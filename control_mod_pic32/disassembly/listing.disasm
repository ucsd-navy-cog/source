Disassembly Listing for EEG64-PIC32
Generated From:
/Users/mikechi/Dropbox/Cognionics/Projects/EEG 64/Firmware/PIC32 DAQ/EEG64-PIC32.X/dist/default/production/EEG64-PIC32.X.production.elf
Sep 22, 2013 9:29:31 PM

---  /Volumes/home/c11067/xc32/build/gcc/libgcc2.c  -----------------------------------------------------
9D00B790  00C04021   ADDU T0, A2, ZERO
9D00BBF0  00C01021   ADDU V0, A2, ZERO
9D00B794  00804821   ADDU T1, A0, ZERO
9D00BBF4  00804021   ADDU T0, A0, ZERO
9D00B798  14E0003B   BNE A3, ZERO, 0x9D00B888
9D00B79C  00A01821   ADDU V1, A1, ZERO
9D00BBF8  14E0003D   BNE A3, ZERO, 0x9D00BCF0
9D00BBFC  00A01821   ADDU V1, A1, ZERO
9D00B7A0  00A6102B   SLTU V0, A1, A2
9D00B7A4  10400048   BEQ V0, ZERO, 0x9D00B8C8
9D00B7A8  70C21020   CLZ V0, A2
9D00BC00  00A6302B   SLTU A2, A1, A2
9D00BC04  10C00046   BEQ A2, ZERO, 0x9D00BD20
9D00BC08  00000000   NOP
9D00BC0C  70442020   CLZ A0, V0
9D00B7AC  50400008   BEQL V0, ZERO, 0x9D00B7D0
9D00B7B0  00083402   SRL A2, T0, 16
9D00BC10  10800008   BEQ A0, ZERO, 0x9D00BC34
9D00BC14  00022C02   SRL A1, V0, 16
9D00B7C0  00464004   SLLV T0, A2, V0
9D00BC24  00821004   SLLV V0, V0, A0
9D00B7B4  00022023   SUBU A0, ZERO, V0
9D00B7B8  00892006   SRLV A0, T1, A0
9D00B7BC  00451804   SLLV V1, A1, V0
9D00B7C4  00831825   OR V1, A0, V1
9D00BC18  00042823   SUBU A1, ZERO, A0
9D00BC1C  00A82806   SRLV A1, T0, A1
9D00BC20  00831804   SLLV V1, V1, A0
9D00BC28  00A31825   OR V1, A1, V1
9D00B7C8  00494804   SLLV T1, T1, V0
9D00BC2C  00884004   SLLV T0, T0, A0
9D00B7CC  00083402   SRL A2, T0, 16
9D00B7D0  0066001B   DIVU V1, A2
9D00B7D4  00C001F4   TEQ A2, ZERO
9D00B7D8  310CFFFF   ANDI T4, T0, -1
9D00B7DC  00092402   SRL A0, T1, 16
9D00B7E0  00005812   MFLO T3
9D00B7E4  00005010   MFHI T2
9D00B7E8  000A5400   SLL T2, T2, 16
9D00B7EC  01445025   OR T2, T2, A0
9D00B7F0  716C5802   MUL T3, T3, T4
9D00B7F4  014B682B   SLTU T5, T2, T3
9D00B7F8  0066001B   DIVU V1, A2
9D00B7FC  00C001F4   TEQ A2, ZERO
9D00B800  51A00009   BEQL T5, ZERO, 0x9D00B828
9D00B804  014B5023   SUBU T2, T2, T3
9D00B808  01485021   ADDU T2, T2, T0
9D00B80C  0148182B   SLTU V1, T2, T0
9D00B810  54600005   BNEL V1, ZERO, 0x9D00B828
9D00B814  014B5023   SUBU T2, T2, T3
9D00B818  014B182B   SLTU V1, T2, T3
9D00B81C  70682002   MUL A0, V1, T0
9D00B820  008A5021   ADDU T2, A0, T2
9D00B824  014B5023   SUBU T2, T2, T3
9D00B828  0146001B   DIVU T2, A2
9D00B82C  00C001F4   TEQ A2, ZERO
9D00B830  3129FFFF   ANDI T1, T1, -1
9D00B834  00002012   MFLO A0
9D00B838  00001810   MFHI V1
9D00B83C  00031C00   SLL V1, V1, 16
9D00B840  00694825   OR T1, V1, T1
9D00B844  708C2002   MUL A0, A0, T4
9D00B848  0124182B   SLTU V1, T1, A0
9D00B84C  0146001B   DIVU T2, A2
9D00B850  00C001F4   TEQ A2, ZERO
9D00B854  50600009   BEQL V1, ZERO, 0x9D00B87C
9D00B858  01244823   SUBU T1, T1, A0
9D00B85C  01284821   ADDU T1, T1, T0
9D00B860  0128182B   SLTU V1, T1, T0
9D00B864  54600005   BNEL V1, ZERO, 0x9D00B87C
9D00B868  01244823   SUBU T1, T1, A0
9D00B86C  0124182B   SLTU V1, T1, A0
9D00B870  70682802   MUL A1, V1, T0
9D00B874  00A94821   ADDU T1, A1, T1
9D00B878  01244823   SUBU T1, T1, A0
9D00BC30  00022C02   SRL A1, V0, 16
9D00BC34  0065001B   DIVU V1, A1
9D00BC38  00A001F4   TEQ A1, ZERO
9D00BC3C  304AFFFF   ANDI T2, V0, -1
9D00BC40  00085C02   SRL T3, T0, 16
9D00BC44  00004812   MFLO T1
9D00BC48  00003810   MFHI A3
9D00BC4C  00073C00   SLL A3, A3, 16
9D00BC50  00EB3825   OR A3, A3, T3
9D00BC54  712A2002   MUL A0, T1, T2
9D00BC58  00E4302B   SLTU A2, A3, A0
9D00BC5C  0065001B   DIVU V1, A1
9D00BC60  00A001F4   TEQ A1, ZERO
9D00BC64  10C0000B   BEQ A2, ZERO, 0x9D00BC94
9D00BC68  00E41823   SUBU V1, A3, A0
9D00BC6C  00E23821   ADDU A3, A3, V0
9D00BC70  00E2182B   SLTU V1, A3, V0
9D00BC74  14600006   BNE V1, ZERO, 0x9D00BC90
9D00BC78  2529FFFF   ADDIU T1, T1, -1
9D00BC7C  00E4182B   SLTU V1, A3, A0
9D00BC80  10600004   BEQ V1, ZERO, 0x9D00BC94
9D00BC84  00E41823   SUBU V1, A3, A0
9D00BC88  2529FFFF   ADDIU T1, T1, -1
9D00BC8C  00E23821   ADDU A3, A3, V0
9D00BC90  00E41823   SUBU V1, A3, A0
9D00BC94  0065001B   DIVU V1, A1
9D00BC98  00A001F4   TEQ A1, ZERO
9D00BC9C  3108FFFF   ANDI T0, T0, -1
9D00BCA0  00002012   MFLO A0
9D00BCA4  00003010   MFHI A2
9D00BCA8  00063400   SLL A2, A2, 16
9D00BCAC  00C84025   OR T0, A2, T0
9D00BCB0  708A5002   MUL T2, A0, T2
9D00BCB4  010A302B   SLTU A2, T0, T2
9D00BCB8  0065001B   DIVU V1, A1
9D00BCBC  00A001F4   TEQ A1, ZERO
9D00BCC0  10C00006   BEQ A2, ZERO, 0x9D00BCDC
9D00BCC4  01024021   ADDU T0, T0, V0
9D00BCC8  0102102B   SLTU V0, T0, V0
9D00BCCC  14400003   BNE V0, ZERO, 0x9D00BCDC
9D00BCD0  2484FFFF   ADDIU A0, A0, -1
9D00BCD4  010A502B   SLTU T2, T0, T2
9D00BCD8  008A2023   SUBU A0, A0, T2
9D00BCDC  00094C00   SLL T1, T1, 16
9D00BCE0  00892025   OR A0, A0, T1
9D00BCE4  00001821   ADDU V1, ZERO, ZERO
9D00B8C8  14C00006   BNE A2, ZERO, 0x9D00B8E4
9D00B8CC  71021020   CLZ V0, T0
9D00BD20  14400006   BNE V0, ZERO, 0x9D00BD3C
9D00BD24  70463020   CLZ A2, V0
9D00B8D0  24020001   ADDIU V0, ZERO, 1
9D00B8D4  0046001B   DIVU V0, A2
9D00B8D8  00C001F4   TEQ A2, ZERO
9D00B8DC  00004012   MFLO T0
9D00BD28  24030001   ADDIU V1, ZERO, 1
9D00BD2C  0062001B   DIVU V1, V0
9D00BD30  004001F4   TEQ V0, ZERO
9D00BD34  00001012   MFLO V0
9D00B8E0  71021020   CLZ V0, T0
9D00BD38  70463020   CLZ A2, V0
9D00B8E4  5440007C   BNEL V0, ZERO, 0x9D00BAD8
9D00B8E8  24090020   ADDIU T1, ZERO, 32
9D00BD3C  54C00077   BNEL A2, ZERO, 0x9D00BF1C
9D00BD40  24080020   ADDIU T0, ZERO, 32
9D00B8EC  00A82823   SUBU A1, A1, T0
9D00B8F0  00081C02   SRL V1, T0, 16
9D00B8F4  3107FFFF   ANDI A3, T0, -1
9D00BD44  00A24823   SUBU T1, A1, V0
9D00BD48  00023C02   SRL A3, V0, 16
9D00BD4C  304CFFFF   ANDI T4, V0, -1
9D00BD50  24030001   ADDIU V1, ZERO, 1
9D00BAD8  01224823   SUBU T1, T1, V0
9D00BF20  01064023   SUBU T0, T0, A2
9D00BADC  00484004   SLLV T0, T0, V0
9D00BF1C  00C21004   SLLV V0, V0, A2
9D00BAE0  01253006   SRLV A2, A1, T1
9D00BF24  01055006   SRLV T2, A1, T0
9D00BAF4  01245806   SRLV T3, A0, T1
9D00BAF8  00452804   SLLV A1, A1, V0
9D00BAFC  01655825   OR T3, T3, A1
9D00BF34  01044006   SRLV T0, A0, T0
9D00BF38  00C52804   SLLV A1, A1, A2
9D00BF40  01052825   OR A1, T0, A1
9D00BB04  00444804   SLLV T1, A0, V0
9D00BF44  00C44004   SLLV T0, A0, A2
9D00BAE4  00081C02   SRL V1, T0, 16
9D00BAE8  00C3001B   DIVU A2, V1
9D00BAEC  006001F4   TEQ V1, ZERO
9D00BAF0  3107FFFF   ANDI A3, T0, -1
9D00BB00  000B2C02   SRL A1, T3, 16
9D00BB08  00005012   MFLO T2
9D00BB0C  00006010   MFHI T4
9D00BB10  000C2400   SLL A0, T4, 16
9D00BB14  00A42025   OR A0, A1, A0
9D00BB18  71475002   MUL T2, T2, A3
9D00BB1C  008A282B   SLTU A1, A0, T2
9D00BB20  00C3001B   DIVU A2, V1
9D00BB24  006001F4   TEQ V1, ZERO
9D00BB28  50A00006   BEQL A1, ZERO, 0x9D00BB44
9D00BB2C  008A2023   SUBU A0, A0, T2
9D00BB30  00882021   ADDU A0, A0, T0
9D00BB34  0088282B   SLTU A1, A0, T0
9D00BB38  10A00024   BEQ A1, ZERO, 0x9D00BBCC
9D00BB3C  008A282B   SLTU A1, A0, T2
9D00BB40  008A2023   SUBU A0, A0, T2
9D00BB44  0083001B   DIVU A0, V1
9D00BB48  006001F4   TEQ V1, ZERO
9D00BB4C  316BFFFF   ANDI T3, T3, -1
9D00BB50  00003012   MFLO A2
9D00BB54  00002810   MFHI A1
9D00BB58  00052C00   SLL A1, A1, 16
9D00BB5C  00AB2825   OR A1, A1, T3
9D00BB60  70C73002   MUL A2, A2, A3
9D00BB64  00A6502B   SLTU T2, A1, A2
9D00BB68  0083001B   DIVU A0, V1
9D00BB6C  006001F4   TEQ V1, ZERO
9D00BB70  5140FF61   BEQL T2, ZERO, 0x9D00B8F8
9D00BB74  00A62823   SUBU A1, A1, A2
9D00BB78  00A82821   ADDU A1, A1, T0
9D00BB7C  00A8202B   SLTU A0, A1, T0
9D00BB80  5480FF5D   BNEL A0, ZERO, 0x9D00B8F8
9D00BB84  00A62823   SUBU A1, A1, A2
9D00BB88  00A6202B   SLTU A0, A1, A2
9D00BB8C  70885002   MUL T2, A0, T0
9D00BB90  01452821   ADDU A1, T2, A1
9D00BB94  0B402E3E   J 0x9D00B8F8
9D00BB98  00A62823   SUBU A1, A1, A2
9D00BBCC  70A83002   MUL A2, A1, T0
9D00BBD0  0B402ED0   J 0x9D00BB40
9D00BBD4  00C42021   ADDU A0, A2, A0
9D00BF28  00023C02   SRL A3, V0, 16
9D00BF2C  0147001B   DIVU T2, A3
9D00BF30  00E001F4   TEQ A3, ZERO
9D00BF3C  304CFFFF   ANDI T4, V0, -1
9D00BF48  00054C02   SRL T1, A1, 16
9D00BF4C  00001812   MFLO V1
9D00BF50  00005810   MFHI T3
9D00BF54  000B2400   SLL A0, T3, 16
9D00BF58  01242025   OR A0, T1, A0
9D00BF5C  00003012   MFLO A2
9D00BF60  706C1802   MUL V1, V1, T4
9D00BF64  0083482B   SLTU T1, A0, V1
9D00BF68  0147001B   DIVU T2, A3
9D00BF6C  00E001F4   TEQ A3, ZERO
9D00BF70  5120000B   BEQL T1, ZERO, 0x9D00BFA0
9D00BF74  00832023   SUBU A0, A0, V1
9D00BF78  00822021   ADDU A0, A0, V0
9D00BF7C  0082482B   SLTU T1, A0, V0
9D00BF80  15200006   BNE T1, ZERO, 0x9D00BF9C
9D00BF84  24C6FFFF   ADDIU A2, A2, -1
9D00BF88  0083482B   SLTU T1, A0, V1
9D00BF8C  51200004   BEQL T1, ZERO, 0x9D00BFA0
9D00BF90  00832023   SUBU A0, A0, V1
9D00BF94  24C6FFFF   ADDIU A2, A2, -1
9D00BF98  00822021   ADDU A0, A0, V0
9D00BF9C  00832023   SUBU A0, A0, V1
9D00BFA0  0087001B   DIVU A0, A3
9D00BFA4  00E001F4   TEQ A3, ZERO
9D00BFA8  30AAFFFF   ANDI T2, A1, -1
9D00BFAC  00001812   MFLO V1
9D00BFB0  00004810   MFHI T1
9D00BFB4  00094C00   SLL T1, T1, 16
9D00BFB8  012A4825   OR T1, T1, T2
9D00BFBC  706C2802   MUL A1, V1, T4
9D00BFC0  0125502B   SLTU T2, T1, A1
9D00BFC4  0087001B   DIVU A0, A3
9D00BFC8  00E001F4   TEQ A3, ZERO
9D00BFCC  5140000B   BEQL T2, ZERO, 0x9D00BFFC
9D00BFD0  00063400   SLL A2, A2, 16
9D00BFD4  01224821   ADDU T1, T1, V0
9D00BFD8  0122202B   SLTU A0, T1, V0
9D00BFDC  14800006   BNE A0, ZERO, 0x9D00BFF8
9D00BFE0  2463FFFF   ADDIU V1, V1, -1
9D00BFE4  0125202B   SLTU A0, T1, A1
9D00BFE8  50800004   BEQL A0, ZERO, 0x9D00BFFC
9D00BFEC  00063400   SLL A2, A2, 16
9D00BFF0  2463FFFF   ADDIU V1, V1, -1
9D00BFF4  01224821   ADDU T1, T1, V0
9D00BFF8  00063400   SLL A2, A2, 16
9D00BFFC  01254823   SUBU T1, T1, A1
9D00C000  0B402F55   J 0x9D00BD54
9D00C004  00661825   OR V1, V1, A2
9D00B8F8  00A3001B   DIVU A1, V1
9D00B8FC  006001F4   TEQ V1, ZERO
9D00B900  00095402   SRL T2, T1, 16
9D00B904  00002012   MFLO A0
9D00B908  00003010   MFHI A2
9D00B90C  00063400   SLL A2, A2, 16
9D00B910  00CA3025   OR A2, A2, T2
9D00B914  70872002   MUL A0, A0, A3
9D00B918  00C4502B   SLTU T2, A2, A0
9D00B91C  00A3001B   DIVU A1, V1
9D00B920  006001F4   TEQ V1, ZERO
9D00B924  51400009   BEQL T2, ZERO, 0x9D00B94C
9D00B928  00C43023   SUBU A2, A2, A0
9D00B92C  00C83021   ADDU A2, A2, T0
9D00B930  00C8282B   SLTU A1, A2, T0
9D00B934  54A00005   BNEL A1, ZERO, 0x9D00B94C
9D00B938  00C43023   SUBU A2, A2, A0
9D00B93C  00C4282B   SLTU A1, A2, A0
9D00B940  70A85002   MUL T2, A1, T0
9D00B944  01463021   ADDU A2, T2, A2
9D00B948  00C43023   SUBU A2, A2, A0
9D00B94C  00C3001B   DIVU A2, V1
9D00B950  006001F4   TEQ V1, ZERO
9D00B954  3129FFFF   ANDI T1, T1, -1
9D00B958  00005012   MFLO T2
9D00B95C  00002010   MFHI A0
9D00B960  00042400   SLL A0, A0, 16
9D00B964  00894825   OR T1, A0, T1
9D00B968  71473802   MUL A3, T2, A3
9D00B96C  0127202B   SLTU A0, T1, A3
9D00B970  00C3001B   DIVU A2, V1
9D00B974  006001F4   TEQ V1, ZERO
9D00B978  50800009   BEQL A0, ZERO, 0x9D00B9A0
9D00B97C  01274823   SUBU T1, T1, A3
9D00B980  01284821   ADDU T1, T1, T0
9D00B984  0128182B   SLTU V1, T1, T0
9D00B988  54600005   BNEL V1, ZERO, 0x9D00B9A0
9D00B98C  01274823   SUBU T1, T1, A3
9D00B990  0127182B   SLTU V1, T1, A3
9D00B994  70682002   MUL A0, V1, T0
9D00B998  00894821   ADDU T1, A0, T1
9D00B99C  01274823   SUBU T1, T1, A3
9D00BD54  0127001B   DIVU T1, A3
9D00BD58  00E001F4   TEQ A3, ZERO
9D00BD5C  00086C02   SRL T5, T0, 16
9D00BD60  00005812   MFLO T3
9D00BD64  00005010   MFHI T2
9D00BD68  000A5400   SLL T2, T2, 16
9D00BD6C  014D5025   OR T2, T2, T5
9D00BD70  716C2002   MUL A0, T3, T4
9D00BD74  0144302B   SLTU A2, T2, A0
9D00BD78  0127001B   DIVU T1, A3
9D00BD7C  00E001F4   TEQ A3, ZERO
9D00BD80  10C00009   BEQ A2, ZERO, 0x9D00BDA8
9D00BD84  01442823   SUBU A1, T2, A0
9D00BD88  01425021   ADDU T2, T2, V0
9D00BD8C  0142282B   SLTU A1, T2, V0
9D00BD90  14A00004   BNE A1, ZERO, 0x9D00BDA4
9D00BD94  256BFFFF   ADDIU T3, T3, -1
9D00BD98  0144282B   SLTU A1, T2, A0
9D00BD9C  54A000A2   BNEL A1, ZERO, 0x9D00C028
9D00BDA0  256BFFFF   ADDIU T3, T3, -1
9D00BDA4  01442823   SUBU A1, T2, A0
9D00BDA8  00A7001B   DIVU A1, A3
9D00BDAC  00E001F4   TEQ A3, ZERO
9D00BDB0  3108FFFF   ANDI T0, T0, -1
9D00BDB4  00002012   MFLO A0
9D00BDB8  00003010   MFHI A2
9D00BDBC  00063400   SLL A2, A2, 16
9D00BDC0  00C84025   OR T0, A2, T0
9D00BDC4  708C6002   MUL T4, A0, T4
9D00BDC8  010C302B   SLTU A2, T0, T4
9D00BDCC  00A7001B   DIVU A1, A3
9D00BDD0  00E001F4   TEQ A3, ZERO
9D00BDD4  10C00006   BEQ A2, ZERO, 0x9D00BDF0
9D00BDD8  01024021   ADDU T0, T0, V0
9D00BDDC  0102102B   SLTU V0, T0, V0
9D00BDE0  14400003   BNE V0, ZERO, 0x9D00BDF0
9D00BDE4  2484FFFF   ADDIU A0, A0, -1
9D00BDE8  010C602B   SLTU T4, T0, T4
9D00BDEC  008C2023   SUBU A0, A0, T4
9D00BDF0  000B5C00   SLL T3, T3, 16
9D00BDF4  008B2025   OR A0, A0, T3
9D00C028  0B402F69   J 0x9D00BDA4
9D00C02C  01425021   ADDU T2, T2, V0
9D00B87C  00491006   SRLV V0, T1, V0
9D00B9A0  00491006   SRLV V0, T1, V0
9D00B880  03E00008   JR RA
9D00B884  00001821   ADDU V1, ZERO, ZERO
9D00B9A4  03E00008   JR RA
9D00B9A8  00001821   ADDU V1, ZERO, ZERO
9D00B888  00A7102B   SLTU V0, A1, A3
9D00B88C  14400047   BNE V0, ZERO, 0x9D00B9AC
9D00B890  70E84020   CLZ T0, A3
9D00BCF0  00A7102B   SLTU V0, A1, A3
9D00BCF4  54400042   BNEL V0, ZERO, 0x9D00BE00
9D00BCF8  00002021   ADDU A0, ZERO, ZERO
9D00BE00  00001821   ADDU V1, ZERO, ZERO
9D00B9AC  00801021   ADDU V0, A0, ZERO
9D00B9B0  03E00008   JR RA
9D00B9B4  00A01821   ADDU V1, A1, ZERO
9D00BCFC  70E31820   CLZ V1, A3
9D00B894  15000048   BNE T0, ZERO, 0x9D00B9B8
9D00B898  240A0020   ADDIU T2, ZERO, 32
9D00BD00  14600042   BNE V1, ZERO, 0x9D00BE0C
9D00BD04  240B0020   ADDIU T3, ZERO, 32
9D00B89C  00E5102B   SLTU V0, A3, A1
9D00B8A0  14400005   BNE V0, ZERO, 0x9D00B8B8
9D00B8A4  00861023   SUBU V0, A0, A2
9D00B8A8  0086402B   SLTU T0, A0, A2
9D00B8AC  15000088   BNE T0, ZERO, 0x9D00BAD0
9D00B8B0  00801021   ADDU V0, A0, ZERO
9D00BD08  00E5282B   SLTU A1, A3, A1
9D00BD0C  54A000C4   BNEL A1, ZERO, 0x9D00C020
9D00BD10  00001821   ADDU V1, ZERO, ZERO
9D00BD14  0086202B   SLTU A0, A0, A2
9D00BD18  0B402F3A   J 0x9D00BCE8
9D00BD1C  2C840001   SLTIU A0, A0, 1
9D00C020  0B402F3A   J 0x9D00BCE8
9D00C024  24040001   ADDIU A0, ZERO, 1
9D00B8B4  00861023   SUBU V0, A0, A2
9D00B8B8  00A71823   SUBU V1, A1, A3
9D00B8BC  0082202B   SLTU A0, A0, V0
9D00B8C0  03E00008   JR RA
9D00B8C4  00641823   SUBU V1, V1, A0
9D00B9B8  01485023   SUBU T2, T2, T0
9D00BE0C  01635823   SUBU T3, T3, V1
9D00B9BC  01461006   SRLV V0, A2, T2
9D00B9C0  01073804   SLLV A3, A3, T0
9D00B9C4  00473825   OR A3, V0, A3
9D00BE10  01661006   SRLV V0, A2, T3
9D00BE14  00673804   SLLV A3, A3, V1
9D00BE18  00473825   OR A3, V0, A3
9D00B9EC  01063004   SLLV A2, A2, T0
9D00B9C8  01455806   SRLV T3, A1, T2
9D00BE1C  01654806   SRLV T1, A1, T3
9D00B9DC  01441806   SRLV V1, A0, T2
9D00B9E0  01052804   SLLV A1, A1, T0
9D00B9E4  00652825   OR A1, V1, A1
9D00BE30  01645806   SRLV T3, A0, T3
9D00BE34  00652804   SLLV A1, A1, V1
9D00BE38  01652825   OR A1, T3, A1
9D00B9CC  00074C02   SRL T1, A3, 16
9D00B9D0  0169001B   DIVU T3, T1
9D00B9D4  012001F4   TEQ T1, ZERO
9D00B9D8  30EDFFFF   ANDI T5, A3, -1
9D00B9E8  00051C02   SRL V1, A1, 16
9D00B9F0  00006012   MFLO T4
9D00B9F4  00001010   MFHI V0
9D00B9F8  00021400   SLL V0, V0, 16
9D00B9FC  00431025   OR V0, V0, V1
9D00BA00  718D7002   MUL T6, T4, T5
9D00BA04  004E182B   SLTU V1, V0, T6
9D00BA08  0169001B   DIVU T3, T1
9D00BA0C  012001F4   TEQ T1, ZERO
9D00BA10  1060000A   BEQ V1, ZERO, 0x9D00BA3C
9D00BA14  01042004   SLLV A0, A0, T0
9D00BA18  00471021   ADDU V0, V0, A3
9D00BA1C  0047182B   SLTU V1, V0, A3
9D00BA20  14600006   BNE V1, ZERO, 0x9D00BA3C
9D00BA24  258CFFFF   ADDIU T4, T4, -1
9D00BA28  004E182B   SLTU V1, V0, T6
9D00BA2C  50600004   BEQL V1, ZERO, 0x9D00BA40
9D00BA30  004E1023   SUBU V0, V0, T6
9D00BA34  258CFFFF   ADDIU T4, T4, -1
9D00BA38  00471021   ADDU V0, V0, A3
9D00BA3C  004E1023   SUBU V0, V0, T6
9D00BA40  0049001B   DIVU V0, T1
9D00BA44  012001F4   TEQ T1, ZERO
9D00BA48  30A5FFFF   ANDI A1, A1, -1
9D00BA4C  00005812   MFLO T3
9D00BA50  00001810   MFHI V1
9D00BA54  00031C00   SLL V1, V1, 16
9D00BA58  00652825   OR A1, V1, A1
9D00BA5C  716D6802   MUL T5, T3, T5
9D00BA60  00AD182B   SLTU V1, A1, T5
9D00BA64  0049001B   DIVU V0, T1
9D00BA68  012001F4   TEQ T1, ZERO
9D00BA6C  50600006   BEQL V1, ZERO, 0x9D00BA88
9D00BA70  000C6400   SLL T4, T4, 16
9D00BA74  00A72821   ADDU A1, A1, A3
9D00BA78  00A7102B   SLTU V0, A1, A3
9D00BA7C  1040004D   BEQ V0, ZERO, 0x9D00BBB4
9D00BA80  256BFFFF   ADDIU T3, T3, -1
9D00BA84  000C6400   SLL T4, T4, 16
9D00BA88  016C5825   OR T3, T3, T4
9D00BA90  00AD2823   SUBU A1, A1, T5
9D00BBB4  00AD102B   SLTU V0, A1, T5
9D00BBB8  5040FFB3   BEQL V0, ZERO, 0x9D00BA88
9D00BBBC  000C6400   SLL T4, T4, 16
9D00BBC0  256BFFFF   ADDIU T3, T3, -1
9D00BBC4  0B402EA1   J 0x9D00BA84
9D00BBC8  00A72821   ADDU A1, A1, A3
9D00BE20  00071402   SRL V0, A3, 16
9D00BE24  0122001B   DIVU T1, V0
9D00BE28  004001F4   TEQ V0, ZERO
9D00BE2C  30ECFFFF   ANDI T4, A3, -1
9D00BE3C  00055C02   SRL T3, A1, 16
9D00BE40  00005012   MFLO T2
9D00BE44  00004010   MFHI T0
9D00BE48  00084400   SLL T0, T0, 16
9D00BE4C  010B4025   OR T0, T0, T3
9D00BE50  714C6802   MUL T5, T2, T4
9D00BE54  010D582B   SLTU T3, T0, T5
9D00BE58  0122001B   DIVU T1, V0
9D00BE5C  004001F4   TEQ V0, ZERO
9D00BE60  1160000A   BEQ T3, ZERO, 0x9D00BE8C
9D00BE64  00663004   SLLV A2, A2, V1
9D00BE68  01074021   ADDU T0, T0, A3
9D00BE6C  0107482B   SLTU T1, T0, A3
9D00BE70  15200006   BNE T1, ZERO, 0x9D00BE8C
9D00BE74  254AFFFF   ADDIU T2, T2, -1
9D00BE78  010D482B   SLTU T1, T0, T5
9D00BE7C  51200004   BEQL T1, ZERO, 0x9D00BE90
9D00BE80  010D4023   SUBU T0, T0, T5
9D00BE84  254AFFFF   ADDIU T2, T2, -1
9D00BE88  01074021   ADDU T0, T0, A3
9D00BE8C  010D4023   SUBU T0, T0, T5
9D00BE90  0102001B   DIVU T0, V0
9D00BE94  004001F4   TEQ V0, ZERO
9D00BE98  30A5FFFF   ANDI A1, A1, -1
9D00BE9C  00004812   MFLO T1
9D00BEA0  00005810   MFHI T3
9D00BEA4  000B5C00   SLL T3, T3, 16
9D00BEA8  01652825   OR A1, T3, A1
9D00BEAC  712C6002   MUL T4, T1, T4
9D00BEB0  00AC582B   SLTU T3, A1, T4
9D00BEB4  0102001B   DIVU T0, V0
9D00BEB8  004001F4   TEQ V0, ZERO
9D00BEBC  5160000B   BEQL T3, ZERO, 0x9D00BEEC
9D00BEC0  000A5400   SLL T2, T2, 16
9D00BEC4  00A72821   ADDU A1, A1, A3
9D00BEC8  00A7102B   SLTU V0, A1, A3
9D00BECC  14400006   BNE V0, ZERO, 0x9D00BEE8
9D00BED0  2529FFFF   ADDIU T1, T1, -1
9D00BED4  00AC102B   SLTU V0, A1, T4
9D00BED8  50400004   BEQL V0, ZERO, 0x9D00BEEC
9D00BEDC  000A5400   SLL T2, T2, 16
9D00BEE0  2529FFFF   ADDIU T1, T1, -1
9D00BEE4  00A72821   ADDU A1, A1, A3
9D00BEE8  000A5400   SLL T2, T2, 16
9D00BEEC  012A4825   OR T1, T1, T2
9D00BEF4  00AC2823   SUBU A1, A1, T4
9D00BA8C  01660019   MULTU T3, A2
9D00BA94  0000C810   MFHI T9
9D00BA9C  03207021   ADDU T6, T9, ZERO
9D00BAB0  00001012   MFLO V0
9D00BEF0  01260019   MULTU T1, A2
9D00BEF8  00005810   MFHI T3
9D00BA98  00B9682B   SLTU T5, A1, T9
9D00BAA0  15A0003E   BNE T5, ZERO, 0x9D00BB9C
9D00BAA4  00004812   MFLO T1
9D00BAA8  10B9004B   BEQ A1, T9, 0x9D00BBD8
9D00BAAC  00B91823   SUBU V1, A1, T9
9D00BBD8  0089182B   SLTU V1, A0, T1
9D00BBDC  5460FFF0   BNEL V1, ZERO, 0x9D00BBA0
9D00BBE0  01261023   SUBU V0, T1, A2
9D00BBE4  00001012   MFLO V0
9D00BBE8  0B402EAD   J 0x9D00BAB4
9D00BBEC  00001821   ADDU V1, ZERO, ZERO
9D00BEFC  00AB382B   SLTU A3, A1, T3
9D00BF00  14E00044   BNE A3, ZERO, 0x9D00C014
9D00BF04  00005012   MFLO T2
9D00BF08  50AB003F   BEQL A1, T3, 0x9D00C008
9D00BF0C  00641804   SLLV V1, A0, V1
9D00BF10  01202021   ADDU A0, T1, ZERO
9D00BF14  0B402F3A   J 0x9D00BCE8
9D00BF18  00001821   ADDU V1, ZERO, ZERO
9D00C008  006A182B   SLTU V1, V1, T2
9D00C00C  1060FF36   BEQ V1, ZERO, 0x9D00BCE8
9D00C010  01202021   ADDU A0, T1, ZERO
9D00C014  2524FFFF   ADDIU A0, T1, -1
9D00C018  0B402F3A   J 0x9D00BCE8
9D00C01C  00001821   ADDU V1, ZERO, ZERO
9D00BB9C  01261023   SUBU V0, T1, A2
9D00BBA0  01C71823   SUBU V1, T6, A3
9D00BBA4  0122482B   SLTU T1, T1, V0
9D00BBA8  00691823   SUBU V1, V1, T1
9D00BBAC  0B402EAD   J 0x9D00BAB4
9D00BBB0  00A31823   SUBU V1, A1, V1
9D00BAB4  00821023   SUBU V0, A0, V0
9D00BAB8  0082202B   SLTU A0, A0, V0
9D00BABC  00641823   SUBU V1, V1, A0
9D00BAC0  01435004   SLLV T2, V1, T2
9D00BAC4  01021006   SRLV V0, V0, T0
9D00BAC8  004A1025   OR V0, V0, T2
9D00BACC  01031806   SRLV V1, V1, T0
9D00BAD0  03E00008   JR RA
9D00BAD4  00000000   NOP
9D00BCE8  03E00008   JR RA
9D00BCEC  00801021   ADDU V0, A0, ZERO
9D00BDF8  03E00008   JR RA
9D00BDFC  00801021   ADDU V0, A0, ZERO
9D00BE04  03E00008   JR RA
9D00BE08  00801021   ADDU V0, A0, ZERO
---  /Users/mikechi/Dropbox/Cognionics/Projects/EEG 64/Firmware/PIC32 DAQ/EEG64-PIC32.X/pic32_delay.c  --
1:                   #include <plib.h>
2:                   #include "port_defs.h"
3:                   #include "pic32_delay.h"
4:                   
5:                   void DelayUS(int us) {
9D00C6F0  27BDFFF0   ADDIU SP, SP, -16
9D00C6F4  AFBE000C   SW S8, 12(SP)
9D00C6F8  03A0F021   ADDU S8, SP, ZERO
9D00C6FC  AFC40010   SW A0, 16(S8)
6:                       DWORD start = _CP0_GET_COUNT();
9D00C700  40024800   MFC0 V0, Count
9D00C704  AFC20000   SW V0, 0(S8)
7:                       DWORD end = start + SYSCLK / 1000000 / 2 * us;
9D00C708  8FC30010   LW V1, 16(S8)
9D00C70C  2402000B   ADDIU V0, ZERO, 11
9D00C710  70621002   MUL V0, V1, V0
9D00C714  00401821   ADDU V1, V0, ZERO
9D00C718  8FC20000   LW V0, 0(S8)
9D00C71C  00621021   ADDU V0, V1, V0
9D00C720  AFC20004   SW V0, 4(S8)
8:                       if (end > start) while (_CP0_GET_COUNT() < end);
9D00C724  8FC30004   LW V1, 4(S8)
9D00C728  8FC20000   LW V0, 0(S8)
9D00C72C  0043102B   SLTU V0, V0, V1
9D00C730  10400009   BEQ V0, ZERO, 0x9D00C758
9D00C734  00000000   NOP
9D00C738  00000000   NOP
9D00C73C  40034800   MFC0 V1, Count
9D00C740  8FC20004   LW V0, 4(S8)
9D00C744  0062102B   SLTU V0, V1, V0
9D00C748  1440FFFC   BNE V0, ZERO, 0x9D00C73C
9D00C74C  00000000   NOP
9D00C750  0B4031E1   J 0x9D00C784
9D00C754  00000000   NOP
9:                       else while (_CP0_GET_COUNT() > start || _CP0_GET_COUNT() < end);
9D00C758  00000000   NOP
9D00C75C  40034800   MFC0 V1, Count
9D00C760  8FC20000   LW V0, 0(S8)
9D00C764  0043102B   SLTU V0, V0, V1
9D00C768  1440FFFC   BNE V0, ZERO, 0x9D00C75C
9D00C76C  00000000   NOP
9D00C770  40034800   MFC0 V1, Count
9D00C774  8FC20004   LW V0, 4(S8)
9D00C778  0062102B   SLTU V0, V1, V0
9D00C77C  1440FFF7   BNE V0, ZERO, 0x9D00C75C
9D00C780  00000000   NOP
10:                  }
9D00C784  03C0E821   ADDU SP, S8, ZERO
9D00C788  8FBE000C   LW S8, 12(SP)
9D00C78C  27BD0010   ADDIU SP, SP, 16
9D00C790  03E00008   JR RA
9D00C794  00000000   NOP
11:                  
12:                  void DelayMS(int ms) {
9D00C798  27BDFFF0   ADDIU SP, SP, -16
9D00C79C  AFBE000C   SW S8, 12(SP)
9D00C7A0  03A0F021   ADDU S8, SP, ZERO
9D00C7A4  AFC40010   SW A0, 16(S8)
13:                      DWORD start = _CP0_GET_COUNT();
9D00C7A8  40024800   MFC0 V0, Count
9D00C7AC  AFC20000   SW V0, 0(S8)
14:                      DWORD end = start + SYSCLK / 1000 / 2 * ms;
9D00C7B0  8FC30010   LW V1, 16(S8)
9D00C7B4  24022B33   ADDIU V0, ZERO, 11059
9D00C7B8  70621002   MUL V0, V1, V0
9D00C7BC  00401821   ADDU V1, V0, ZERO
9D00C7C0  8FC20000   LW V0, 0(S8)
9D00C7C4  00621021   ADDU V0, V1, V0
9D00C7C8  AFC20004   SW V0, 4(S8)
15:                      if (end > start) while (_CP0_GET_COUNT() < end);
9D00C7CC  8FC30004   LW V1, 4(S8)
9D00C7D0  8FC20000   LW V0, 0(S8)
9D00C7D4  0043102B   SLTU V0, V0, V1
9D00C7D8  10400009   BEQ V0, ZERO, 0x9D00C800
9D00C7DC  00000000   NOP
9D00C7E0  00000000   NOP
9D00C7E4  40034800   MFC0 V1, Count
9D00C7E8  8FC20004   LW V0, 4(S8)
9D00C7EC  0062102B   SLTU V0, V1, V0
9D00C7F0  1440FFFC   BNE V0, ZERO, 0x9D00C7E4
9D00C7F4  00000000   NOP
9D00C7F8  0B40320B   J 0x9D00C82C
9D00C7FC  00000000   NOP
16:                      else while (_CP0_GET_COUNT() > start || _CP0_GET_COUNT() < end);
9D00C800  00000000   NOP
9D00C804  40034800   MFC0 V1, Count
9D00C808  8FC20000   LW V0, 0(S8)
9D00C80C  0043102B   SLTU V0, V0, V1
9D00C810  1440FFFC   BNE V0, ZERO, 0x9D00C804
9D00C814  00000000   NOP
9D00C818  40034800   MFC0 V1, Count
9D00C81C  8FC20004   LW V0, 4(S8)
9D00C820  0062102B   SLTU V0, V1, V0
9D00C824  1440FFF7   BNE V0, ZERO, 0x9D00C804
9D00C828  00000000   NOP
17:                  }
9D00C82C  03C0E821   ADDU SP, S8, ZERO
9D00C830  8FBE000C   LW S8, 12(SP)
9D00C834  27BD0010   ADDIU SP, SP, 16
9D00C838  03E00008   JR RA
9D00C83C  00000000   NOP
---  /Users/mikechi/Dropbox/Cognionics/Projects/EEG 64/Firmware/PIC32 DAQ/EEG64-PIC32.X/memory_buffer.c  
1:                   #include "port_defs.h"
2:                   
3:                   char memBuffer[MEMBUFLEN];
4:                   
5:                   char* Buf0Ptr()
6:                   {
9D00D32C  27BDFFF8   ADDIU SP, SP, -8
9D00D330  AFBE0004   SW S8, 4(SP)
9D00D334  03A0F021   ADDU S8, SP, ZERO
7:                       return &memBuffer[0];
9D00D338  3C02A000   LUI V0, -24576
9D00D33C  24420094   ADDIU V0, V0, 148
8:                   }
9D00D340  03C0E821   ADDU SP, S8, ZERO
9D00D344  8FBE0004   LW S8, 4(SP)
9D00D348  27BD0008   ADDIU SP, SP, 8
9D00D34C  03E00008   JR RA
9D00D350  00000000   NOP
9:                   
10:                  char* Buf1Ptr()
11:                  {
9D00D354  27BDFFF8   ADDIU SP, SP, -8
9D00D358  AFBE0004   SW S8, 4(SP)
9D00D35C  03A0F021   ADDU S8, SP, ZERO
12:                      return &memBuffer[MEMBUFLEN/2];
9D00D360  3C02A000   LUI V0, -24576
9D00D364  24427494   ADDIU V0, V0, 29844
13:                  }
9D00D368  03C0E821   ADDU SP, S8, ZERO
9D00D36C  8FBE0004   LW S8, 4(SP)
9D00D370  27BD0008   ADDIU SP, SP, 8
9D00D374  03E00008   JR RA
9D00D378  00000000   NOP
---  /Users/mikechi/Dropbox/Cognionics/Projects/EEG 64/Firmware/PIC32 DAQ/EEG64-PIC32.X/main.c  ---------
1:                   #include <xc.h>
2:                   #include <plib.h>
3:                   #include "port_defs.h"
4:                   #include "pic32_delay.h"
5:                   #include "battery.h"
6:                   
7:                   #include "fatfs/IOFunc.h"
8:                   #include "fatfs/ff.h"
9:                   
10:                  
11:                  // PIC32MX795F512H Configuration Bit Settings
12:                  // DEVCFG3
13:                  // USERID = No Setting
14:                  #pragma config FSRSSEL = PRIORITY_7     // SRS Select (SRS Priority 7)
15:                  #pragma config FMIIEN = ON              // Ethernet RMII/MII Enable (MII Enabled)
16:                  #pragma config FETHIO = ON              // Ethernet I/O Pin Select (Default Ethernet I/O)
17:                  #pragma config FCANIO = ON              // CAN I/O Pin Select (Default CAN I/O)
18:                  #pragma config FUSBIDIO = OFF           // USB USID Selection (Controlled by Port Function)
19:                  #pragma config FVBUSONIO = OFF          // USB VBUS ON Selection (Controlled by Port Function)
20:                  
21:                  // DEVCFG2
22:                  #pragma config FPLLIDIV = DIV_4        // PLL Input Divider (12x Divider)
23:                  #pragma config FPLLMUL = MUL_16         // PLL Multiplier (24x Multiplier)
24:                  #pragma config UPLLIDIV = DIV_12        // USB PLL Input Divider (12x Divider)
25:                  #pragma config UPLLEN = OFF             // USB PLL Enable (Disabled and Bypassed)
26:                  #pragma config FPLLODIV = DIV_2       // System PLL Output Clock Divider (PLL Divide by 256)
27:                  
28:                  // DEVCFG1
29:                  #pragma config FNOSC = PRIPLL              // Oscillator Selection Bits (Primary Osc (XT,HS,EC))
30:                  #pragma config FSOSCEN = OFF            // Secondary Oscillator Enable (Disabled)
31:                  #pragma config IESO = OFF               // Internal/External Switch Over (Disabled)
32:                  #pragma config POSCMOD = HS             // Primary Oscillator Configuration (HS osc mode)
33:                  #pragma config OSCIOFNC = OFF           // CLKO Output Signal Active on the OSCO Pin (Disabled)
34:                  #pragma config FPBDIV = DIV_1           // Peripheral Clock Divisor (Pb_Clk is Sys_Clk/1)
35:                  #pragma config FCKSM = CSDCMD           // Clock Switching and Monitor Selection (Clock Switch Disable, FSCM Disabled)
36:                  #pragma config WDTPS = PS1048576        // Watchdog Timer Postscaler (1:1048576)
37:                  #pragma config FWDTEN = OFF             // Watchdog Timer Enable (WDT Disabled (SWDTEN Bit Controls))
38:                  
39:                  // DEVCFG0
40:                  #pragma config DEBUG = OFF              // Background Debugger Enable (Debugger is disabled)
41:                  #pragma config ICESEL = ICS_PGx2        // ICE/ICD Comm Channel Select (ICE EMUC2/EMUD2 pins shared with PGC2/PGD2)
42:                  #pragma config PWP = OFF                // Program Flash Write Protect (Disable)
43:                  #pragma config BWP = OFF                // Boot Flash Write Protect bit (Protection Disabled)
44:                  #pragma config CP = OFF                 // Code Protect (Protection Disabled)
45:                  
46:                  
47:                  #define SDTRIES 10
48:                  
49:                  void initPorts();
50:                  void waitForPowerOn();
51:                  void lockOut();
52:                  
53:                  int main()
54:                  {
9D00A9FC  27BDFF98   ADDIU SP, SP, -104
9D00AA00  AFBF0064   SW RA, 100(SP)
9D00AA04  AFBE0060   SW S8, 96(SP)
9D00AA08  03A0F021   ADDU S8, SP, ZERO
55:                      waitForPowerOn();
9D00AA0C  0F402B7D   JAL waitForPowerOn
9D00AA10  00000000   NOP
9D00AA14  3C020151   LUI V0, 337
9D00AA18  34428000   ORI V0, V0, -32768
9D00AA1C  AFC20018   SW V0, 24(S8)
9D00AA20  8FC20018   LW V0, 24(S8)
9D00AA24  AFC2001C   SW V0, 28(S8)
9D00AA28  8FC2001C   LW V0, 28(S8)
9D00AA2C  AFC20020   SW V0, 32(S8)
56:                  
57:                      //configure PIC for maximum performance at the specified clock
58:                      //Note that this overrides the peripheral bus divider to the maximum supported speed
59:                      SYSTEMConfigPerformance(SYSCLK);
60:                  
61:                      //init basic IO pins
62:                      initPorts();
9D00AC8C  0F402C14   JAL initPorts
9D00AC90  00000000   NOP
63:                  
64:                       //init SD card IO pins
65:                      SDPortInit();
9D00AC94  0F402C6F   JAL SDPortInit
9D00AC98  00000000   NOP
66:                  
67:                      //init battery monitoring
68:                      //BatteryInit();
69:                  
70:                      
71:                      //try to startup SD card
72:                      int c;
73:                      int sd_card_opened = 0;
9D00AC9C  AFC00014   SW ZERO, 20(S8)
74:                      for (c = 0; c < SDTRIES; c++) {
9D00ACA0  AFC00010   SW ZERO, 16(S8)
9D00ACA4  0B402B35   J 0x9D00ACD4
9D00ACA8  00000000   NOP
9D00ACC8  8FC20010   LW V0, 16(S8)
9D00ACCC  24420001   ADDIU V0, V0, 1
9D00ACD0  AFC20010   SW V0, 16(S8)
9D00ACD4  8FC20010   LW V0, 16(S8)
9D00ACD8  2842000A   SLTI V0, V0, 10
9D00ACDC  1440FFF3   BNE V0, ZERO, 0x9D00ACAC
9D00ACE0  00000000   NOP
75:                          if (disk_initialize(0) == FR_OK) {
9D00ACAC  00002021   ADDU A0, ZERO, ZERO
9D00ACB0  0F402045   JAL disk_initialize
9D00ACB4  00000000   NOP
9D00ACB8  14400003   BNE V0, ZERO, 0x9D00ACC8
9D00ACBC  00000000   NOP
76:                              c = SDTRIES;
9D00ACC0  2402000A   ADDIU V0, ZERO, 10
9D00ACC4  AFC20010   SW V0, 16(S8)
77:                          }
78:                      }
79:                      for (c = 0; c < SDTRIES; c++) {
9D00ACE4  AFC00010   SW ZERO, 16(S8)
9D00ACE8  0B402B47   J 0x9D00AD1C
9D00ACEC  00000000   NOP
9D00AD10  8FC20010   LW V0, 16(S8)
9D00AD14  24420001   ADDIU V0, V0, 1
9D00AD18  AFC20010   SW V0, 16(S8)
9D00AD1C  8FC20010   LW V0, 16(S8)
9D00AD20  2842000A   SLTI V0, V0, 10
9D00AD24  1440FFF2   BNE V0, ZERO, 0x9D00ACF0
9D00AD28  00000000   NOP
80:                          if (SDNewFile() == 0) {
9D00ACF0  0F402CB7   JAL SDNewFile
9D00ACF4  00000000   NOP
9D00ACF8  14400005   BNE V0, ZERO, 0x9D00AD10
9D00ACFC  00000000   NOP
81:                              //sd card successfully opened, shut down Bluetooth
82:                              sd_card_opened = 1;
9D00AD00  24020001   ADDIU V0, ZERO, 1
9D00AD04  AFC20014   SW V0, 20(S8)
83:                              c = SDTRIES;
9D00AD08  2402000A   ADDIU V0, ZERO, 10
9D00AD0C  AFC20010   SW V0, 16(S8)
84:                          }
85:                      }
86:                  
87:                      LED_B = 1;
9D00AD2C  3C03BF88   LUI V1, -16504
9D00AD30  8C6260A0   LW V0, 24736(V1)
9D00AD34  24040001   ADDIU A0, ZERO, 1
9D00AD38  7C826B44   INS V0, A0, 13, 1
9D00AD3C  AC6260A0   SW V0, 24736(V1)
88:                  
89:                      BTInitPorts();
9D00AD40  0F40300C   JAL BTInitPorts
9D00AD44  00000000   NOP
90:                      if(!sd_card_opened) //shut off BT
9D00AD48  8FC20014   LW V0, 20(S8)
9D00AD4C  14400007   BNE V0, ZERO, 0x9D00AD6C
9D00AD50  00000000   NOP
91:                      {
92:                          BT_RST = 0;
9D00AD54  3C03BF88   LUI V1, -16504
9D00AD58  8C626060   LW V0, 24672(V1)
9D00AD5C  7C024204   INS V0, ZERO, 8, 1
9D00AD60  AC626060   SW V0, 24672(V1)
93:                      }
94:                  
95:                      //while now switched off
96:                      while(PORTCbits.RC14 == 1)
9D00AD64  0B402B5C   J 0x9D00AD70
9D00AD68  00000000   NOP
9D00AD6C  00000000   NOP
9D00AD70  3C02BF88   LUI V0, -16504
9D00AD74  8C426090   LW V0, 24720(V0)
9D00AD78  30424000   ANDI V0, V0, 16384
9D00AD7C  1440FFFC   BNE V0, ZERO, 0x9D00AD70
9D00AD80  00000000   NOP
97:                      {
98:                      }
99:                  
100:                     LED_G = 1;
9D00AD84  3C03BF88   LUI V1, -16504
9D00AD88  8C6260E0   LW V0, 24800(V1)
9D00AD8C  24040001   ADDIU A0, ZERO, 1
9D00AD90  7C825AC4   INS V0, A0, 11, 1
9D00AD94  AC6260E0   SW V0, 24800(V1)
101:                     LED_B = 1;
9D00AD98  3C03BF88   LUI V1, -16504
9D00AD9C  8C6260A0   LW V0, 24736(V1)
9D00ADA0  24040001   ADDIU A0, ZERO, 1
9D00ADA4  7C826B44   INS V0, A0, 13, 1
9D00ADA8  AC6260A0   SW V0, 24736(V1)
102:                     LED_R = 1;
9D00ADAC  3C03BF88   LUI V1, -16504
9D00ADB0  8C626060   LW V0, 24672(V1)
9D00ADB4  24040001   ADDIU A0, ZERO, 1
9D00ADB8  7C825AC4   INS V0, A0, 11, 1
9D00ADBC  AC626060   SW V0, 24672(V1)
103:                     LED1 = 0;
9D00ADC0  3C03BF88   LUI V1, -16504
9D00ADC4  8C626060   LW V0, 24672(V1)
9D00ADC8  7C024A44   INS V0, ZERO, 9, 1
9D00ADCC  AC626060   SW V0, 24672(V1)
104:                     LED2 = 0;
9D00ADD0  3C03BF88   LUI V1, -16504
9D00ADD4  8C626060   LW V0, 24672(V1)
9D00ADD8  7C025284   INS V0, ZERO, 10, 1
9D00ADDC  AC626060   SW V0, 24672(V1)
105:                     DelayMS(1000);
9D00ADE0  240403E8   ADDIU A0, ZERO, 1000
9D00ADE4  0F4031E6   JAL DelayMS
9D00ADE8  00000000   NOP
106:                     SoftReset();
9D00ADEC  0F40347C   JAL SoftReset
9D00ADF0  00000000   NOP
107:                 
108:                     return 0;
109:                 }
110:                 
111:                 void waitForPowerOn()
112:                 {
9D00ADF4  27BDFFE8   ADDIU SP, SP, -24
9D00ADF8  AFBF0014   SW RA, 20(SP)
9D00ADFC  AFBE0010   SW S8, 16(SP)
9D00AE00  03A0F021   ADDU S8, SP, ZERO
113:                     //set all ports to output
114:                     TRISB = 0;
9D00AE04  3C02BF88   LUI V0, -16504
9D00AE08  AC406040   SW ZERO, 24640(V0)
115:                     TRISC = 0;
9D00AE0C  3C02BF88   LUI V0, -16504
9D00AE10  AC406080   SW ZERO, 24704(V0)
116:                     TRISD = 0;
9D00AE14  3C02BF88   LUI V0, -16504
9D00AE18  AC4060C0   SW ZERO, 24768(V0)
117:                     TRISE = 0;
9D00AE1C  3C02BF88   LUI V0, -16504
9D00AE20  AC406100   SW ZERO, 24832(V0)
118:                     TRISF = 0;
9D00AE24  3C02BF88   LUI V0, -16504
9D00AE28  AC406140   SW ZERO, 24896(V0)
119:                     TRISG = 0;
9D00AE2C  3C02BF88   LUI V0, -16504
9D00AE30  AC406180   SW ZERO, 24960(V0)
120:                     LATB = 0;
9D00AE34  3C02BF88   LUI V0, -16504
9D00AE38  AC406060   SW ZERO, 24672(V0)
121:                     LATC = 0;
9D00AE3C  3C02BF88   LUI V0, -16504
9D00AE40  AC4060A0   SW ZERO, 24736(V0)
122:                     LATD = 0;
9D00AE44  3C02BF88   LUI V0, -16504
9D00AE48  AC4060E0   SW ZERO, 24800(V0)
123:                     LATE = 0;
9D00AE4C  3C02BF88   LUI V0, -16504
9D00AE50  AC406120   SW ZERO, 24864(V0)
124:                     LATF = 0;
9D00AE54  3C02BF88   LUI V0, -16504
9D00AE58  AC406160   SW ZERO, 24928(V0)
125:                     LATG = 0;
9D00AE5C  3C02BF88   LUI V0, -16504
9D00AE60  AC4061A0   SW ZERO, 24992(V0)
126:                 
127:                     TRISBbits.TRISB2 = 1; //set battery monitor as input
9D00AE64  3C03BF88   LUI V1, -16504
9D00AE68  8C626040   LW V0, 24640(V1)
9D00AE6C  24040001   ADDIU A0, ZERO, 1
9D00AE70  7C821084   INS V0, A0, 2, 1
9D00AE74  AC626040   SW V0, 24640(V1)
128:                 
129:                     //shut off RGB LED
130:                     LED_R = 1;
9D00AE78  3C03BF88   LUI V1, -16504
9D00AE7C  8C626060   LW V0, 24672(V1)
9D00AE80  24040001   ADDIU A0, ZERO, 1
9D00AE84  7C825AC4   INS V0, A0, 11, 1
9D00AE88  AC626060   SW V0, 24672(V1)
131:                     LED_G = 1;
9D00AE8C  3C03BF88   LUI V1, -16504
9D00AE90  8C6260E0   LW V0, 24800(V1)
9D00AE94  24040001   ADDIU A0, ZERO, 1
9D00AE98  7C825AC4   INS V0, A0, 11, 1
9D00AE9C  AC6260E0   SW V0, 24800(V1)
132:                     LED_B = 1;
9D00AEA0  3C03BF88   LUI V1, -16504
9D00AEA4  8C6260A0   LW V0, 24736(V1)
9D00AEA8  24040001   ADDIU A0, ZERO, 1
9D00AEAC  7C826B44   INS V0, A0, 13, 1
9D00AEB0  AC6260A0   SW V0, 24736(V1)
133:                 
134:                     //shut off all power
135:                     //analog power supply
136:                     TRISDbits.TRISD4 = 0;
9D00AEB4  3C03BF88   LUI V1, -16504
9D00AEB8  8C6260C0   LW V0, 24768(V1)
9D00AEBC  7C022104   INS V0, ZERO, 4, 1
9D00AEC0  AC6260C0   SW V0, 24768(V1)
137:                     LATDbits.LATD4 = 0;
9D00AEC4  3C03BF88   LUI V1, -16504
9D00AEC8  8C6260E0   LW V0, 24800(V1)
9D00AECC  7C022104   INS V0, ZERO, 4, 1
9D00AED0  AC6260E0   SW V0, 24800(V1)
138:                     //digital power supply
139:                     TRISEbits.TRISE6 = 0;
9D00AED4  3C03BF88   LUI V1, -16504
9D00AED8  8C626100   LW V0, 24832(V1)
9D00AEDC  7C023184   INS V0, ZERO, 6, 1
9D00AEE0  AC626100   SW V0, 24832(V1)
140:                     LATEbits.LATE6 = 1;
9D00AEE4  3C03BF88   LUI V1, -16504
9D00AEE8  8C626120   LW V0, 24864(V1)
9D00AEEC  24040001   ADDIU A0, ZERO, 1
9D00AEF0  7C823184   INS V0, A0, 6, 1
9D00AEF4  AC626120   SW V0, 24864(V1)
141:                 
142:                     //monitor push button port, RC14, CN0
143:                     TRISCbits.TRISC14 = 1;
9D00AEF8  3C03BF88   LUI V1, -16504
9D00AEFC  8C626080   LW V0, 24704(V1)
9D00AF00  24040001   ADDIU A0, ZERO, 1
9D00AF04  7C827384   INS V0, A0, 14, 1
9D00AF08  AC626080   SW V0, 24704(V1)
144:                     CNPUEbits.CNPUE0 = 1; //enable CN0 pull up
9D00AF0C  3C03BF88   LUI V1, -16504
9D00AF10  8C6261E0   LW V0, 25056(V1)
9D00AF14  24040001   ADDIU A0, ZERO, 1
9D00AF18  7C820004   INS V0, A0, 0, 1
9D00AF1C  AC6261E0   SW V0, 25056(V1)
145:                     DelayMS(100); //wait for CN to charge up
9D00AF20  24040064   ADDIU A0, ZERO, 100
9D00AF24  0F4031E6   JAL DelayMS
9D00AF28  00000000   NOP
146:                 
147:                     while(PORTCbits.RC14 == 1);
9D00AF2C  00000000   NOP
9D00AF30  3C02BF88   LUI V0, -16504
9D00AF34  8C426090   LW V0, 24720(V0)
9D00AF38  30424000   ANDI V0, V0, 16384
9D00AF3C  1440FFFC   BNE V0, ZERO, 0x9D00AF30
9D00AF40  00000000   NOP
148:                 
149:                     /*
150:                     //setup push button interrupt
151:                     mCNOpen( (CN_ON | CN_IDLE_CON) , CN0_ENABLE, CN0_PULLUP_ENABLE);
152:                     int dummy = PORTCbits.RC14; //read RC14 to clear mismatchs
153:                     mCNIntEnable( (CHANGE_INT_ON | CHANGE_INT_PRI_3) );
154:                 
155:                 
156:                 
157:                     //wait for push button
158:                     INTEnableSystemMultiVectoredInt();
159:                     PowerSaveSleep();
160:                     INTDisableInterrupts();
161:                     mCNClose();
162:                     mCNIntEnable( (CHANGE_INT_OFF | CHANGE_INT_PRI_3) );
163:                     */
164:                 
165:                     //reset ports
166:                     TRISB = 0xFFFF;
9D00AF44  3C02BF88   LUI V0, -16504
9D00AF48  3403FFFF   ORI V1, ZERO, -1
9D00AF4C  AC436040   SW V1, 24640(V0)
167:                     TRISC = 0xFFFF;
9D00AF50  3C02BF88   LUI V0, -16504
9D00AF54  3403FFFF   ORI V1, ZERO, -1
9D00AF58  AC436080   SW V1, 24704(V0)
168:                     TRISD = 0xFFFF;
9D00AF5C  3C02BF88   LUI V0, -16504
9D00AF60  3403FFFF   ORI V1, ZERO, -1
9D00AF64  AC4360C0   SW V1, 24768(V0)
169:                     TRISE = 0xFFFF;
9D00AF68  3C02BF88   LUI V0, -16504
9D00AF6C  3403FFFF   ORI V1, ZERO, -1
9D00AF70  AC436100   SW V1, 24832(V0)
170:                     TRISF = 0xFFFF;
9D00AF74  3C02BF88   LUI V0, -16504
9D00AF78  3403FFFF   ORI V1, ZERO, -1
9D00AF7C  AC436140   SW V1, 24896(V0)
171:                     TRISG = 0xFFFF;
9D00AF80  3C02BF88   LUI V0, -16504
9D00AF84  3403FFFF   ORI V1, ZERO, -1
9D00AF88  AC436180   SW V1, 24960(V0)
172:                 }
9D00AF8C  03C0E821   ADDU SP, S8, ZERO
9D00AF90  8FBF0014   LW RA, 20(SP)
9D00AF94  8FBE0010   LW S8, 16(SP)
9D00AF98  27BD0018   ADDIU SP, SP, 24
9D00AF9C  03E00008   JR RA
9D00AFA0  00000000   NOP
173:                 
174:                 void __ISR(_CHANGE_NOTICE_VECTOR, IPL3AUTO) CNHandler(void)
175:                 {
9D00AFA4  415DE800   RDPGPR SP, SP
9D00AFA8  401B7000   MFC0 K1, EPC
9D00AFAC  401A6002   MFC0 K0, SRSCtl
9D00AFB0  27BDFFE0   ADDIU SP, SP, -32
9D00AFB4  AFBB001C   SW K1, 28(SP)
9D00AFB8  401B6000   MFC0 K1, Status
9D00AFBC  AFBA0018   SW K0, 24(SP)
9D00AFC0  AFBB0014   SW K1, 20(SP)
9D00AFC4  7C1B7844   INS K1, ZERO, 1, 15
9D00AFC8  377B0C00   ORI K1, K1, 3072
9D00AFCC  409B6000   MTC0 K1, Status
9D00AFD0  AFA30008   SW V1, 8(SP)
9D00AFD4  AFA20004   SW V0, 4(SP)
9D00AFD8  8FA30018   LW V1, 24(SP)
9D00AFDC  3063000F   ANDI V1, V1, 15
9D00AFE0  AFBE000C   SW S8, 12(SP)
9D00AFE4  03A0F021   ADDU S8, SP, ZERO
176:                     LED_B = 0;
9D00AFE8  3C03BF88   LUI V1, -16504
9D00AFEC  8C6260A0   LW V0, 24736(V1)
9D00AFF0  7C026B44   INS V0, ZERO, 13, 1
9D00AFF4  AC6260A0   SW V0, 24736(V1)
177:                     mCNClearIntFlag();
9D00AFF8  3C02BF88   LUI V0, -16504
9D00AFFC  24030001   ADDIU V1, ZERO, 1
9D00B000  AC431044   SW V1, 4164(V0)
178:                 }
9D00B004  03C0E821   ADDU SP, S8, ZERO
9D00B008  8FA20018   LW V0, 24(SP)
9D00B00C  3042000F   ANDI V0, V0, 15
9D00B010  14400004   BNE V0, ZERO, 0x9D00B024
9D00B014  00000000   NOP
9D00B018  8FBE000C   LW S8, 12(SP)
9D00B01C  8FA30008   LW V1, 8(SP)
9D00B020  8FA20004   LW V0, 4(SP)
9D00B024  41606000   DI ZERO
9D00B028  000000C0   EHB
9D00B02C  8FBA001C   LW K0, 28(SP)
9D00B030  8FBB0014   LW K1, 20(SP)
9D00B034  409A7000   MTC0 K0, EPC
9D00B038  8FBA0018   LW K0, 24(SP)
9D00B03C  27BD0020   ADDIU SP, SP, 32
9D00B040  409A6002   MTC0 K0, SRSCtl
9D00B044  41DDE800   WRPGPR SP, SP
9D00B048  409B6000   MTC0 K1, Status
9D00B04C  42000018   ERET
179:                 
180:                 void initPorts()
181:                 {
9D00B050  27BDFFE8   ADDIU SP, SP, -24
9D00B054  AFBF0014   SW RA, 20(SP)
9D00B058  AFBE0010   SW S8, 16(SP)
9D00B05C  03A0F021   ADDU S8, SP, ZERO
182:                     //LED Array
183:                     TRISBbits.TRISB10 = 0;
9D00B060  3C03BF88   LUI V1, -16504
9D00B064  8C626040   LW V0, 24640(V1)
9D00B068  7C025284   INS V0, ZERO, 10, 1
9D00B06C  AC626040   SW V0, 24640(V1)
184:                     TRISBbits.TRISB9 = 0;
9D00B070  3C03BF88   LUI V1, -16504
9D00B074  8C626040   LW V0, 24640(V1)
9D00B078  7C024A44   INS V0, ZERO, 9, 1
9D00B07C  AC626040   SW V0, 24640(V1)
185:                     TRISDbits.TRISD11 = 0;
9D00B080  3C03BF88   LUI V1, -16504
9D00B084  8C6260C0   LW V0, 24768(V1)
9D00B088  7C025AC4   INS V0, ZERO, 11, 1
9D00B08C  AC6260C0   SW V0, 24768(V1)
186:                     TRISCbits.TRISC13 = 0;
9D00B090  3C03BF88   LUI V1, -16504
9D00B094  8C626080   LW V0, 24704(V1)
9D00B098  7C026B44   INS V0, ZERO, 13, 1
9D00B09C  AC626080   SW V0, 24704(V1)
187:                     TRISBbits.TRISB11 = 0;
9D00B0A0  3C03BF88   LUI V1, -16504
9D00B0A4  8C626040   LW V0, 24640(V1)
9D00B0A8  7C025AC4   INS V0, ZERO, 11, 1
9D00B0AC  AC626040   SW V0, 24640(V1)
188:                 
189:                     LED1 = 1;
9D00B0B0  3C03BF88   LUI V1, -16504
9D00B0B4  8C626060   LW V0, 24672(V1)
9D00B0B8  24040001   ADDIU A0, ZERO, 1
9D00B0BC  7C824A44   INS V0, A0, 9, 1
9D00B0C0  AC626060   SW V0, 24672(V1)
190:                     LED2 = 1;
9D00B0C4  3C03BF88   LUI V1, -16504
9D00B0C8  8C626060   LW V0, 24672(V1)
9D00B0CC  24040001   ADDIU A0, ZERO, 1
9D00B0D0  7C825284   INS V0, A0, 10, 1
9D00B0D4  AC626060   SW V0, 24672(V1)
191:                     LED_G = 0;
9D00B0D8  3C03BF88   LUI V1, -16504
9D00B0DC  8C6260E0   LW V0, 24800(V1)
9D00B0E0  7C025AC4   INS V0, ZERO, 11, 1
9D00B0E4  AC6260E0   SW V0, 24800(V1)
192:                     LED_B = 0;
9D00B0E8  3C03BF88   LUI V1, -16504
9D00B0EC  8C6260A0   LW V0, 24736(V1)
9D00B0F0  7C026B44   INS V0, ZERO, 13, 1
9D00B0F4  AC6260A0   SW V0, 24736(V1)
193:                     LED_R = 0;
9D00B0F8  3C03BF88   LUI V1, -16504
9D00B0FC  8C626060   LW V0, 24672(V1)
9D00B100  7C025AC4   INS V0, ZERO, 11, 1
9D00B104  AC626060   SW V0, 24672(V1)
194:                 
195:                     //power button pull up
196:                     TRISCbits.TRISC14 = 1;
9D00B108  3C03BF88   LUI V1, -16504
9D00B10C  8C626080   LW V0, 24704(V1)
9D00B110  24040001   ADDIU A0, ZERO, 1
9D00B114  7C827384   INS V0, A0, 14, 1
9D00B118  AC626080   SW V0, 24704(V1)
197:                     CNPUEbits.CNPUE0 = 1; //enable CN0 pull up
9D00B11C  3C03BF88   LUI V1, -16504
9D00B120  8C6261E0   LW V0, 25056(V1)
9D00B124  24040001   ADDIU A0, ZERO, 1
9D00B128  7C820004   INS V0, A0, 0, 1
9D00B12C  AC6261E0   SW V0, 25056(V1)
198:                 
199:                     
200:                     //Main Power - Analog and Digital
201:                     TRISDbits.TRISD4 = 0;
9D00B130  3C03BF88   LUI V1, -16504
9D00B134  8C6260C0   LW V0, 24768(V1)
9D00B138  7C022104   INS V0, ZERO, 4, 1
9D00B13C  AC6260C0   SW V0, 24768(V1)
202:                     LATDbits.LATD4 = 1;
9D00B140  3C03BF88   LUI V1, -16504
9D00B144  8C6260E0   LW V0, 24800(V1)
9D00B148  24040001   ADDIU A0, ZERO, 1
9D00B14C  7C822104   INS V0, A0, 4, 1
9D00B150  AC6260E0   SW V0, 24800(V1)
203:                     //digital power supply
204:                     TRISEbits.TRISE6 = 0;
9D00B154  3C03BF88   LUI V1, -16504
9D00B158  8C626100   LW V0, 24832(V1)
9D00B15C  7C023184   INS V0, ZERO, 6, 1
9D00B160  AC626100   SW V0, 24832(V1)
205:                     LATEbits.LATE6 = 0;
9D00B164  3C03BF88   LUI V1, -16504
9D00B168  8C626120   LW V0, 24864(V1)
9D00B16C  7C023184   INS V0, ZERO, 6, 1
9D00B170  AC626120   SW V0, 24864(V1)
206:                 
207:                     /*
208:                     //keep bluetooth in reset
209:                     TRISBbits.TRISB8 = 0;
210:                     BT_RST = 0;
211:                     */
212:                 
213:                     //wait for main power to soft start
214:                     DelayMS(300);
9D00B174  2404012C   ADDIU A0, ZERO, 300
9D00B178  0F4031E6   JAL DelayMS
9D00B17C  00000000   NOP
215:                    
216:                 }
9D00B180  03C0E821   ADDU SP, S8, ZERO
9D00B184  8FBF0014   LW RA, 20(SP)
9D00B188  8FBE0010   LW S8, 16(SP)
9D00B18C  27BD0018   ADDIU SP, SP, 24
9D00B190  03E00008   JR RA
9D00B194  00000000   NOP
217:                 
218:                 
219:                 
220:                 /*
221:                 int main()
222:                 {
223:                     waitForPowerOn();
224:                     powerUp();
225:                 
226:                     //configure PIC for maximum performance at the specified clock
227:                     //Note that this overrides the peripheral bus divider to the maximum supported speed
228:                     SYSTEMConfigPerformance(SYSCLK);
229:                 
230:                     //init basic IO pins
231:                     initPorts();
232:                 
233:                     //init SD card IO pins
234:                     SDPortInit();
235:                 
236:                     //init battery monitoring
237:                     BatteryInit();
238:                 
239:                     //try to startup SD card
240:                     int c;
241:                     int sd_card_opened = 0;
242:                     for (c = 0; c < SDTRIES; c++) {
243:                         if (disk_initialize(0) == FR_OK) {
244:                             c = SDTRIES;
245:                         }
246:                     }
247:                     for (c = 0; c < SDTRIES; c++) {
248:                         if (SDNewFile() == 0) {
249:                             //sd card successfully opened, shut down Bluetooth
250:                             sd_card_opened = 1;
251:                             c = SDTRIES;
252:                         }
253:                     }
254:                 
255:                     //activate BT if SD card is not opened
256:                     if(sd_card_opened == 0)
257:                     {
258:                         //init BT Ports and power on BT module
259:                         BTInitPorts();
260:                     }
261:                     else //shut off BT
262:                     {
263:                         BT_RST = 0;
264:                     }
265:                 
266:                     ADS1298Run(sd_card_opened);
267:                 
268:                     //enable interrupts
269:                     INTEnableSystemMultiVectoredInt();
270:                 
271:                     while(PORTAbits.RA1==1)
272:                     {
273:                         if(sd_card_opened==1)
274:                         {
275:                             SDUpdate();
276:                         }
277:                         else
278:                         {
279:                             BTUpdate();
280:                         }
281:                 
282:                         
283:                         int batt_stat = BatteryUpdate();
284:                         if(batt_stat!=BATTERY_IS_OK)
285:                         {
286:                             LED2 = 1;
287:                         }
288:                         if(batt_stat==BATTERY_IS_DEAD)
289:                         {
290:                             lockOut();
291:                         }
292:                         else
293:                         {
294:                             LED2 = 0;
295:                         }
296:                 
297:                 
298:                         PowerSaveIdle();
299:                 
300:                     }
301:                 
302:                     INTDisableInterrupts();
303:                     LED2 = 0;
304:                     LED1 = 0;
305:                 
306:                     SDCloseFile();
307:                     SDPowerDown();
308:                 
309:                     
310:                 
311:                     return 0;
312:                 }
313:                 
314:                 
315:                 
316:                 
317:                 
318:                 void powerUp()
319:                 {
320:                 
321:                 
322:                 }
323:                 
324:                 void lockOut()
325:                 {
326:                     INTDisableInterrupts();
327:                     LED2 = 0;
328:                     LED1 = 0;
329:                 
330:                     SDCloseFile();
331:                     SDPowerDown();
332:                 
333:                     AN_PWR = 1;
334:                     BT_RST = 0;
335:                 
336:                     PowerSaveSleep();
337:                 }
338:                 */
---  /Users/mikechi/Dropbox/Cognionics/Projects/EEG 64/Firmware/PIC32 DAQ/EEG64-PIC32.X/fatfs/mmc.c  ----
1:                   /*------------------------------------------------------------------------/
2:                   /  MMCv3/SDv1/SDv2 (in SPI mode) control module
3:                   /-------------------------------------------------------------------------/
4:                   /
5:                   /  Copyright (C) 2012, ChaN, all right reserved.
6:                   /
7:                   / * This software is a free software and there is NO WARRANTY.
8:                   / * No restriction on use. You can use, modify and redistribute it for
9:                   /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
10:                  / * Redistributions of source code must retain the above copyright notice.
11:                  /
12:                  /-------------------------------------------------------------------------*/
13:                  
14:                  //Mike Chi 2/1/12 - Change to SPI4 from SPI4
15:                  
16:                  /*
17:                  Mike Chi 5/25/12 - Steps to port mmc.c to different processors
18:                  1. Change CS_LOW() and CS_HIGH() functions to right LAT port
19:                  2. Change SOCKWP SOCKINS pins (if they exist) otherwise use defaults
20:                  3. Change all SPIX references to the correct SPI port
21:                  4. Make sure FCLK_SLOW() and FCLK_FAST macros are configured correctly given the master clock
22:                          -add SPIEN = 0 ... SPIEN = 1, need to power cycle spi port to update clock divider
23:                   *
24:                   * 9-1-13
25:                   * changed the card transmit function to allow DMA on pic32, when porting restore old code first to test for functionality
26:                   */
27:                  
28:                  #include <xc.h>
29:                  #include <plib.h>
30:                  #include "diskio.h"
31:                  
32:                  
33:                  /* Definitions for MMC/SDC command */
34:                  #define CMD0   (0)			/* GO_IDLE_STATE */
35:                  #define CMD1   (1)			/* SEND_OP_COND */
36:                  #define ACMD41 (41|0x80)	/* SEND_OP_COND (SDC) */
37:                  #define CMD8   (8)			/* SEND_IF_COND */
38:                  #define CMD9   (9)			/* SEND_CSD */
39:                  #define CMD10  (10)			/* SEND_CID */
40:                  #define CMD12  (12)			/* STOP_TRANSMISSION */
41:                  #define ACMD13 (13|0x80)	/* SD_STATUS (SDC) */
42:                  #define CMD16  (16)			/* SET_BLOCKLEN */
43:                  #define CMD17  (17)			/* READ_SINGLE_BLOCK */
44:                  #define CMD18  (18)			/* READ_MULTIPLE_BLOCK */
45:                  #define CMD23  (23)			/* SET_BLOCK_COUNT */
46:                  #define ACMD23 (23|0x80)	/* SET_WR_BLK_ERASE_COUNT (SDC) */
47:                  #define CMD24  (24)			/* WRITE_BLOCK */
48:                  #define CMD25  (25)			/* WRITE_MULTIPLE_BLOCK */
49:                  #define CMD41  (41)			/* SEND_OP_COND (ACMD) */
50:                  #define CMD55  (55)			/* APP_CMD */
51:                  #define CMD58  (58)			/* READ_OCR */
52:                  
53:                  
54:                  /* Port Controls  (Platform dependent) */
55:                  #define CS_LOW()  LATBCLR = (1<<3) //LATBbits.LATB3 = 0	/* MMC CS = L */
56:                  #define CS_HIGH() LATBSET = (1<<3) //LATBbits.LATB3 = 1	/* MMC CS = H */
57:                  
58:                  #define SOCKWP	0//(PORTB | (1<<10))	/* Write protected (yes:true, no:false, default:false) */
59:                  #define SOCKINS	1//!(PORTB | (1<<11))	/* Card inserted   (yes:true, no:false, default:true) */
60:                  
61:                  #define	FCLK_SLOW()                     SPI4CONbits.ON = 0; SPI4BRG = 32; SPI4CONbits.ON = 1;			/* Set slow clock (100k-400k) */
62:                  #define	FCLK_FAST()		        SPI4CONbits.ON = 0; SPI4BRG = 0; SPI4CONbits.ON = 1;	 //4:1  /* Set fast clock (depends on the CSD) */
63:                  
64:                  
65:                  
66:                  /*--------------------------------------------------------------------------
67:                  
68:                     Module Private Functions
69:                  
70:                  ---------------------------------------------------------------------------*/
71:                  
72:                  static volatile
73:                  DSTATUS Stat = STA_NOINIT; /* Disk status */
74:                  
75:                  static volatile
76:                  UINT Timer1, Timer2; /* 1000Hz decrement timer */
77:                  
78:                  static
79:                  UINT CardType;
80:                  
81:                  
82:                  
83:                  /*-----------------------------------------------------------------------*/
84:                  /* Exchange a byte between PIC and MMC via SPI  (Platform dependent)     */
85:                  /*-----------------------------------------------------------------------*/
86:                  
87:                  #define xmit_spi(dat) 	xchg_spi(dat)
88:                  #define rcvr_spi()		xchg_spi(0xFF)
89:                  #define rcvr_spi_m(p)	SPI4BUF = 0xFF; while (!SPI4STATbits.SPIRBF); *(p) = (BYTE)SPI4BUF;
90:                  
91:                  static
92:                  BYTE xchg_spi(BYTE dat) {
9D007A64  27BDFFF8   ADDIU SP, SP, -8
9D007A68  AFBE0004   SW S8, 4(SP)
9D007A6C  03A0F021   ADDU S8, SP, ZERO
9D007A70  00801021   ADDU V0, A0, ZERO
9D007A74  A3C20008   SB V0, 8(S8)
93:                      SPI4BUF = dat;
9D007A78  93C30008   LBU V1, 8(S8)
9D007A7C  3C02BF80   LUI V0, -16512
9D007A80  AC435C20   SW V1, 23584(V0)
94:                      while (!SPI4STATbits.SPIRBF);
9D007A84  00000000   NOP
9D007A88  3C02BF80   LUI V0, -16512
9D007A8C  8C425C10   LW V0, 23568(V0)
9D007A90  30420001   ANDI V0, V0, 1
9D007A94  1040FFFC   BEQ V0, ZERO, 0x9D007A88
9D007A98  00000000   NOP
95:                      return (BYTE) SPI4BUF;
9D007A9C  3C02BF80   LUI V0, -16512
9D007AA0  8C425C20   LW V0, 23584(V0)
9D007AA4  304200FF   ANDI V0, V0, 255
96:                  }
9D007AA8  03C0E821   ADDU SP, S8, ZERO
9D007AAC  8FBE0004   LW S8, 4(SP)
9D007AB0  27BD0008   ADDIU SP, SP, 8
9D007AB4  03E00008   JR RA
9D007AB8  00000000   NOP
97:                  
98:                  
99:                  /*-----------------------------------------------------------------------*/
100:                 /* Wait for card ready                                                   */
101:                 
102:                 /*-----------------------------------------------------------------------*/
103:                 
104:                 static
105:                 int wait_ready(void) {
9D007ABC  27BDFFE0   ADDIU SP, SP, -32
9D007AC0  AFBF001C   SW RA, 28(SP)
9D007AC4  AFBE0018   SW S8, 24(SP)
9D007AC8  03A0F021   ADDU S8, SP, ZERO
106:                     BYTE d;
107:                 
108:                     Timer2 = 500; /* Wait for ready in timeout of 500ms */
9D007ACC  240201F4   ADDIU V0, ZERO, 500
9D007AD0  AF828050   SW V0, -32688(GP)
109:                     do {
110:                         d = rcvr_spi();
9D007AD4  240400FF   ADDIU A0, ZERO, 255
9D007AD8  0F401E99   JAL 0x9D007A64
9D007ADC  00000000   NOP
9D007AE0  A3C20010   SB V0, 16(S8)
111:                     } while ((d != 0xFF) && Timer2);
9D007AE4  93C30010   LBU V1, 16(S8)
9D007AE8  240200FF   ADDIU V0, ZERO, 255
9D007AEC  10620004   BEQ V1, V0, 0x9D007B00
9D007AF0  00000000   NOP
9D007AF4  8F828050   LW V0, -32688(GP)
9D007AF8  1440FFF6   BNE V0, ZERO, 0x9D007AD4
9D007AFC  00000000   NOP
112:                 
113:                     return (d == 0xFF) ? 1 : 0;
9D007B00  93C20010   LBU V0, 16(S8)
9D007B04  384200FF   XORI V0, V0, 255
9D007B08  2C420001   SLTIU V0, V0, 1
114:                 }
9D007B0C  03C0E821   ADDU SP, S8, ZERO
9D007B10  8FBF001C   LW RA, 28(SP)
9D007B14  8FBE0018   LW S8, 24(SP)
9D007B18  27BD0020   ADDIU SP, SP, 32
9D007B1C  03E00008   JR RA
9D007B20  00000000   NOP
115:                 
116:                 
117:                 
118:                 /*-----------------------------------------------------------------------*/
119:                 /* Deselect the card and release SPI bus                                 */
120:                 
121:                 /*-----------------------------------------------------------------------*/
122:                 
123:                 static
124:                 void deselect(void) {
9D007B24  27BDFFE8   ADDIU SP, SP, -24
9D007B28  AFBF0014   SW RA, 20(SP)
9D007B2C  AFBE0010   SW S8, 16(SP)
9D007B30  03A0F021   ADDU S8, SP, ZERO
125:                     CS_HIGH();
9D007B34  3C02BF88   LUI V0, -16504
9D007B38  24030008   ADDIU V1, ZERO, 8
9D007B3C  AC436068   SW V1, 24680(V0)
126:                     rcvr_spi(); /* Dummy clock (force DO hi-z for multiple slave SPI) */
9D007B40  240400FF   ADDIU A0, ZERO, 255
9D007B44  0F401E99   JAL 0x9D007A64
9D007B48  00000000   NOP
127:                 }
9D007B4C  03C0E821   ADDU SP, S8, ZERO
9D007B50  8FBF0014   LW RA, 20(SP)
9D007B54  8FBE0010   LW S8, 16(SP)
9D007B58  27BD0018   ADDIU SP, SP, 24
9D007B5C  03E00008   JR RA
9D007B60  00000000   NOP
128:                 
129:                 
130:                 
131:                 /*-----------------------------------------------------------------------*/
132:                 /* Select the card and wait ready                                        */
133:                 
134:                 /*-----------------------------------------------------------------------*/
135:                 
136:                 static
137:                 int select(void) /* 1:Successful, 0:Timeout */ {
9D007B64  27BDFFE8   ADDIU SP, SP, -24
9D007B68  AFBF0014   SW RA, 20(SP)
9D007B6C  AFBE0010   SW S8, 16(SP)
9D007B70  03A0F021   ADDU S8, SP, ZERO
138:                     CS_LOW();
9D007B74  3C02BF88   LUI V0, -16504
9D007B78  24030008   ADDIU V1, ZERO, 8
9D007B7C  AC436064   SW V1, 24676(V0)
139:                     rcvr_spi(); /* Dummy clock (force DO enabled) */
9D007B80  240400FF   ADDIU A0, ZERO, 255
9D007B84  0F401E99   JAL 0x9D007A64
9D007B88  00000000   NOP
140:                 
141:                     if (wait_ready()) return 1; /* OK */
9D007B8C  0F401EAF   JAL 0x9D007ABC
9D007B90  00000000   NOP
9D007B94  10400004   BEQ V0, ZERO, 0x9D007BA8
9D007B98  00000000   NOP
9D007B9C  24020001   ADDIU V0, ZERO, 1
9D007BA0  0B401EED   J 0x9D007BB4
9D007BA4  00000000   NOP
142:                     deselect();
9D007BA8  0F401EC9   JAL 0x9D007B24
9D007BAC  00000000   NOP
143:                     return 0; /* Timeout */
9D007BB0  00001021   ADDU V0, ZERO, ZERO
144:                 }
9D007BB4  03C0E821   ADDU SP, S8, ZERO
9D007BB8  8FBF0014   LW RA, 20(SP)
9D007BBC  8FBE0010   LW S8, 16(SP)
9D007BC0  27BD0018   ADDIU SP, SP, 24
9D007BC4  03E00008   JR RA
9D007BC8  00000000   NOP
145:                 
146:                 
147:                 
148:                 /*-----------------------------------------------------------------------*/
149:                 /* Power Control  (Platform dependent)                                   */
150:                 /*-----------------------------------------------------------------------*/
151:                 /* When the target system does not support socket power control, there   */
152:                 
153:                 /* is nothing to do in these functions.                                  */
154:                 
155:                 static
156:                 void power_on(void) {
9D007BCC  27BDFFE0   ADDIU SP, SP, -32
9D007BD0  AFBF001C   SW RA, 28(SP)
9D007BD4  AFBE0018   SW S8, 24(SP)
9D007BD8  03A0F021   ADDU S8, SP, ZERO
157:                    /* Turn on socket power, delay >1ms */
158:                     //OpenSPI4((PRI_PRESCAL_64_1 | SEC_PRESCAL_8_1 | MASTER_ENABLE_ON | SPI_CKE_ON | SPI_SMP_ON), (SPI_ENABLE));
159:                     int SPIMODE = (SPI_OPEN_MSTEN|SPI_OPEN_MODE8|SPI_OPEN_CKE_REV|SPI_OPEN_SMP_END|SPI_OPEN_TBE_NOT_FULL);
9D007BDC  2402032C   ADDIU V0, ZERO, 812
9D007BE0  AFC20010   SW V0, 16(S8)
160:                     SpiChnOpen(4, SPIMODE, 4);
9D007BE4  8FC20010   LW V0, 16(S8)
9D007BE8  24040004   ADDIU A0, ZERO, 4
9D007BEC  00402821   ADDU A1, V0, ZERO
9D007BF0  24060004   ADDIU A2, ZERO, 4
9D007BF4  0F403210   JAL SpiChnOpen
9D007BF8  00000000   NOP
161:                     SPI4CONbits.ON = 1;
9D007BFC  3C03BF80   LUI V1, -16512
9D007C00  8C625C00   LW V0, 23552(V1)
9D007C04  24040001   ADDIU A0, ZERO, 1
9D007C08  7C827BC4   INS V0, A0, 15, 1
9D007C0C  AC625C00   SW V0, 23552(V1)
162:                 
163:                     SPI4BRG = 4;
9D007C10  3C02BF80   LUI V0, -16512
9D007C14  24030004   ADDIU V1, ZERO, 4
9D007C18  AC435C30   SW V1, 23600(V0)
164:                 }
9D007C1C  03C0E821   ADDU SP, S8, ZERO
9D007C20  8FBF001C   LW RA, 28(SP)
9D007C24  8FBE0018   LW S8, 24(SP)
9D007C28  27BD0020   ADDIU SP, SP, 32
9D007C2C  03E00008   JR RA
9D007C30  00000000   NOP
165:                 
166:                 static
167:                 void power_off(void) {
9D007C34  27BDFFE8   ADDIU SP, SP, -24
9D007C38  AFBF0014   SW RA, 20(SP)
9D007C3C  AFBE0010   SW S8, 16(SP)
9D007C40  03A0F021   ADDU S8, SP, ZERO
168:                     select(); /* Wait for card ready */
9D007C44  0F401ED9   JAL 0x9D007B64
9D007C48  00000000   NOP
169:                     deselect();
9D007C4C  0F401EC9   JAL 0x9D007B24
9D007C50  00000000   NOP
170:                 
171:                     SPI4CONbits.ON = 0;
9D007C54  3C03BF80   LUI V1, -16512
9D007C58  8C625C00   LW V0, 23552(V1)
9D007C5C  7C027BC4   INS V0, ZERO, 15, 1
9D007C60  AC625C00   SW V0, 23552(V1)
172:                     //SPI4STATbits.SPIEN = 0; /* Disable SPI4 */
173:                 
174:                     /* Turn off socket power */
175:                 
176:                     Stat |= STA_NOINIT; /* Force uninitialized */
9D007C64  93828020   LBU V0, -32736(GP)
9D007C68  304200FF   ANDI V0, V0, 255
9D007C6C  34420001   ORI V0, V0, 1
9D007C70  304200FF   ANDI V0, V0, 255
9D007C74  A3828020   SB V0, -32736(GP)
177:                 }
9D007C78  03C0E821   ADDU SP, S8, ZERO
9D007C7C  8FBF0014   LW RA, 20(SP)
9D007C80  8FBE0010   LW S8, 16(SP)
9D007C84  27BD0018   ADDIU SP, SP, 24
9D007C88  03E00008   JR RA
9D007C8C  00000000   NOP
178:                 
179:                 
180:                 
181:                 /*-----------------------------------------------------------------------*/
182:                 /* Receive a data packet from MMC                                        */
183:                 
184:                 /*-----------------------------------------------------------------------*/
185:                 
186:                 static
187:                 int rcvr_datablock(/* 1:OK, 0:Failed */
188:                         BYTE *buff, /* Data buffer to store received data */
189:                         UINT btr /* Byte count (must be multiple of 4) */
190:                         ) {
9D007C90  27BDFFE0   ADDIU SP, SP, -32
9D007C94  AFBF001C   SW RA, 28(SP)
9D007C98  AFBE0018   SW S8, 24(SP)
9D007C9C  03A0F021   ADDU S8, SP, ZERO
9D007CA0  AFC40020   SW A0, 32(S8)
9D007CA4  AFC50024   SW A1, 36(S8)
191:                     BYTE token;
192:                 
193:                 
194:                     Timer1 = 100;
9D007CA8  24020064   ADDIU V0, ZERO, 100
9D007CAC  AF82804C   SW V0, -32692(GP)
195:                     do { /* Wait for data packet in timeout of 100ms */
196:                         token = rcvr_spi();
9D007CB0  240400FF   ADDIU A0, ZERO, 255
9D007CB4  0F401E99   JAL 0x9D007A64
9D007CB8  00000000   NOP
9D007CBC  A3C20010   SB V0, 16(S8)
197:                     } while ((token == 0xFF) && Timer1);
9D007CC0  93C30010   LBU V1, 16(S8)
9D007CC4  240200FF   ADDIU V0, ZERO, 255
9D007CC8  14620004   BNE V1, V0, 0x9D007CDC
9D007CCC  00000000   NOP
9D007CD0  8F82804C   LW V0, -32692(GP)
9D007CD4  1440FFF6   BNE V0, ZERO, 0x9D007CB0
9D007CD8  00000000   NOP
198:                 
199:                     if (token != 0xFE) return 0; /* If not valid data token, retutn with error */
9D007CDC  93C30010   LBU V1, 16(S8)
9D007CE0  240200FE   ADDIU V0, ZERO, 254
9D007CE4  10620004   BEQ V1, V0, 0x9D007CF8
9D007CE8  00000000   NOP
9D007CEC  00001021   ADDU V0, ZERO, ZERO
9D007CF0  0B401F8B   J 0x9D007E2C
9D007CF4  00000000   NOP
200:                 
201:                     do { /* Receive the data block into buffer */
202:                         rcvr_spi_m(buff++);
9D007CF8  3C02BF80   LUI V0, -16512
9D007CFC  240300FF   ADDIU V1, ZERO, 255
9D007D00  AC435C20   SW V1, 23584(V0)
9D007D04  3C02BF80   LUI V0, -16512
9D007D08  8C425C10   LW V0, 23568(V0)
9D007D0C  30420001   ANDI V0, V0, 1
9D007D10  1040FFFC   BEQ V0, ZERO, 0x9D007D04
9D007D14  00000000   NOP
9D007D18  3C02BF80   LUI V0, -16512
9D007D1C  8C425C20   LW V0, 23584(V0)
9D007D20  304300FF   ANDI V1, V0, 255
9D007D24  8FC20020   LW V0, 32(S8)
9D007D28  A0430000   SB V1, 0(V0)
9D007D2C  8FC20020   LW V0, 32(S8)
9D007D30  24420001   ADDIU V0, V0, 1
9D007D34  AFC20020   SW V0, 32(S8)
203:                         rcvr_spi_m(buff++);
9D007D38  3C02BF80   LUI V0, -16512
9D007D3C  240300FF   ADDIU V1, ZERO, 255
9D007D40  AC435C20   SW V1, 23584(V0)
9D007D44  3C02BF80   LUI V0, -16512
9D007D48  8C425C10   LW V0, 23568(V0)
9D007D4C  30420001   ANDI V0, V0, 1
9D007D50  1040FFFC   BEQ V0, ZERO, 0x9D007D44
9D007D54  00000000   NOP
9D007D58  3C02BF80   LUI V0, -16512
9D007D5C  8C425C20   LW V0, 23584(V0)
9D007D60  304300FF   ANDI V1, V0, 255
9D007D64  8FC20020   LW V0, 32(S8)
9D007D68  A0430000   SB V1, 0(V0)
9D007D6C  8FC20020   LW V0, 32(S8)
9D007D70  24420001   ADDIU V0, V0, 1
9D007D74  AFC20020   SW V0, 32(S8)
204:                         rcvr_spi_m(buff++);
9D007D78  3C02BF80   LUI V0, -16512
9D007D7C  240300FF   ADDIU V1, ZERO, 255
9D007D80  AC435C20   SW V1, 23584(V0)
9D007D84  3C02BF80   LUI V0, -16512
9D007D88  8C425C10   LW V0, 23568(V0)
9D007D8C  30420001   ANDI V0, V0, 1
9D007D90  1040FFFC   BEQ V0, ZERO, 0x9D007D84
9D007D94  00000000   NOP
9D007D98  3C02BF80   LUI V0, -16512
9D007D9C  8C425C20   LW V0, 23584(V0)
9D007DA0  304300FF   ANDI V1, V0, 255
9D007DA4  8FC20020   LW V0, 32(S8)
9D007DA8  A0430000   SB V1, 0(V0)
9D007DAC  8FC20020   LW V0, 32(S8)
9D007DB0  24420001   ADDIU V0, V0, 1
9D007DB4  AFC20020   SW V0, 32(S8)
205:                         rcvr_spi_m(buff++);
9D007DB8  3C02BF80   LUI V0, -16512
9D007DBC  240300FF   ADDIU V1, ZERO, 255
9D007DC0  AC435C20   SW V1, 23584(V0)
9D007DC4  3C02BF80   LUI V0, -16512
9D007DC8  8C425C10   LW V0, 23568(V0)
9D007DCC  30420001   ANDI V0, V0, 1
9D007DD0  1040FFFC   BEQ V0, ZERO, 0x9D007DC4
9D007DD4  00000000   NOP
9D007DD8  3C02BF80   LUI V0, -16512
9D007DDC  8C425C20   LW V0, 23584(V0)
9D007DE0  304300FF   ANDI V1, V0, 255
9D007DE4  8FC20020   LW V0, 32(S8)
9D007DE8  A0430000   SB V1, 0(V0)
9D007DEC  8FC20020   LW V0, 32(S8)
9D007DF0  24420001   ADDIU V0, V0, 1
9D007DF4  AFC20020   SW V0, 32(S8)
206:                     } while (btr -= 4);
9D007DF8  8FC20024   LW V0, 36(S8)
9D007DFC  2442FFFC   ADDIU V0, V0, -4
9D007E00  AFC20024   SW V0, 36(S8)
9D007E04  8FC20024   LW V0, 36(S8)
9D007E08  1440FFBB   BNE V0, ZERO, 0x9D007CF8
9D007E0C  00000000   NOP
207:                     rcvr_spi(); /* Discard CRC */
9D007E10  240400FF   ADDIU A0, ZERO, 255
9D007E14  0F401E99   JAL 0x9D007A64
9D007E18  00000000   NOP
208:                     rcvr_spi();
9D007E1C  240400FF   ADDIU A0, ZERO, 255
9D007E20  0F401E99   JAL 0x9D007A64
9D007E24  00000000   NOP
209:                 
210:                     return 1; /* Return with success */
9D007E28  24020001   ADDIU V0, ZERO, 1
211:                 }
9D007E2C  03C0E821   ADDU SP, S8, ZERO
9D007E30  8FBF001C   LW RA, 28(SP)
9D007E34  8FBE0018   LW S8, 24(SP)
9D007E38  27BD0020   ADDIU SP, SP, 32
9D007E3C  03E00008   JR RA
9D007E40  00000000   NOP
212:                 
213:                 
214:                 
215:                 /*-----------------------------------------------------------------------*/
216:                 /* Send a data packet to MMC                                             */
217:                 /*-----------------------------------------------------------------------*/
218:                 
219:                 #if _READONLY == 0
220:                 
221:                 static
222:                 int xmit_datablock(/* 1:OK, 0:Failed */
223:                         const BYTE *buff, /* 512 byte data block to be transmitted */
224:                         BYTE token /* Data token */
225:                         ) {
9D007E44  27BDFFE0   ADDIU SP, SP, -32
9D007E48  AFBF001C   SW RA, 28(SP)
9D007E4C  AFBE0018   SW S8, 24(SP)
9D007E50  03A0F021   ADDU S8, SP, ZERO
9D007E54  AFC40020   SW A0, 32(S8)
9D007E58  00A01021   ADDU V0, A1, ZERO
9D007E5C  A3C20024   SB V0, 36(S8)
226:                     BYTE resp;
227:                     UINT bc = 512;
9D007E60  24020200   ADDIU V0, ZERO, 512
9D007E64  AFC20010   SW V0, 16(S8)
228:                 
229:                 
230:                     if (!wait_ready()) return 0;
9D007E68  0F401EAF   JAL 0x9D007ABC
9D007E6C  00000000   NOP
9D007E70  14400004   BNE V0, ZERO, 0x9D007E84
9D007E74  00000000   NOP
9D007E78  00001021   ADDU V0, ZERO, ZERO
9D007E7C  0B401FD2   J 0x9D007F48
9D007E80  00000000   NOP
231:                 
232:                     xmit_spi(token); /* Xmit a token */
9D007E84  93C20024   LBU V0, 36(S8)
9D007E88  00402021   ADDU A0, V0, ZERO
9D007E8C  0F401E99   JAL 0x9D007A64
9D007E90  00000000   NOP
233:                     if (token != 0xFD) { /* Not StopTran token */
9D007E94  93C30024   LBU V1, 36(S8)
9D007E98  240200FD   ADDIU V0, ZERO, 253
9D007E9C  10620029   BEQ V1, V0, 0x9D007F44
9D007EA0  00000000   NOP
234:                 
235:                 
236:                         /*
237:                         //set up DMA
238:                         INTClearFlag(INT_SOURCE_SPI_TX(4)); //clear SPI 4 TX FLAG
239:                 
240:                         DmaChnOpen(DMA_CHANNEL1, DMA_CHN_PRI3, DMA_OPEN_DEFAULT); //Open DMA channel 1 in default mode
241:                         DmaChnSetEventControl(DMA_CHANNEL1, DMA_EV_START_IRQ_EN|DMA_EV_START_IRQ(INT_SOURCE_SPI_TX(4))); //gate DMA transfer on SPI TX interrupt
242:                         
243:                         DmaChnSetTxfer(DMA_CHANNEL1,(unsigned char*)buff, (void*)&SPI4BUF, 512, 1, 1);  //set source from buff and destination as SPI4 with 512 bytes total size in 4 byte chunks
244:                         //transfer buff to SPI
245:                         DmaChnStartTxfer(DMA_CHANNEL1, DMA_WAIT_BLOCK, 0);  //blocking DMA transfer
246:                 
247:                         //clean up DMA
248:                         SPI4STATbits.SPIROV = 0;  //clear SPI RX over write
249:                         INTClearFlag(INT_SOURCE_SPI_TX(4)); //clear SPI TX FLAG
250:                 
251:                         while(SPI4STATbits.SPIBUSY==1);
252:                         volatile unsigned char discard=SPI4BUF;
253:                         */
254:                 
255:                         
256:                         do { // Xmit the 512 byte data block to the MMC
257:                             xmit_spi(*buff++);
9D007EA4  8FC20020   LW V0, 32(S8)
9D007EA8  90420000   LBU V0, 0(V0)
9D007EAC  8FC30020   LW V1, 32(S8)
9D007EB0  24630001   ADDIU V1, V1, 1
9D007EB4  AFC30020   SW V1, 32(S8)
9D007EB8  00402021   ADDU A0, V0, ZERO
9D007EBC  0F401E99   JAL 0x9D007A64
9D007EC0  00000000   NOP
258:                             xmit_spi(*buff++);
9D007EC4  8FC20020   LW V0, 32(S8)
9D007EC8  90420000   LBU V0, 0(V0)
9D007ECC  8FC30020   LW V1, 32(S8)
9D007ED0  24630001   ADDIU V1, V1, 1
9D007ED4  AFC30020   SW V1, 32(S8)
9D007ED8  00402021   ADDU A0, V0, ZERO
9D007EDC  0F401E99   JAL 0x9D007A64
9D007EE0  00000000   NOP
259:                         } while (bc -= 2);
9D007EE4  8FC20010   LW V0, 16(S8)
9D007EE8  2442FFFE   ADDIU V0, V0, -2
9D007EEC  AFC20010   SW V0, 16(S8)
9D007EF0  8FC20010   LW V0, 16(S8)
9D007EF4  1440FFEB   BNE V0, ZERO, 0x9D007EA4
9D007EF8  00000000   NOP
260:                        
261:                 
262:                 
263:                         xmit_spi(0xFF); /* CRC (Dummy) */
9D007EFC  240400FF   ADDIU A0, ZERO, 255
9D007F00  0F401E99   JAL 0x9D007A64
9D007F04  00000000   NOP
264:                         xmit_spi(0xFF);
9D007F08  240400FF   ADDIU A0, ZERO, 255
9D007F0C  0F401E99   JAL 0x9D007A64
9D007F10  00000000   NOP
265:                         resp = rcvr_spi(); /* Receive a data response */
9D007F14  240400FF   ADDIU A0, ZERO, 255
9D007F18  0F401E99   JAL 0x9D007A64
9D007F1C  00000000   NOP
9D007F20  A3C20014   SB V0, 20(S8)
266:                         if ((resp & 0x1F) != 0x05) /* If not accepted, return with error */
9D007F24  93C20014   LBU V0, 20(S8)
9D007F28  3043001F   ANDI V1, V0, 31
9D007F2C  24020005   ADDIU V0, ZERO, 5
9D007F30  10620004   BEQ V1, V0, 0x9D007F44
9D007F34  00000000   NOP
267:                             return 0;
9D007F38  00001021   ADDU V0, ZERO, ZERO
9D007F3C  0B401FD2   J 0x9D007F48
9D007F40  00000000   NOP
268:                     }
269:                 
270:                     return 1;
9D007F44  24020001   ADDIU V0, ZERO, 1
271:                 }
9D007F48  03C0E821   ADDU SP, S8, ZERO
9D007F4C  8FBF001C   LW RA, 28(SP)
9D007F50  8FBE0018   LW S8, 24(SP)
9D007F54  27BD0020   ADDIU SP, SP, 32
9D007F58  03E00008   JR RA
9D007F5C  00000000   NOP
272:                 #endif	/* _READONLY */
273:                 
274:                 
275:                 
276:                 /*-----------------------------------------------------------------------*/
277:                 /* Send a command packet to MMC                                          */
278:                 
279:                 /*-----------------------------------------------------------------------*/
280:                 
281:                 static
282:                 BYTE send_cmd(
283:                         BYTE cmd, /* Command byte */
284:                         DWORD arg /* Argument */
285:                         ) {
9D007F60  27BDFFE0   ADDIU SP, SP, -32
9D007F64  AFBF001C   SW RA, 28(SP)
9D007F68  AFBE0018   SW S8, 24(SP)
9D007F6C  03A0F021   ADDU S8, SP, ZERO
9D007F70  00801021   ADDU V0, A0, ZERO
9D007F74  AFC50024   SW A1, 36(S8)
9D007F78  A3C20020   SB V0, 32(S8)
286:                     BYTE n, res;
287:                 
288:                 
289:                     if (cmd & 0x80) { /* ACMD<n> is the command sequense of CMD55-CMD<n> */
9D007F7C  83C20020   LB V0, 32(S8)
9D007F80  04410010   BGEZ V0, 0x9D007FC4
9D007F84  00000000   NOP
290:                         cmd &= 0x7F;
9D007F88  93C20020   LBU V0, 32(S8)
9D007F8C  3042007F   ANDI V0, V0, 127
9D007F90  A3C20020   SB V0, 32(S8)
291:                         res = send_cmd(CMD55, 0);
9D007F94  24040037   ADDIU A0, ZERO, 55
9D007F98  00002821   ADDU A1, ZERO, ZERO
9D007F9C  0F401FD8   JAL 0x9D007F60
9D007FA0  00000000   NOP
9D007FA4  A3C20011   SB V0, 17(S8)
292:                         if (res > 1) return res;
9D007FA8  93C20011   LBU V0, 17(S8)
9D007FAC  2C420002   SLTIU V0, V0, 2
9D007FB0  14400004   BNE V0, ZERO, 0x9D007FC4
9D007FB4  00000000   NOP
9D007FB8  93C20011   LBU V0, 17(S8)
9D007FBC  0B40203F   J 0x9D0080FC
9D007FC0  00000000   NOP
293:                     }
294:                 
295:                     /* Select the card and wait for ready */
296:                     deselect();
9D007FC4  0F401EC9   JAL 0x9D007B24
9D007FC8  00000000   NOP
297:                     if (!select()) return 0xFF;
9D007FCC  0F401ED9   JAL 0x9D007B64
9D007FD0  00000000   NOP
9D007FD4  14400004   BNE V0, ZERO, 0x9D007FE8
9D007FD8  00000000   NOP
9D007FDC  240200FF   ADDIU V0, ZERO, 255
9D007FE0  0B40203F   J 0x9D0080FC
9D007FE4  00000000   NOP
298:                 
299:                     /* Send command packet */
300:                     xmit_spi(0x40 | cmd); /* Start + Command index */
9D007FE8  93C20020   LBU V0, 32(S8)
9D007FEC  34420040   ORI V0, V0, 64
9D007FF0  304200FF   ANDI V0, V0, 255
9D007FF4  00402021   ADDU A0, V0, ZERO
9D007FF8  0F401E99   JAL 0x9D007A64
9D007FFC  00000000   NOP
301:                     xmit_spi((BYTE) (arg >> 24)); /* Argument[31..24] */
9D008000  8FC20024   LW V0, 36(S8)
9D008004  00021602   SRL V0, V0, 24
9D008008  304200FF   ANDI V0, V0, 255
9D00800C  00402021   ADDU A0, V0, ZERO
9D008010  0F401E99   JAL 0x9D007A64
9D008014  00000000   NOP
302:                     xmit_spi((BYTE) (arg >> 16)); /* Argument[23..16] */
9D008018  8FC20024   LW V0, 36(S8)
9D00801C  00021402   SRL V0, V0, 16
9D008020  304200FF   ANDI V0, V0, 255
9D008024  00402021   ADDU A0, V0, ZERO
9D008028  0F401E99   JAL 0x9D007A64
9D00802C  00000000   NOP
303:                     xmit_spi((BYTE) (arg >> 8)); /* Argument[15..8] */
9D008030  8FC20024   LW V0, 36(S8)
9D008034  00021202   SRL V0, V0, 8
9D008038  304200FF   ANDI V0, V0, 255
9D00803C  00402021   ADDU A0, V0, ZERO
9D008040  0F401E99   JAL 0x9D007A64
9D008044  00000000   NOP
304:                     xmit_spi((BYTE) arg); /* Argument[7..0] */
9D008048  8FC20024   LW V0, 36(S8)
9D00804C  304200FF   ANDI V0, V0, 255
9D008050  00402021   ADDU A0, V0, ZERO
9D008054  0F401E99   JAL 0x9D007A64
9D008058  00000000   NOP
305:                     n = 0x01; /* Dummy CRC + Stop */
9D00805C  24020001   ADDIU V0, ZERO, 1
9D008060  A3C20010   SB V0, 16(S8)
306:                     if (cmd == CMD0) n = 0x95; /* Valid CRC for CMD0(0) */
9D008064  93C20020   LBU V0, 32(S8)
9D008068  14400003   BNE V0, ZERO, 0x9D008078
9D00806C  00000000   NOP
9D008070  2402FF95   ADDIU V0, ZERO, -107
9D008074  A3C20010   SB V0, 16(S8)
307:                     if (cmd == CMD8) n = 0x87; /* Valid CRC for CMD8(0x1AA) */
9D008078  93C30020   LBU V1, 32(S8)
9D00807C  24020008   ADDIU V0, ZERO, 8
9D008080  14620003   BNE V1, V0, 0x9D008090
9D008084  00000000   NOP
9D008088  2402FF87   ADDIU V0, ZERO, -121
9D00808C  A3C20010   SB V0, 16(S8)
308:                     xmit_spi(n);
9D008090  93C20010   LBU V0, 16(S8)
9D008094  00402021   ADDU A0, V0, ZERO
9D008098  0F401E99   JAL 0x9D007A64
9D00809C  00000000   NOP
309:                 
310:                     /* Receive command response */
311:                     if (cmd == CMD12) rcvr_spi(); /* Skip a stuff byte when stop reading */
9D0080A0  93C30020   LBU V1, 32(S8)
9D0080A4  2402000C   ADDIU V0, ZERO, 12
9D0080A8  14620004   BNE V1, V0, 0x9D0080BC
9D0080AC  00000000   NOP
9D0080B0  240400FF   ADDIU A0, ZERO, 255
9D0080B4  0F401E99   JAL 0x9D007A64
9D0080B8  00000000   NOP
312:                     n = 10; /* Wait for a valid response in timeout of 10 attempts */
9D0080BC  2402000A   ADDIU V0, ZERO, 10
9D0080C0  A3C20010   SB V0, 16(S8)
313:                     do
314:                         res = rcvr_spi(); while ((res & 0x80) && --n);
9D0080C4  240400FF   ADDIU A0, ZERO, 255
9D0080C8  0F401E99   JAL 0x9D007A64
9D0080CC  00000000   NOP
9D0080D0  A3C20011   SB V0, 17(S8)
9D0080D4  83C20011   LB V0, 17(S8)
9D0080D8  04410007   BGEZ V0, 0x9D0080F8
9D0080DC  00000000   NOP
9D0080E0  93C20010   LBU V0, 16(S8)
9D0080E4  2442FFFF   ADDIU V0, V0, -1
9D0080E8  A3C20010   SB V0, 16(S8)
9D0080EC  93C20010   LBU V0, 16(S8)
9D0080F0  1440FFF4   BNE V0, ZERO, 0x9D0080C4
9D0080F4  00000000   NOP
315:                 
316:                     return res; /* Return with the response value */
9D0080F8  93C20011   LBU V0, 17(S8)
317:                 }
9D0080FC  03C0E821   ADDU SP, S8, ZERO
9D008100  8FBF001C   LW RA, 28(SP)
9D008104  8FBE0018   LW S8, 24(SP)
9D008108  27BD0020   ADDIU SP, SP, 32
9D00810C  03E00008   JR RA
9D008110  00000000   NOP
318:                 
319:                 
320:                 
321:                 /*--------------------------------------------------------------------------
322:                 
323:                    Public Functions
324:                 
325:                 ---------------------------------------------------------------------------*/
326:                 
327:                 
328:                 /*-----------------------------------------------------------------------*/
329:                 /* Initialize Disk Drive                                                 */
330:                 
331:                 /*-----------------------------------------------------------------------*/
332:                 
333:                 DSTATUS disk_initialize(
334:                         BYTE drv /* Physical drive nmuber (0) */
335:                         ) {
9D008114  27BDFFD8   ADDIU SP, SP, -40
9D008118  AFBF0024   SW RA, 36(SP)
9D00811C  AFBE0020   SW S8, 32(SP)
9D008120  AFB0001C   SW S0, 28(SP)
9D008124  03A0F021   ADDU S8, SP, ZERO
9D008128  00801021   ADDU V0, A0, ZERO
9D00812C  A3C20028   SB V0, 40(S8)
336:                     BYTE n, cmd, ty, ocr[4];
337:                 
338:                 
339:                     if (drv) return STA_NOINIT; /* Supports only single drive */
9D008130  93C20028   LBU V0, 40(S8)
9D008134  10400004   BEQ V0, ZERO, 0x9D008148
9D008138  00000000   NOP
9D00813C  24020001   ADDIU V0, ZERO, 1
9D008140  0B402117   J 0x9D00845C
9D008144  00000000   NOP
340:                     if (Stat & STA_NODISK) return Stat; /* No card in the socket */
9D008148  93828020   LBU V0, -32736(GP)
9D00814C  304200FF   ANDI V0, V0, 255
9D008150  30420002   ANDI V0, V0, 2
9D008154  10400005   BEQ V0, ZERO, 0x9D00816C
9D008158  00000000   NOP
9D00815C  93828020   LBU V0, -32736(GP)
9D008160  304200FF   ANDI V0, V0, 255
9D008164  0B402117   J 0x9D00845C
9D008168  00000000   NOP
341:                 
342:                     power_on(); /* Force socket power on */
9D00816C  0F401EF3   JAL 0x9D007BCC
9D008170  00000000   NOP
343:                     FCLK_SLOW();
9D008174  3C03BF80   LUI V1, -16512
9D008178  8C625C00   LW V0, 23552(V1)
9D00817C  7C027BC4   INS V0, ZERO, 15, 1
9D008180  AC625C00   SW V0, 23552(V1)
9D008184  3C02BF80   LUI V0, -16512
9D008188  24030020   ADDIU V1, ZERO, 32
9D00818C  AC435C30   SW V1, 23600(V0)
9D008190  3C03BF80   LUI V1, -16512
9D008194  8C625C00   LW V0, 23552(V1)
9D008198  24040001   ADDIU A0, ZERO, 1
9D00819C  7C827BC4   INS V0, A0, 15, 1
9D0081A0  AC625C00   SW V0, 23552(V1)
344:                     for (n = 10; n; n--) rcvr_spi(); /* 80 dummy clocks */
9D0081A4  2402000A   ADDIU V0, ZERO, 10
9D0081A8  A3C20010   SB V0, 16(S8)
9D0081AC  0B402073   J 0x9D0081CC
9D0081B0  00000000   NOP
9D0081B4  240400FF   ADDIU A0, ZERO, 255
9D0081B8  0F401E99   JAL 0x9D007A64
9D0081BC  00000000   NOP
9D0081C0  93C20010   LBU V0, 16(S8)
9D0081C4  2442FFFF   ADDIU V0, V0, -1
9D0081C8  A3C20010   SB V0, 16(S8)
9D0081CC  93C20010   LBU V0, 16(S8)
9D0081D0  1440FFF8   BNE V0, ZERO, 0x9D0081B4
9D0081D4  00000000   NOP
345:                 
346:                     ty = 0;
9D0081D8  A3C00012   SB ZERO, 18(S8)
347:                     if (send_cmd(CMD0, 0) == 1) { /* Enter Idle state */
9D0081DC  00002021   ADDU A0, ZERO, ZERO
9D0081E0  00002821   ADDU A1, ZERO, ZERO
9D0081E4  0F401FD8   JAL 0x9D007F60
9D0081E8  00000000   NOP
9D0081EC  00401821   ADDU V1, V0, ZERO
9D0081F0  24020001   ADDIU V0, ZERO, 1
9D0081F4  1462007B   BNE V1, V0, 0x9D0083E4
9D0081F8  00000000   NOP
348:                         Timer1 = 1000; /* Initialization timeout of 1000 msec */
9D0081FC  240203E8   ADDIU V0, ZERO, 1000
9D008200  AF82804C   SW V0, -32692(GP)
349:                         if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2? */
9D008204  24040008   ADDIU A0, ZERO, 8
9D008208  240501AA   ADDIU A1, ZERO, 426
9D00820C  0F401FD8   JAL 0x9D007F60
9D008210  00000000   NOP
9D008214  00401821   ADDU V1, V0, ZERO
9D008218  24020001   ADDIU V0, ZERO, 1
9D00821C  1462004B   BNE V1, V0, 0x9D00834C
9D008220  00000000   NOP
350:                             for (n = 0; n < 4; n++) ocr[n] = rcvr_spi(); /* Get trailing return value of R7 resp */
9D008224  A3C00010   SB ZERO, 16(S8)
9D008228  0B402097   J 0x9D00825C
9D00822C  00000000   NOP
9D008230  93D00010   LBU S0, 16(S8)
9D008234  240400FF   ADDIU A0, ZERO, 255
9D008238  0F401E99   JAL 0x9D007A64
9D00823C  00000000   NOP
9D008240  00401821   ADDU V1, V0, ZERO
9D008244  27C20010   ADDIU V0, S8, 16
9D008248  00501021   ADDU V0, V0, S0
9D00824C  A0430004   SB V1, 4(V0)
9D008250  93C20010   LBU V0, 16(S8)
9D008254  24420001   ADDIU V0, V0, 1
9D008258  A3C20010   SB V0, 16(S8)
9D00825C  93C20010   LBU V0, 16(S8)
9D008260  2C420004   SLTIU V0, V0, 4
9D008264  1440FFF2   BNE V0, ZERO, 0x9D008230
9D008268  00000000   NOP
351:                             if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
9D00826C  93C30016   LBU V1, 22(S8)
9D008270  24020001   ADDIU V0, ZERO, 1
9D008274  1462005B   BNE V1, V0, 0x9D0083E4
9D008278  00000000   NOP
9D00827C  93C30017   LBU V1, 23(S8)
9D008280  240200AA   ADDIU V0, ZERO, 170
9D008284  14620057   BNE V1, V0, 0x9D0083E4
9D008288  00000000   NOP
352:                                 while (Timer1 && send_cmd(ACMD41, 0x40000000)); /* Wait for leaving idle state (ACMD41 with HCS bit) */
9D00828C  00000000   NOP
9D008290  8F82804C   LW V0, -32692(GP)
9D008294  10400007   BEQ V0, ZERO, 0x9D0082B4
9D008298  00000000   NOP
9D00829C  240400A9   ADDIU A0, ZERO, 169
9D0082A0  3C054000   LUI A1, 16384
9D0082A4  0F401FD8   JAL 0x9D007F60
9D0082A8  00000000   NOP
9D0082AC  1440FFF8   BNE V0, ZERO, 0x9D008290
9D0082B0  00000000   NOP
353:                                 if (Timer1 && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
9D0082B4  8F82804C   LW V0, -32692(GP)
9D0082B8  1040004A   BEQ V0, ZERO, 0x9D0083E4
9D0082BC  00000000   NOP
9D0082C0  2404003A   ADDIU A0, ZERO, 58
9D0082C4  00002821   ADDU A1, ZERO, ZERO
9D0082C8  0F401FD8   JAL 0x9D007F60
9D0082CC  00000000   NOP
9D0082D0  14400044   BNE V0, ZERO, 0x9D0083E4
9D0082D4  00000000   NOP
354:                                     for (n = 0; n < 4; n++) ocr[n] = rcvr_spi();
9D0082D8  A3C00010   SB ZERO, 16(S8)
9D0082DC  0B4020C4   J 0x9D008310
9D0082E0  00000000   NOP
9D0082E4  93D00010   LBU S0, 16(S8)
9D0082E8  240400FF   ADDIU A0, ZERO, 255
9D0082EC  0F401E99   JAL 0x9D007A64
9D0082F0  00000000   NOP
9D0082F4  00401821   ADDU V1, V0, ZERO
9D0082F8  27C20010   ADDIU V0, S8, 16
9D0082FC  00501021   ADDU V0, V0, S0
9D008300  A0430004   SB V1, 4(V0)
9D008304  93C20010   LBU V0, 16(S8)
9D008308  24420001   ADDIU V0, V0, 1
9D00830C  A3C20010   SB V0, 16(S8)
9D008310  93C20010   LBU V0, 16(S8)
9D008314  2C420004   SLTIU V0, V0, 4
9D008318  1440FFF2   BNE V0, ZERO, 0x9D0082E4
9D00831C  00000000   NOP
355:                                     ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2; /* SDv2 */
9D008320  93C20014   LBU V0, 20(S8)
9D008324  30420040   ANDI V0, V0, 64
9D008328  10400004   BEQ V0, ZERO, 0x9D00833C
9D00832C  00000000   NOP
9D008330  2402000C   ADDIU V0, ZERO, 12
9D008334  0B4020D0   J 0x9D008340
9D008338  00000000   NOP
9D00833C  24020004   ADDIU V0, ZERO, 4
9D008340  A3C20012   SB V0, 18(S8)
9D008344  0B4020F9   J 0x9D0083E4
9D008348  00000000   NOP
356:                                 }
357:                             }
358:                         } else { /* SDv1 or MMCv3 */
359:                             if (send_cmd(ACMD41, 0) <= 1) {
9D00834C  240400A9   ADDIU A0, ZERO, 169
9D008350  00002821   ADDU A1, ZERO, ZERO
9D008354  0F401FD8   JAL 0x9D007F60
9D008358  00000000   NOP
9D00835C  2C420002   SLTIU V0, V0, 2
9D008360  10400007   BEQ V0, ZERO, 0x9D008380
9D008364  00000000   NOP
360:                                 ty = CT_SD1;
9D008368  24020002   ADDIU V0, ZERO, 2
9D00836C  A3C20012   SB V0, 18(S8)
361:                                 cmd = ACMD41; /* SDv1 */
9D008370  2402FFA9   ADDIU V0, ZERO, -87
9D008374  A3C20011   SB V0, 17(S8)
362:                             } else {
363:                                 ty = CT_MMC;
9D008380  24020001   ADDIU V0, ZERO, 1
9D008384  A3C20012   SB V0, 18(S8)
364:                                 cmd = CMD1; /* MMCv3 */
9D008388  24020001   ADDIU V0, ZERO, 1
9D00838C  A3C20011   SB V0, 17(S8)
365:                             }
366:                             while (Timer1 && send_cmd(cmd, 0)); /* Wait for leaving idle state */
9D008378  0B4020E5   J 0x9D008394
9D00837C  00000000   NOP
9D008390  00000000   NOP
9D008394  8F82804C   LW V0, -32692(GP)
9D008398  10400008   BEQ V0, ZERO, 0x9D0083BC
9D00839C  00000000   NOP
9D0083A0  93C20011   LBU V0, 17(S8)
9D0083A4  00402021   ADDU A0, V0, ZERO
9D0083A8  00002821   ADDU A1, ZERO, ZERO
9D0083AC  0F401FD8   JAL 0x9D007F60
9D0083B0  00000000   NOP
9D0083B4  1440FFF7   BNE V0, ZERO, 0x9D008394
9D0083B8  00000000   NOP
367:                             if (!Timer1 || send_cmd(CMD16, 512) != 0) /* Set read/write block length to 512 */
9D0083BC  8F82804C   LW V0, -32692(GP)
9D0083C0  10400007   BEQ V0, ZERO, 0x9D0083E0
9D0083C4  00000000   NOP
9D0083C8  24040010   ADDIU A0, ZERO, 16
9D0083CC  24050200   ADDIU A1, ZERO, 512
9D0083D0  0F401FD8   JAL 0x9D007F60
9D0083D4  00000000   NOP
9D0083D8  10400002   BEQ V0, ZERO, 0x9D0083E4
9D0083DC  00000000   NOP
368:                                 ty = 0;
9D0083E0  A3C00012   SB ZERO, 18(S8)
369:                         }
370:                     }
371:                     CardType = ty;
9D0083E4  93C20012   LBU V0, 18(S8)
9D0083E8  AF828054   SW V0, -32684(GP)
372:                     deselect();
9D0083EC  0F401EC9   JAL 0x9D007B24
9D0083F0  00000000   NOP
373:                 
374:                     if (ty) { /* Initialization succeded */
9D0083F4  93C20012   LBU V0, 18(S8)
9D0083F8  10400014   BEQ V0, ZERO, 0x9D00844C
9D0083FC  00000000   NOP
375:                         Stat &= ~STA_NOINIT; /* Clear STA_NOINIT */
9D008400  93828020   LBU V0, -32736(GP)
9D008404  304300FF   ANDI V1, V0, 255
9D008408  2402FFFE   ADDIU V0, ZERO, -2
9D00840C  00621024   AND V0, V1, V0
9D008410  304200FF   ANDI V0, V0, 255
9D008414  A3828020   SB V0, -32736(GP)
376:                         FCLK_FAST();
9D008418  3C03BF80   LUI V1, -16512
9D00841C  8C625C00   LW V0, 23552(V1)
9D008420  7C027BC4   INS V0, ZERO, 15, 1
9D008424  AC625C00   SW V0, 23552(V1)
9D008428  3C02BF80   LUI V0, -16512
9D00842C  AC405C30   SW ZERO, 23600(V0)
9D008430  3C03BF80   LUI V1, -16512
9D008434  8C625C00   LW V0, 23552(V1)
9D008438  24040001   ADDIU A0, ZERO, 1
9D00843C  7C827BC4   INS V0, A0, 15, 1
9D008440  AC625C00   SW V0, 23552(V1)
9D008444  0B402115   J 0x9D008454
9D008448  00000000   NOP
377:                     } else { /* Initialization failed */
378:                         power_off();
9D00844C  0F401F0D   JAL 0x9D007C34
9D008450  00000000   NOP
379:                     }
380:                 
381:                     return Stat;
9D008454  93828020   LBU V0, -32736(GP)
9D008458  304200FF   ANDI V0, V0, 255
382:                 }
9D00845C  03C0E821   ADDU SP, S8, ZERO
9D008460  8FBF0024   LW RA, 36(SP)
9D008464  8FBE0020   LW S8, 32(SP)
9D008468  8FB0001C   LW S0, 28(SP)
9D00846C  27BD0028   ADDIU SP, SP, 40
9D008470  03E00008   JR RA
9D008474  00000000   NOP
383:                 
384:                 
385:                 
386:                 /*-----------------------------------------------------------------------*/
387:                 /* Get Disk Status                                                       */
388:                 
389:                 /*-----------------------------------------------------------------------*/
390:                 
391:                 DSTATUS disk_status(
392:                         BYTE drv /* Physical drive nmuber (0) */
393:                         ) {
9D008478  27BDFFF8   ADDIU SP, SP, -8
9D00847C  AFBE0004   SW S8, 4(SP)
9D008480  03A0F021   ADDU S8, SP, ZERO
9D008484  00801021   ADDU V0, A0, ZERO
9D008488  A3C20008   SB V0, 8(S8)
394:                     if (drv) return STA_NOINIT; /* Supports only single drive */
9D00848C  93C20008   LBU V0, 8(S8)
9D008490  10400004   BEQ V0, ZERO, 0x9D0084A4
9D008494  00000000   NOP
9D008498  24020001   ADDIU V0, ZERO, 1
9D00849C  0B40212B   J 0x9D0084AC
9D0084A0  00000000   NOP
395:                     return Stat;
9D0084A4  93828020   LBU V0, -32736(GP)
9D0084A8  304200FF   ANDI V0, V0, 255
396:                 }
9D0084AC  03C0E821   ADDU SP, S8, ZERO
9D0084B0  8FBE0004   LW S8, 4(SP)
9D0084B4  27BD0008   ADDIU SP, SP, 8
9D0084B8  03E00008   JR RA
9D0084BC  00000000   NOP
397:                 
398:                 
399:                 
400:                 /*-----------------------------------------------------------------------*/
401:                 /* Read Sector(s)                                                        */
402:                 
403:                 /*-----------------------------------------------------------------------*/
404:                 
405:                 DRESULT disk_read(
406:                         BYTE drv, /* Physical drive nmuber (0) */
407:                         BYTE *buff, /* Pointer to the data buffer to store read data */
408:                         DWORD sector, /* Start sector number (LBA) */
409:                         BYTE count /* Sector count (1..255) */
410:                         ) {
9D0084C0  27BDFFE8   ADDIU SP, SP, -24
9D0084C4  AFBF0014   SW RA, 20(SP)
9D0084C8  AFBE0010   SW S8, 16(SP)
9D0084CC  03A0F021   ADDU S8, SP, ZERO
9D0084D0  00801821   ADDU V1, A0, ZERO
9D0084D4  AFC5001C   SW A1, 28(S8)
9D0084D8  AFC60020   SW A2, 32(S8)
9D0084DC  00E01021   ADDU V0, A3, ZERO
9D0084E0  A3C30018   SB V1, 24(S8)
9D0084E4  A3C20024   SB V0, 36(S8)
411:                     if (drv || !count) return RES_PARERR;
9D0084E8  93C20018   LBU V0, 24(S8)
9D0084EC  14400004   BNE V0, ZERO, 0x9D008500
9D0084F0  00000000   NOP
9D0084F4  93C20024   LBU V0, 36(S8)
9D0084F8  14400004   BNE V0, ZERO, 0x9D00850C
9D0084FC  00000000   NOP
9D008500  24020004   ADDIU V0, ZERO, 4
9D008504  0B402186   J 0x9D008618
9D008508  00000000   NOP
412:                     if (Stat & STA_NOINIT) return RES_NOTRDY;
9D00850C  93828020   LBU V0, -32736(GP)
9D008510  304200FF   ANDI V0, V0, 255
9D008514  30420001   ANDI V0, V0, 1
9D008518  304200FF   ANDI V0, V0, 255
9D00851C  10400004   BEQ V0, ZERO, 0x9D008530
9D008520  00000000   NOP
9D008524  24020003   ADDIU V0, ZERO, 3
9D008528  0B402186   J 0x9D008618
9D00852C  00000000   NOP
413:                 
414:                     if (!(CardType & CT_BLOCK)) sector *= 512; /* Convert to byte address if needed */
9D008530  8F828054   LW V0, -32684(GP)
9D008534  30420008   ANDI V0, V0, 8
9D008538  14400004   BNE V0, ZERO, 0x9D00854C
9D00853C  00000000   NOP
9D008540  8FC20020   LW V0, 32(S8)
9D008544  00021240   SLL V0, V0, 9
9D008548  AFC20020   SW V0, 32(S8)
415:                 
416:                     if (count == 1) { /* Single block read */
9D00854C  93C30024   LBU V1, 36(S8)
9D008550  24020001   ADDIU V0, ZERO, 1
9D008554  14620010   BNE V1, V0, 0x9D008598
9D008558  00000000   NOP
417:                         if ((send_cmd(CMD17, sector) == 0) /* READ_SINGLE_BLOCK */
9D00855C  24040011   ADDIU A0, ZERO, 17
9D008560  8FC50020   LW A1, 32(S8)
9D008564  0F401FD8   JAL 0x9D007F60
9D008568  00000000   NOP
9D00856C  14400026   BNE V0, ZERO, 0x9D008608
9D008570  00000000   NOP
418:                                 && rcvr_datablock(buff, 512))
9D008574  8FC4001C   LW A0, 28(S8)
9D008578  24050200   ADDIU A1, ZERO, 512
9D00857C  0F401F24   JAL 0x9D007C90
9D008580  00000000   NOP
9D008584  10400020   BEQ V0, ZERO, 0x9D008608
9D008588  00000000   NOP
419:                             count = 0;
9D00858C  A3C00024   SB ZERO, 36(S8)
9D008590  0B402182   J 0x9D008608
9D008594  00000000   NOP
420:                     } else { /* Multiple block read */
421:                         if (send_cmd(CMD18, sector) == 0) { /* READ_MULTIPLE_BLOCK */
9D008598  24040012   ADDIU A0, ZERO, 18
9D00859C  8FC50020   LW A1, 32(S8)
9D0085A0  0F401FD8   JAL 0x9D007F60
9D0085A4  00000000   NOP
9D0085A8  14400017   BNE V0, ZERO, 0x9D008608
9D0085AC  00000000   NOP
422:                             do {
423:                                 if (!rcvr_datablock(buff, 512)) break;
9D0085B0  8FC4001C   LW A0, 28(S8)
9D0085B4  24050200   ADDIU A1, ZERO, 512
9D0085B8  0F401F24   JAL 0x9D007C90
9D0085BC  00000000   NOP
9D0085C0  1040000C   BEQ V0, ZERO, 0x9D0085F4
9D0085C4  00000000   NOP
9D0085F4  00000000   NOP
424:                                 buff += 512;
9D0085C8  8FC2001C   LW V0, 28(S8)
9D0085CC  24420200   ADDIU V0, V0, 512
9D0085D0  AFC2001C   SW V0, 28(S8)
425:                             } while (--count);
9D0085D4  93C20024   LBU V0, 36(S8)
9D0085D8  2442FFFF   ADDIU V0, V0, -1
9D0085DC  A3C20024   SB V0, 36(S8)
9D0085E0  93C20024   LBU V0, 36(S8)
9D0085E4  1440FFF2   BNE V0, ZERO, 0x9D0085B0
9D0085E8  00000000   NOP
9D0085EC  0B40217E   J 0x9D0085F8
9D0085F0  00000000   NOP
426:                             send_cmd(CMD12, 0); /* STOP_TRANSMISSION */
9D0085F8  2404000C   ADDIU A0, ZERO, 12
9D0085FC  00002821   ADDU A1, ZERO, ZERO
9D008600  0F401FD8   JAL 0x9D007F60
9D008604  00000000   NOP
427:                         }
428:                     }
429:                     deselect();
9D008608  0F401EC9   JAL 0x9D007B24
9D00860C  00000000   NOP
430:                 
431:                     return count ? RES_ERROR : RES_OK;
9D008610  93C20024   LBU V0, 36(S8)
9D008614  0002102B   SLTU V0, ZERO, V0
432:                 }
9D008618  03C0E821   ADDU SP, S8, ZERO
9D00861C  8FBF0014   LW RA, 20(SP)
9D008620  8FBE0010   LW S8, 16(SP)
9D008624  27BD0018   ADDIU SP, SP, 24
9D008628  03E00008   JR RA
9D00862C  00000000   NOP
433:                 
434:                 
435:                 
436:                 /*-----------------------------------------------------------------------*/
437:                 /* Write Sector(s)                                                       */
438:                 /*-----------------------------------------------------------------------*/
439:                 
440:                 #if _READONLY == 0
441:                 
442:                 DRESULT disk_write(
443:                         BYTE drv, /* Physical drive nmuber (0) */
444:                         const BYTE *buff, /* Pointer to the data to be written */
445:                         DWORD sector, /* Start sector number (LBA) */
446:                         BYTE count /* Sector count (1..255) */
447:                         ) {
9D008630  27BDFFE8   ADDIU SP, SP, -24
9D008634  AFBF0014   SW RA, 20(SP)
9D008638  AFBE0010   SW S8, 16(SP)
9D00863C  03A0F021   ADDU S8, SP, ZERO
9D008640  00801821   ADDU V1, A0, ZERO
9D008644  AFC5001C   SW A1, 28(S8)
9D008648  AFC60020   SW A2, 32(S8)
9D00864C  00E01021   ADDU V0, A3, ZERO
9D008650  A3C30018   SB V1, 24(S8)
9D008654  A3C20024   SB V0, 36(S8)
448:                     if (drv || !count) return RES_PARERR;
9D008658  93C20018   LBU V0, 24(S8)
9D00865C  14400004   BNE V0, ZERO, 0x9D008670
9D008660  00000000   NOP
9D008664  93C20024   LBU V0, 36(S8)
9D008668  14400004   BNE V0, ZERO, 0x9D00867C
9D00866C  00000000   NOP
9D008670  24020004   ADDIU V0, ZERO, 4
9D008674  0B4021F7   J 0x9D0087DC
9D008678  00000000   NOP
449:                     if (Stat & STA_NOINIT) return RES_NOTRDY;
9D00867C  93828020   LBU V0, -32736(GP)
9D008680  304200FF   ANDI V0, V0, 255
9D008684  30420001   ANDI V0, V0, 1
9D008688  304200FF   ANDI V0, V0, 255
9D00868C  10400004   BEQ V0, ZERO, 0x9D0086A0
9D008690  00000000   NOP
9D008694  24020003   ADDIU V0, ZERO, 3
9D008698  0B4021F7   J 0x9D0087DC
9D00869C  00000000   NOP
450:                     if (Stat & STA_PROTECT) return RES_WRPRT;
9D0086A0  93828020   LBU V0, -32736(GP)
9D0086A4  304200FF   ANDI V0, V0, 255
9D0086A8  30420004   ANDI V0, V0, 4
9D0086AC  10400004   BEQ V0, ZERO, 0x9D0086C0
9D0086B0  00000000   NOP
9D0086B4  24020002   ADDIU V0, ZERO, 2
9D0086B8  0B4021F7   J 0x9D0087DC
9D0086BC  00000000   NOP
451:                 
452:                     if (!(CardType & CT_BLOCK)) sector *= 512; /* Convert to byte address if needed */
9D0086C0  8F828054   LW V0, -32684(GP)
9D0086C4  30420008   ANDI V0, V0, 8
9D0086C8  14400004   BNE V0, ZERO, 0x9D0086DC
9D0086CC  00000000   NOP
9D0086D0  8FC20020   LW V0, 32(S8)
9D0086D4  00021240   SLL V0, V0, 9
9D0086D8  AFC20020   SW V0, 32(S8)
453:                 
454:                     if (count == 1) { /* Single block write */
9D0086DC  93C30024   LBU V1, 36(S8)
9D0086E0  24020001   ADDIU V0, ZERO, 1
9D0086E4  14620010   BNE V1, V0, 0x9D008728
9D0086E8  00000000   NOP
455:                         if ((send_cmd(CMD24, sector) == 0) /* WRITE_BLOCK */
9D0086EC  24040018   ADDIU A0, ZERO, 24
9D0086F0  8FC50020   LW A1, 32(S8)
9D0086F4  0F401FD8   JAL 0x9D007F60
9D0086F8  00000000   NOP
9D0086FC  14400033   BNE V0, ZERO, 0x9D0087CC
9D008700  00000000   NOP
456:                                 && xmit_datablock(buff, 0xFE))
9D008704  8FC4001C   LW A0, 28(S8)
9D008708  240500FE   ADDIU A1, ZERO, 254
9D00870C  0F401F91   JAL 0x9D007E44
9D008710  00000000   NOP
9D008714  1040002D   BEQ V0, ZERO, 0x9D0087CC
9D008718  00000000   NOP
457:                             count = 0;
9D00871C  A3C00024   SB ZERO, 36(S8)
9D008720  0B4021F3   J 0x9D0087CC
9D008724  00000000   NOP
458:                     } else { /* Multiple block write */
459:                         if (CardType & CT_SDC) send_cmd(ACMD23, count);
9D008728  8F828054   LW V0, -32684(GP)
9D00872C  30420006   ANDI V0, V0, 6
9D008730  10400006   BEQ V0, ZERO, 0x9D00874C
9D008734  00000000   NOP
9D008738  93C20024   LBU V0, 36(S8)
9D00873C  24040097   ADDIU A0, ZERO, 151
9D008740  00402821   ADDU A1, V0, ZERO
9D008744  0F401FD8   JAL 0x9D007F60
9D008748  00000000   NOP
460:                         if (send_cmd(CMD25, sector) == 0) { /* WRITE_MULTIPLE_BLOCK */
9D00874C  24040019   ADDIU A0, ZERO, 25
9D008750  8FC50020   LW A1, 32(S8)
9D008754  0F401FD8   JAL 0x9D007F60
9D008758  00000000   NOP
9D00875C  1440001B   BNE V0, ZERO, 0x9D0087CC
9D008760  00000000   NOP
461:                             do {
462:                                 if (!xmit_datablock(buff, 0xFC)) break;
9D008764  8FC4001C   LW A0, 28(S8)
9D008768  240500FC   ADDIU A1, ZERO, 252
9D00876C  0F401F91   JAL 0x9D007E44
9D008770  00000000   NOP
9D008774  1040000C   BEQ V0, ZERO, 0x9D0087A8
9D008778  00000000   NOP
9D0087A8  00000000   NOP
463:                                 buff += 512;
9D00877C  8FC2001C   LW V0, 28(S8)
9D008780  24420200   ADDIU V0, V0, 512
9D008784  AFC2001C   SW V0, 28(S8)
464:                             } while (--count);
9D008788  93C20024   LBU V0, 36(S8)
9D00878C  2442FFFF   ADDIU V0, V0, -1
9D008790  A3C20024   SB V0, 36(S8)
9D008794  93C20024   LBU V0, 36(S8)
9D008798  1440FFF2   BNE V0, ZERO, 0x9D008764
9D00879C  00000000   NOP
9D0087A0  0B4021EB   J 0x9D0087AC
9D0087A4  00000000   NOP
465:                             if (!xmit_datablock(0, 0xFD)) /* STOP_TRAN token */
9D0087AC  00002021   ADDU A0, ZERO, ZERO
9D0087B0  240500FD   ADDIU A1, ZERO, 253
9D0087B4  0F401F91   JAL 0x9D007E44
9D0087B8  00000000   NOP
9D0087BC  14400003   BNE V0, ZERO, 0x9D0087CC
9D0087C0  00000000   NOP
466:                                 count = 1;
9D0087C4  24020001   ADDIU V0, ZERO, 1
9D0087C8  A3C20024   SB V0, 36(S8)
467:                         }
468:                     }
469:                     deselect();
9D0087CC  0F401EC9   JAL 0x9D007B24
9D0087D0  00000000   NOP
470:                 
471:                     return count ? RES_ERROR : RES_OK;
9D0087D4  93C20024   LBU V0, 36(S8)
9D0087D8  0002102B   SLTU V0, ZERO, V0
472:                 }
9D0087DC  03C0E821   ADDU SP, S8, ZERO
9D0087E0  8FBF0014   LW RA, 20(SP)
9D0087E4  8FBE0010   LW S8, 16(SP)
9D0087E8  27BD0018   ADDIU SP, SP, 24
9D0087EC  03E00008   JR RA
9D0087F0  00000000   NOP
473:                 #endif /* _READONLY */
474:                 
475:                 
476:                 
477:                 /*-----------------------------------------------------------------------*/
478:                 /* Miscellaneous Functions                                               */
479:                 
480:                 /*-----------------------------------------------------------------------*/
481:                 
482:                 DRESULT disk_ioctl(
483:                         BYTE drv, /* Physical drive nmuber (0) */
484:                         BYTE ctrl, /* Control code */
485:                         void *buff /* Buffer to send/receive data block */
486:                         ) {
9D0087F4  27BDFFC0   ADDIU SP, SP, -64
9D0087F8  AFBF003C   SW RA, 60(SP)
9D0087FC  AFBE0038   SW S8, 56(SP)
9D008800  AFB00034   SW S0, 52(SP)
9D008804  03A0F021   ADDU S8, SP, ZERO
9D008808  00801821   ADDU V1, A0, ZERO
9D00880C  00A01021   ADDU V0, A1, ZERO
9D008810  AFC60048   SW A2, 72(S8)
9D008814  A3C30040   SB V1, 64(S8)
9D008818  A3C20044   SB V0, 68(S8)
487:                     DRESULT res;
488:                     BYTE n, csd[16], *ptr = buff;
9D00881C  8FC20048   LW V0, 72(S8)
9D008820  AFC20018   SW V0, 24(S8)
489:                     DWORD csize;
490:                 
491:                 
492:                     if (drv) return RES_PARERR;
9D008824  93C20040   LBU V0, 64(S8)
9D008828  10400004   BEQ V0, ZERO, 0x9D00883C
9D00882C  00000000   NOP
9D008830  24020004   ADDIU V0, ZERO, 4
9D008834  0B402374   J 0x9D008DD0
9D008838  00000000   NOP
493:                     if (Stat & STA_NOINIT) return RES_NOTRDY;
9D00883C  93828020   LBU V0, -32736(GP)
9D008840  304200FF   ANDI V0, V0, 255
9D008844  30420001   ANDI V0, V0, 1
9D008848  304200FF   ANDI V0, V0, 255
9D00884C  10400004   BEQ V0, ZERO, 0x9D008860
9D008850  00000000   NOP
9D008854  24020003   ADDIU V0, ZERO, 3
9D008858  0B402374   J 0x9D008DD0
9D00885C  00000000   NOP
494:                 
495:                     res = RES_ERROR;
9D008860  24020001   ADDIU V0, ZERO, 1
9D008864  AFC20010   SW V0, 16(S8)
496:                     switch (ctrl) {
9D008868  93C20044   LBU V0, 68(S8)
9D00886C  2C43000F   SLTIU V1, V0, 15
9D008870  10600125   BEQ V1, ZERO, 0x9D008D08
9D008874  00000000   NOP
9D008878  00021880   SLL V1, V0, 2
9D00887C  3C029D01   LUI V0, -25343
9D008880  24428894   ADDIU V0, V0, -30572
9D008884  00621021   ADDU V0, V1, V0
9D008888  8C420000   LW V0, 0(V0)
9D00888C  00400008   JR V0
9D008890  00000000   NOP
497:                         case CTRL_SYNC: /* Flush write-back cache, Wait for end of internal process */
498:                             if (select()) {
9D0088D0  0F401ED9   JAL 0x9D007B64
9D0088D4  00000000   NOP
9D0088D8  1040010F   BEQ V0, ZERO, 0x9D008D18
9D0088DC  00000000   NOP
499:                                 deselect();
9D0088E0  0F401EC9   JAL 0x9D007B24
9D0088E4  00000000   NOP
500:                                 res = RES_OK;
9D0088E8  AFC00010   SW ZERO, 16(S8)
501:                             }
502:                             break;
9D0088EC  0B402371   J 0x9D008DC4
9D0088F0  00000000   NOP
9D008D18  00000000   NOP
9D008D1C  0B402371   J 0x9D008DC4
9D008D20  00000000   NOP
503:                 
504:                         case GET_SECTOR_COUNT: /* Get number of sectors on the disk (WORD) */
505:                             if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
9D0088F4  24040009   ADDIU A0, ZERO, 9
9D0088F8  00002821   ADDU A1, ZERO, ZERO
9D0088FC  0F401FD8   JAL 0x9D007F60
9D008900  00000000   NOP
9D008904  14400107   BNE V0, ZERO, 0x9D008D24
9D008908  00000000   NOP
9D00890C  27C20020   ADDIU V0, S8, 32
9D008910  00402021   ADDU A0, V0, ZERO
9D008914  24050010   ADDIU A1, ZERO, 16
9D008918  0F401F24   JAL 0x9D007C90
9D00891C  00000000   NOP
9D008920  10400103   BEQ V0, ZERO, 0x9D008D30
9D008924  00000000   NOP
506:                                 if ((csd[0] >> 6) == 1) { /* SDv2? */
9D008928  93C20020   LBU V0, 32(S8)
9D00892C  00021182   SRL V0, V0, 6
9D008930  304300FF   ANDI V1, V0, 255
9D008934  24020001   ADDIU V0, ZERO, 1
9D008938  1462000E   BNE V1, V0, 0x9D008974
9D00893C  00000000   NOP
507:                                     csize = csd[9] + ((WORD) csd[8] << 8) + 1;
9D008940  93C20029   LBU V0, 41(S8)
9D008944  00401821   ADDU V1, V0, ZERO
9D008948  93C20028   LBU V0, 40(S8)
9D00894C  00021200   SLL V0, V0, 8
9D008950  00621021   ADDU V0, V1, V0
9D008954  24420001   ADDIU V0, V0, 1
9D008958  AFC2001C   SW V0, 28(S8)
508:                                     *(DWORD*) buff = (DWORD) csize << 10;
9D00895C  8FC20048   LW V0, 72(S8)
9D008960  8FC3001C   LW V1, 28(S8)
9D008964  00031A80   SLL V1, V1, 10
9D008968  AC430000   SW V1, 0(V0)
9D00896C  0B402281   J 0x9D008A04
9D008970  00000000   NOP
509:                                 } else { /* SDv1 or MMCv3 */
510:                                     n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
9D008974  93C20025   LBU V0, 37(S8)
9D008978  3042000F   ANDI V0, V0, 15
9D00897C  304300FF   ANDI V1, V0, 255
9D008980  93C2002A   LBU V0, 42(S8)
9D008984  000211C2   SRL V0, V0, 7
9D008988  304200FF   ANDI V0, V0, 255
9D00898C  00621021   ADDU V0, V1, V0
9D008990  304300FF   ANDI V1, V0, 255
9D008994  93C20029   LBU V0, 41(S8)
9D008998  30420003   ANDI V0, V0, 3
9D00899C  304200FF   ANDI V0, V0, 255
9D0089A0  00021040   SLL V0, V0, 1
9D0089A4  304200FF   ANDI V0, V0, 255
9D0089A8  00621021   ADDU V0, V1, V0
9D0089AC  304200FF   ANDI V0, V0, 255
9D0089B0  24420002   ADDIU V0, V0, 2
9D0089B4  A3C20014   SB V0, 20(S8)
511:                                     csize = (csd[8] >> 6) + ((WORD) csd[7] << 2) + ((WORD) (csd[6] & 3) << 10) + 1;
9D0089B8  93C20028   LBU V0, 40(S8)
9D0089BC  00021182   SRL V0, V0, 6
9D0089C0  304200FF   ANDI V0, V0, 255
9D0089C4  00401821   ADDU V1, V0, ZERO
9D0089C8  93C20027   LBU V0, 39(S8)
9D0089CC  00021080   SLL V0, V0, 2
9D0089D0  00621821   ADDU V1, V1, V0
9D0089D4  93C20026   LBU V0, 38(S8)
9D0089D8  30420003   ANDI V0, V0, 3
9D0089DC  00021280   SLL V0, V0, 10
9D0089E0  00621021   ADDU V0, V1, V0
9D0089E4  24420001   ADDIU V0, V0, 1
9D0089E8  AFC2001C   SW V0, 28(S8)
512:                                     *(DWORD*) buff = (DWORD) csize << (n - 9);
9D0089EC  8FC20048   LW V0, 72(S8)
9D0089F0  93C30014   LBU V1, 20(S8)
9D0089F4  2463FFF7   ADDIU V1, V1, -9
9D0089F8  8FC4001C   LW A0, 28(S8)
9D0089FC  00641804   SLLV V1, A0, V1
9D008A00  AC430000   SW V1, 0(V0)
513:                                 }
514:                                 res = RES_OK;
9D008A04  AFC00010   SW ZERO, 16(S8)
515:                             }
516:                             break;
9D008A08  0B402371   J 0x9D008DC4
9D008A0C  00000000   NOP
9D008D24  00000000   NOP
9D008D28  0B402371   J 0x9D008DC4
9D008D2C  00000000   NOP
9D008D30  00000000   NOP
9D008D34  0B402371   J 0x9D008DC4
9D008D38  00000000   NOP
517:                 
518:                         case GET_SECTOR_SIZE: /* Get sectors on the disk (WORD) */
519:                             *(WORD*) buff = 512;
9D008A10  8FC20048   LW V0, 72(S8)
9D008A14  24030200   ADDIU V1, ZERO, 512
9D008A18  A4430000   SH V1, 0(V0)
520:                             res = RES_OK;
9D008A1C  AFC00010   SW ZERO, 16(S8)
521:                             break;
9D008A20  0B402371   J 0x9D008DC4
9D008A24  00000000   NOP
522:                 
523:                         case GET_BLOCK_SIZE: /* Get erase block size in unit of sectors (DWORD) */
524:                             if (CardType & CT_SD2) { /* SDv2? */
9D008A28  8F828054   LW V0, -32684(GP)
9D008A2C  30420004   ANDI V0, V0, 4
9D008A30  10400028   BEQ V0, ZERO, 0x9D008AD4
9D008A34  00000000   NOP
525:                                 if (send_cmd(ACMD13, 0) == 0) { /* Read SD status */
9D008A38  2404008D   ADDIU A0, ZERO, 141
9D008A3C  00002821   ADDU A1, ZERO, ZERO
9D008A40  0F401FD8   JAL 0x9D007F60
9D008A44  00000000   NOP
9D008A48  144000BC   BNE V0, ZERO, 0x9D008D3C
9D008A4C  00000000   NOP
526:                                     rcvr_spi();
9D008A50  240400FF   ADDIU A0, ZERO, 255
9D008A54  0F401E99   JAL 0x9D007A64
9D008A58  00000000   NOP
527:                                     if (rcvr_datablock(csd, 16)) { /* Read partial block */
9D008A5C  27C20020   ADDIU V0, S8, 32
9D008A60  00402021   ADDU A0, V0, ZERO
9D008A64  24050010   ADDIU A1, ZERO, 16
9D008A68  0F401F24   JAL 0x9D007C90
9D008A6C  00000000   NOP
9D008A70  104000B5   BEQ V0, ZERO, 0x9D008D48
9D008A74  00000000   NOP
528:                                         for (n = 64 - 16; n; n--) rcvr_spi(); /* Purge trailing data */
9D008A78  24020030   ADDIU V0, ZERO, 48
9D008A7C  A3C20014   SB V0, 20(S8)
9D008A80  0B4022A8   J 0x9D008AA0
9D008A84  00000000   NOP
9D008A88  240400FF   ADDIU A0, ZERO, 255
9D008A8C  0F401E99   JAL 0x9D007A64
9D008A90  00000000   NOP
9D008A94  93C20014   LBU V0, 20(S8)
9D008A98  2442FFFF   ADDIU V0, V0, -1
9D008A9C  A3C20014   SB V0, 20(S8)
9D008AA0  93C20014   LBU V0, 20(S8)
9D008AA4  1440FFF8   BNE V0, ZERO, 0x9D008A88
9D008AA8  00000000   NOP
529:                                         *(DWORD*) buff = 16UL << (csd[10] >> 4);
9D008AAC  8FC20048   LW V0, 72(S8)
9D008AB0  93C3002A   LBU V1, 42(S8)
9D008AB4  00031902   SRL V1, V1, 4
9D008AB8  306300FF   ANDI V1, V1, 255
9D008ABC  24040010   ADDIU A0, ZERO, 16
9D008AC0  00641804   SLLV V1, A0, V1
9D008AC4  AC430000   SW V1, 0(V0)
530:                                         res = RES_OK;
9D008AC8  AFC00010   SW ZERO, 16(S8)
531:                                     }
532:                                 }
533:                             } else { /* SDv1 or MMCv3 */
534:                                 if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) { /* Read CSD */
9D008AD4  24040009   ADDIU A0, ZERO, 9
9D008AD8  00002821   ADDU A1, ZERO, ZERO
9D008ADC  0F401FD8   JAL 0x9D007F60
9D008AE0  00000000   NOP
9D008AE4  1440009B   BNE V0, ZERO, 0x9D008D54
9D008AE8  00000000   NOP
9D008AEC  27C20020   ADDIU V0, S8, 32
9D008AF0  00402021   ADDU A0, V0, ZERO
9D008AF4  24050010   ADDIU A1, ZERO, 16
9D008AF8  0F401F24   JAL 0x9D007C90
9D008AFC  00000000   NOP
9D008B00  10400097   BEQ V0, ZERO, 0x9D008D60
9D008B04  00000000   NOP
535:                                     if (CardType & CT_SD1) { /* SDv1 */
9D008B08  8F828054   LW V0, -32684(GP)
9D008B0C  30420002   ANDI V0, V0, 2
9D008B10  10400012   BEQ V0, ZERO, 0x9D008B5C
9D008B14  00000000   NOP
536:                                         *(DWORD*) buff = (((csd[10] & 63) << 1) + ((WORD) (csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
9D008B18  8FC20048   LW V0, 72(S8)
9D008B1C  93C3002A   LBU V1, 42(S8)
9D008B20  3063003F   ANDI V1, V1, 63
9D008B24  00032040   SLL A0, V1, 1
9D008B28  93C3002B   LBU V1, 43(S8)
9D008B2C  000319C2   SRL V1, V1, 7
9D008B30  306300FF   ANDI V1, V1, 255
9D008B34  00831821   ADDU V1, A0, V1
9D008B38  24640001   ADDIU A0, V1, 1
9D008B3C  93C3002D   LBU V1, 45(S8)
9D008B40  00031982   SRL V1, V1, 6
9D008B44  306300FF   ANDI V1, V1, 255
9D008B48  2463FFFF   ADDIU V1, V1, -1
9D008B4C  00641804   SLLV V1, A0, V1
9D008B50  AC430000   SW V1, 0(V0)
9D008B54  0B4022E7   J 0x9D008B9C
9D008B58  00000000   NOP
537:                                     } else { /* MMCv3 */
538:                                         *(DWORD*) buff = ((WORD) ((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
9D008B5C  8FC20048   LW V0, 72(S8)
9D008B60  93C3002A   LBU V1, 42(S8)
9D008B64  3063007C   ANDI V1, V1, 124
9D008B68  00031883   SRA V1, V1, 2
9D008B6C  3063FFFF   ANDI V1, V1, -1
9D008B70  24650001   ADDIU A1, V1, 1
9D008B74  93C3002B   LBU V1, 43(S8)
9D008B78  30630003   ANDI V1, V1, 3
9D008B7C  000320C0   SLL A0, V1, 3
9D008B80  93C3002B   LBU V1, 43(S8)
9D008B84  00031942   SRL V1, V1, 5
9D008B88  306300FF   ANDI V1, V1, 255
9D008B8C  00831821   ADDU V1, A0, V1
9D008B90  24630001   ADDIU V1, V1, 1
9D008B94  70A31802   MUL V1, A1, V1
9D008B98  AC430000   SW V1, 0(V0)
539:                                     }
540:                                     res = RES_OK;
9D008B9C  AFC00010   SW ZERO, 16(S8)
541:                                 }
542:                             }
543:                             break;
9D008ACC  0B402371   J 0x9D008DC4
9D008AD0  00000000   NOP
9D008BA0  0B402371   J 0x9D008DC4
9D008BA4  00000000   NOP
9D008D3C  00000000   NOP
9D008D40  0B402371   J 0x9D008DC4
9D008D44  00000000   NOP
9D008D48  00000000   NOP
9D008D4C  0B402371   J 0x9D008DC4
9D008D50  00000000   NOP
9D008D54  00000000   NOP
9D008D58  0B402371   J 0x9D008DC4
9D008D5C  00000000   NOP
9D008D60  00000000   NOP
9D008D64  0B402371   J 0x9D008DC4
9D008D68  00000000   NOP
544:                 
545:                         case MMC_GET_TYPE: /* Get card type flags (1 byte) */
546:                             *ptr = CardType;
9D008BA8  8F828054   LW V0, -32684(GP)
9D008BAC  304300FF   ANDI V1, V0, 255
9D008BB0  8FC20018   LW V0, 24(S8)
9D008BB4  A0430000   SB V1, 0(V0)
547:                             res = RES_OK;
9D008BB8  AFC00010   SW ZERO, 16(S8)
548:                             break;
9D008BBC  0B402371   J 0x9D008DC4
9D008BC0  00000000   NOP
549:                 
550:                         case MMC_GET_CSD: /* Receive CSD as a data block (16 bytes) */
551:                             if ((send_cmd(CMD9, 0) == 0) /* READ_CSD */
9D008BC4  24040009   ADDIU A0, ZERO, 9
9D008BC8  00002821   ADDU A1, ZERO, ZERO
9D008BCC  0F401FD8   JAL 0x9D007F60
9D008BD0  00000000   NOP
9D008BD4  14400065   BNE V0, ZERO, 0x9D008D6C
9D008BD8  00000000   NOP
552:                                     && rcvr_datablock(buff, 16))
9D008BDC  8FC20048   LW V0, 72(S8)
9D008BE0  00402021   ADDU A0, V0, ZERO
9D008BE4  24050010   ADDIU A1, ZERO, 16
9D008BE8  0F401F24   JAL 0x9D007C90
9D008BEC  00000000   NOP
9D008BF0  10400061   BEQ V0, ZERO, 0x9D008D78
9D008BF4  00000000   NOP
553:                                 res = RES_OK;
9D008BF8  AFC00010   SW ZERO, 16(S8)
554:                             break;
9D008BFC  0B402371   J 0x9D008DC4
9D008C00  00000000   NOP
9D008D6C  00000000   NOP
9D008D70  0B402371   J 0x9D008DC4
9D008D74  00000000   NOP
9D008D78  00000000   NOP
9D008D7C  0B402371   J 0x9D008DC4
9D008D80  00000000   NOP
555:                 
556:                         case MMC_GET_CID: /* Receive CID as a data block (16 bytes) */
557:                             if ((send_cmd(CMD10, 0) == 0) /* READ_CID */
9D008C04  2404000A   ADDIU A0, ZERO, 10
9D008C08  00002821   ADDU A1, ZERO, ZERO
9D008C0C  0F401FD8   JAL 0x9D007F60
9D008C10  00000000   NOP
9D008C14  1440005B   BNE V0, ZERO, 0x9D008D84
9D008C18  00000000   NOP
558:                                     && rcvr_datablock(buff, 16))
9D008C1C  8FC20048   LW V0, 72(S8)
9D008C20  00402021   ADDU A0, V0, ZERO
9D008C24  24050010   ADDIU A1, ZERO, 16
9D008C28  0F401F24   JAL 0x9D007C90
9D008C2C  00000000   NOP
9D008C30  10400057   BEQ V0, ZERO, 0x9D008D90
9D008C34  00000000   NOP
559:                                 res = RES_OK;
9D008C38  AFC00010   SW ZERO, 16(S8)
560:                             break;
9D008C3C  0B402371   J 0x9D008DC4
9D008C40  00000000   NOP
9D008D84  00000000   NOP
9D008D88  0B402371   J 0x9D008DC4
9D008D8C  00000000   NOP
9D008D90  00000000   NOP
9D008D94  0B402371   J 0x9D008DC4
9D008D98  00000000   NOP
561:                 
562:                         case MMC_GET_OCR: /* Receive OCR as an R3 resp (4 bytes) */
563:                             if (send_cmd(CMD58, 0) == 0) { /* READ_OCR */
9D008C44  2404003A   ADDIU A0, ZERO, 58
9D008C48  00002821   ADDU A1, ZERO, ZERO
9D008C4C  0F401FD8   JAL 0x9D007F60
9D008C50  00000000   NOP
9D008C54  14400051   BNE V0, ZERO, 0x9D008D9C
9D008C58  00000000   NOP
564:                                 for (n = 0; n < 4; n++)
9D008C5C  A3C00014   SB ZERO, 20(S8)
9D008C60  0B402324   J 0x9D008C90
9D008C64  00000000   NOP
9D008C84  93C20014   LBU V0, 20(S8)
9D008C88  24420001   ADDIU V0, V0, 1
9D008C8C  A3C20014   SB V0, 20(S8)
9D008C90  93C20014   LBU V0, 20(S8)
9D008C94  2C420004   SLTIU V0, V0, 4
9D008C98  1440FFF3   BNE V0, ZERO, 0x9D008C68
9D008C9C  00000000   NOP
565:                                     *((BYTE*) buff + n) = rcvr_spi();
9D008C68  8FC30048   LW V1, 72(S8)
9D008C6C  93C20014   LBU V0, 20(S8)
9D008C70  00628021   ADDU S0, V1, V0
9D008C74  240400FF   ADDIU A0, ZERO, 255
9D008C78  0F401E99   JAL 0x9D007A64
9D008C7C  00000000   NOP
9D008C80  A2020000   SB V0, 0(S0)
566:                                 res = RES_OK;
9D008CA0  AFC00010   SW ZERO, 16(S8)
567:                             }
568:                             break;
9D008CA4  0B402371   J 0x9D008DC4
9D008CA8  00000000   NOP
9D008D9C  00000000   NOP
9D008DA0  0B402371   J 0x9D008DC4
9D008DA4  00000000   NOP
569:                 
570:                         case MMC_GET_SDSTAT: /* Receive SD statsu as a data block (64 bytes) */
571:                             if ((CardType & CT_SD2) && send_cmd(ACMD13, 0) == 0) { /* SD_STATUS */
9D008CAC  8F828054   LW V0, -32684(GP)
9D008CB0  30420004   ANDI V0, V0, 4
9D008CB4  1040003C   BEQ V0, ZERO, 0x9D008DA8
9D008CB8  00000000   NOP
9D008CBC  2404008D   ADDIU A0, ZERO, 141
9D008CC0  00002821   ADDU A1, ZERO, ZERO
9D008CC4  0F401FD8   JAL 0x9D007F60
9D008CC8  00000000   NOP
9D008CCC  14400039   BNE V0, ZERO, 0x9D008DB4
9D008CD0  00000000   NOP
572:                                 rcvr_spi();
9D008CD4  240400FF   ADDIU A0, ZERO, 255
9D008CD8  0F401E99   JAL 0x9D007A64
9D008CDC  00000000   NOP
573:                                 if (rcvr_datablock(buff, 64))
9D008CE0  8FC20048   LW V0, 72(S8)
9D008CE4  00402021   ADDU A0, V0, ZERO
9D008CE8  24050040   ADDIU A1, ZERO, 64
9D008CEC  0F401F24   JAL 0x9D007C90
9D008CF0  00000000   NOP
9D008CF4  10400032   BEQ V0, ZERO, 0x9D008DC0
9D008CF8  00000000   NOP
574:                                     res = RES_OK;
9D008CFC  AFC00010   SW ZERO, 16(S8)
575:                             }
576:                             break;
9D008D00  0B402371   J 0x9D008DC4
9D008D04  00000000   NOP
9D008DA8  00000000   NOP
9D008DAC  0B402371   J 0x9D008DC4
9D008DB0  00000000   NOP
9D008DB4  00000000   NOP
9D008DB8  0B402371   J 0x9D008DC4
9D008DBC  00000000   NOP
9D008DC0  00000000   NOP
577:                 
578:                         default:
579:                             res = RES_PARERR;
9D008D08  24020004   ADDIU V0, ZERO, 4
9D008D0C  AFC20010   SW V0, 16(S8)
9D008D10  0B402371   J 0x9D008DC4
9D008D14  00000000   NOP
580:                     }
581:                 
582:                     deselect();
9D008DC4  0F401EC9   JAL 0x9D007B24
9D008DC8  00000000   NOP
583:                 
584:                     return res;
9D008DCC  8FC20010   LW V0, 16(S8)
585:                 }
9D008DD0  03C0E821   ADDU SP, S8, ZERO
9D008DD4  8FBF003C   LW RA, 60(SP)
9D008DD8  8FBE0038   LW S8, 56(SP)
9D008DDC  8FB00034   LW S0, 52(SP)
9D008DE0  27BD0040   ADDIU SP, SP, 64
9D008DE4  03E00008   JR RA
9D008DE8  00000000   NOP
586:                 
587:                 
588:                 
589:                 /*-----------------------------------------------------------------------*/
590:                 /* Device Timer Interrupt Procedure                                      */
591:                 /*-----------------------------------------------------------------------*/
592:                 
593:                 /* This function must be called by timer interrupt in period of 1ms      */
594:                 
595:                 void disk_timerproc(void) {
9D008DEC  27BDFFF0   ADDIU SP, SP, -16
9D008DF0  AFBE000C   SW S8, 12(SP)
9D008DF4  03A0F021   ADDU S8, SP, ZERO
596:                     BYTE s;
597:                     UINT n;
598:                 
599:                 
600:                     n = Timer1; /* 1000Hz decrement timer with zero stopped */
9D008DF8  8F82804C   LW V0, -32692(GP)
9D008DFC  AFC20000   SW V0, 0(S8)
601:                     if (n) Timer1 = --n;
9D008E00  8FC20000   LW V0, 0(S8)
9D008E04  10400006   BEQ V0, ZERO, 0x9D008E20
9D008E08  00000000   NOP
9D008E0C  8FC20000   LW V0, 0(S8)
9D008E10  2442FFFF   ADDIU V0, V0, -1
9D008E14  AFC20000   SW V0, 0(S8)
9D008E18  8FC20000   LW V0, 0(S8)
9D008E1C  AF82804C   SW V0, -32692(GP)
602:                     n = Timer2;
9D008E20  8F828050   LW V0, -32688(GP)
9D008E24  AFC20000   SW V0, 0(S8)
603:                     if (n) Timer2 = --n;
9D008E28  8FC20000   LW V0, 0(S8)
9D008E2C  10400006   BEQ V0, ZERO, 0x9D008E48
9D008E30  00000000   NOP
9D008E34  8FC20000   LW V0, 0(S8)
9D008E38  2442FFFF   ADDIU V0, V0, -1
9D008E3C  AFC20000   SW V0, 0(S8)
9D008E40  8FC20000   LW V0, 0(S8)
9D008E44  AF828050   SW V0, -32688(GP)
604:                 
605:                 
606:                     /* Update socket status */
607:                 
608:                     s = Stat;
9D008E48  93828020   LBU V0, -32736(GP)
9D008E4C  A3C20004   SB V0, 4(S8)
609:                 
610:                     if (SOCKWP) s |= STA_PROTECT;
611:                     else s &= ~STA_PROTECT;
9D008E50  93C30004   LBU V1, 4(S8)
9D008E54  2402FFFB   ADDIU V0, ZERO, -5
9D008E58  00621024   AND V0, V1, V0
9D008E5C  A3C20004   SB V0, 4(S8)
612:                 
613:                     if (SOCKINS) s &= ~STA_NODISK;
9D008E60  93C30004   LBU V1, 4(S8)
9D008E64  2402FFFD   ADDIU V0, ZERO, -3
9D008E68  00621024   AND V0, V1, V0
9D008E6C  A3C20004   SB V0, 4(S8)
614:                     else s |= (STA_NODISK | STA_NOINIT);
615:                 
616:                     Stat = s;
9D008E70  93C20004   LBU V0, 4(S8)
9D008E74  A3828020   SB V0, -32736(GP)
617:                 }
9D008E78  03C0E821   ADDU SP, S8, ZERO
9D008E7C  8FBE000C   LW S8, 12(SP)
9D008E80  27BD0010   ADDIU SP, SP, 16
9D008E84  03E00008   JR RA
9D008E88  00000000   NOP
618:                 
---  /Users/mikechi/Dropbox/Cognionics/Projects/EEG 64/Firmware/PIC32 DAQ/EEG64-PIC32.X/fatfs/ff.c  -----
1:                   /*----------------------------------------------------------------------------/
2:                   /  FatFs - FAT file system module  R0.09                  (C)ChaN, 2011
3:                   /-----------------------------------------------------------------------------/
4:                   / FatFs module is a generic FAT file system module for small embedded systems.
5:                   / This is a free software that opened for education, research and commercial
6:                   / developments under license policy of following terms.
7:                   /
8:                   /  Copyright (C) 2011, ChaN, all right reserved.
9:                   /
10:                  / * The FatFs module is a free software and there is NO WARRANTY.
11:                  / * No restriction on use. You can use, modify and redistribute it for
12:                  /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
13:                  / * Redistributions of source code must retain the above copyright notice.
14:                  /
15:                  /-----------------------------------------------------------------------------/
16:                  / Feb 26,'06 R0.00  Prototype.
17:                  /
18:                  / Apr 29,'06 R0.01  First stable version.
19:                  /
20:                  / Jun 01,'06 R0.02  Added FAT12 support.
21:                  /                   Removed unbuffered mode.
22:                  /                   Fixed a problem on small (<32M) partition.
23:                  / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
24:                  /
25:                  / Sep 22,'06 R0.03  Added f_rename().
26:                  /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
27:                  / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
28:                  /                   Fixed f_mkdir() creates incorrect directory on FAT32.
29:                  /
30:                  / Feb 04,'07 R0.04  Supported multiple drive system.
31:                  /                   Changed some interfaces for multiple drive system.
32:                  /                   Changed f_mountdrv() to f_mount().
33:                  /                   Added f_mkfs().
34:                  / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
35:                  /                   Added a capability of extending file size to f_lseek().
36:                  /                   Added minimization level 3.
37:                  /                   Fixed an endian sensitive code in f_mkfs().
38:                  / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
39:                  /                   Added FSInfo support.
40:                  /                   Fixed DBCS name can result FR_INVALID_NAME.
41:                  /                   Fixed short seek (<= csize) collapses the file object.
42:                  /
43:                  / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
44:                  /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
45:                  /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
46:                  / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
47:                  /                   Fixed off by one error at FAT sub-type determination.
48:                  /                   Fixed btr in f_read() can be mistruncated.
49:                  /                   Fixed cached sector is not flushed when create and close without write.
50:                  /
51:                  / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
52:                  /                   Improved performance of f_lseek() on moving to the same or following cluster.
53:                  /
54:                  / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
55:                  /                   Added long file name feature.
56:                  /                   Added multiple code page feature.
57:                  /                   Added re-entrancy for multitask operation.
58:                  /                   Added auto cluster size selection to f_mkfs().
59:                  /                   Added rewind option to f_readdir().
60:                  /                   Changed result code of critical errors.
61:                  /                   Renamed string functions to avoid name collision.
62:                  / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
63:                  /                   Added multiple sector size feature.
64:                  / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
65:                  /                   Fixed wrong cache control in f_lseek().
66:                  /                   Added relative path feature.
67:                  /                   Added f_chdir() and f_chdrive().
68:                  /                   Added proper case conversion to extended char.
69:                  / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
70:                  /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
71:                  /                   Fixed name matching error on the 13 char boundary.
72:                  /                   Added a configuration option, _LFN_UNICODE.
73:                  /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
74:                  /
75:                  / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
76:                  /                   Added file lock feature. (_FS_SHARE)
77:                  /                   Added fast seek feature. (_USE_FASTSEEK)
78:                  /                   Changed some types on the API, XCHAR->TCHAR.
79:                  /                   Changed fname member in the FILINFO structure on Unicode cfg.
80:                  /                   String functions support UTF-8 encoding files on Unicode cfg.
81:                  / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
82:                  /                   Added sector erase feature. (_USE_ERASE)
83:                  /                   Moved file lock semaphore table from fs object to the bss.
84:                  /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
85:                  /                   Fixed f_mkfs() creates wrong FAT32 volume.
86:                  / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
87:                  /                   f_lseek() reports required table size on creating CLMP.
88:                  /                   Extended format syntax of f_printf function.
89:                  /                   Ignores duplicated directory separators in given path names.
90:                  /
91:                  / Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
92:                  /                   Added f_fdisk(). (_MULTI_PARTITION = 2)
93:                  /---------------------------------------------------------------------------*/
94:                  
95:                  #include "ff.h"			/* FatFs configurations and declarations */
96:                  #include "diskio.h"		/* Declarations of low level disk I/O functions */
97:                  
98:                  
99:                  /*--------------------------------------------------------------------------
100:                 
101:                    Module Private Definitions
102:                 
103:                 ---------------------------------------------------------------------------*/
104:                 
105:                 #if _FATFS != 6502	/* Revision ID */
106:                 #error Wrong include file (ff.h).
107:                 #endif
108:                 
109:                 
110:                 /* Definitions on sector size */
111:                 #if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
112:                 #error Wrong sector size.
113:                 #endif
114:                 #if _MAX_SS != 512
115:                 #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
116:                 #else
117:                 #define	SS(fs)	512U			/* Fixed sector size */
118:                 #endif
119:                 
120:                 
121:                 /* Reentrancy related */
122:                 #if _FS_REENTRANT
123:                 #if _USE_LFN == 1
124:                 #error Static LFN work area must not be used in re-entrant configuration.
125:                 #endif
126:                 #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
127:                 #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
128:                 #else
129:                 #define	ENTER_FF(fs)
130:                 #define LEAVE_FF(fs, res)	return res
131:                 #endif
132:                 
133:                 #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
134:                 
135:                 
136:                 /* File shareing feature */
137:                 #if _FS_SHARE
138:                 #if _FS_READONLY
139:                 #error _FS_SHARE must be 0 on read-only cfg.
140:                 #endif
141:                 
142:                 typedef struct {
143:                     FATFS *fs; /* File ID 1, volume (NULL:blank entry) */
144:                     DWORD clu; /* File ID 2, directory */
145:                     WORD idx; /* File ID 3, directory index */
146:                     WORD ctr; /* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
147:                 } FILESEM;
148:                 #endif
149:                 
150:                 
151:                 /* Misc definitions */
152:                 #define LD_CLUST(dir)	(((DWORD)LD_WORD(dir+DIR_FstClusHI)<<16) | LD_WORD(dir+DIR_FstClusLO))
153:                 #define ST_CLUST(dir,cl) {ST_WORD(dir+DIR_FstClusLO, cl); ST_WORD(dir+DIR_FstClusHI, (DWORD)cl>>16);}
154:                 
155:                 
156:                 /* DBCS code ranges and SBCS extend char conversion table */
157:                 
158:                 #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
159:                 #define _DF1S	0x81	/* DBC 1st byte range 1 start */
160:                 #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
161:                 #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
162:                 #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
163:                 #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
164:                 #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
165:                 #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
166:                 #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
167:                 
168:                 #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
169:                 #define _DF1S	0x81
170:                 #define _DF1E	0xFE
171:                 #define _DS1S	0x40
172:                 #define _DS1E	0x7E
173:                 #define _DS2S	0x80
174:                 #define _DS2E	0xFE
175:                 
176:                 #elif _CODE_PAGE == 949	/* Korean */
177:                 #define _DF1S	0x81
178:                 #define _DF1E	0xFE
179:                 #define _DS1S	0x41
180:                 #define _DS1E	0x5A
181:                 #define _DS2S	0x61
182:                 #define _DS2E	0x7A
183:                 #define _DS3S	0x81
184:                 #define _DS3E	0xFE
185:                 
186:                 #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
187:                 #define _DF1S	0x81
188:                 #define _DF1E	0xFE
189:                 #define _DS1S	0x40
190:                 #define _DS1E	0x7E
191:                 #define _DS2S	0xA1
192:                 #define _DS2E	0xFE
193:                 
194:                 #elif _CODE_PAGE == 437	/* U.S. (OEM) */
195:                 #define _DF1S	0
196:                 #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
197:                 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
198:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
199:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
200:                 
201:                 #elif _CODE_PAGE == 720	/* Arabic (OEM) */
202:                 #define _DF1S	0
203:                 #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
204:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
205:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
206:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
207:                 
208:                 #elif _CODE_PAGE == 737	/* Greek (OEM) */
209:                 #define _DF1S	0
210:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
211:                 				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
212:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
213:                 				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
214:                 
215:                 #elif _CODE_PAGE == 775	/* Baltic (OEM) */
216:                 #define _DF1S	0
217:                 #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
218:                 				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
219:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
220:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
221:                 
222:                 #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
223:                 #define _DF1S	0
224:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
225:                 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
226:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
227:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
228:                 
229:                 #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
230:                 #define _DF1S	0
231:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
232:                 				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
233:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
234:                 				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
235:                 
236:                 #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
237:                 #define _DF1S	0
238:                 #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
239:                 				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
240:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
241:                 				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
242:                 
243:                 #elif _CODE_PAGE == 857	/* Turkish (OEM) */
244:                 #define _DF1S	0
245:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
246:                 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
247:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
248:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
249:                 
250:                 #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
251:                 #define _DF1S	0
252:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
253:                 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
254:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
255:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
256:                 
257:                 #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
258:                 #define _DF1S	0
259:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
260:                 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
261:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
262:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
263:                 
264:                 #elif _CODE_PAGE == 866	/* Russian (OEM) */
265:                 #define _DF1S	0
266:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
267:                 				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
268:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
269:                 				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
270:                 
271:                 #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
272:                 #define _DF1S	0
273:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
274:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
275:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
276:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
277:                 
278:                 #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
279:                 #define _DF1S	0
280:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
281:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
282:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
283:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
284:                 
285:                 #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
286:                 #define _DF1S	0
287:                 #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
288:                 				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
289:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
290:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
291:                 
292:                 #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
293:                 #define _DF1S	0
294:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
295:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
296:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
297:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
298:                 
299:                 #elif _CODE_PAGE == 1253 /* Greek (Windows) */
300:                 #define _DF1S	0
301:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
302:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
303:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
304:                 				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
305:                 
306:                 #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
307:                 #define _DF1S	0
308:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
309:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
310:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
311:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
312:                 
313:                 #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
314:                 #define _DF1S	0
315:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
316:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
317:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
318:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
319:                 
320:                 #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
321:                 #define _DF1S	0
322:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
323:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
324:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
325:                 				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
326:                 
327:                 #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
328:                 #define _DF1S	0
329:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
330:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
331:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
332:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
333:                 
334:                 #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
335:                 #define _DF1S	0
336:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
337:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
338:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
339:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
340:                 
341:                 #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
342:                 #if _USE_LFN
343:                 #error Cannot use LFN feature without valid code page.
344:                 #endif
345:                 #define _DF1S	0
346:                 
347:                 #else
348:                 #error Unknown code page
349:                 
350:                 #endif
351:                 
352:                 
353:                 /* Character code support macros */
354:                 #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
355:                 #define IsLower(c)	(((c)>='a')&&((c)<='z'))
356:                 #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
357:                 
358:                 #if _DF1S		/* Code page is DBCS */
359:                 
360:                 #ifdef _DF2S	/* Two 1st byte areas */
361:                 #define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
362:                 #else			/* One 1st byte area */
363:                 #define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
364:                 #endif
365:                 
366:                 #ifdef _DS3S	/* Three 2nd byte areas */
367:                 #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
368:                 #else			/* Two 2nd byte areas */
369:                 #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
370:                 #endif
371:                 
372:                 #else			/* Code page is SBCS */
373:                 
374:                 #define IsDBCS1(c)	0
375:                 #define IsDBCS2(c)	0
376:                 
377:                 #endif /* _DF1S */
378:                 
379:                 
380:                 /* Name status flags */
381:                 #define NS			11		/* Index of name status byte in fn[] */
382:                 #define NS_LOSS		0x01	/* Out of 8.3 format */
383:                 #define NS_LFN		0x02	/* Force to create LFN entry */
384:                 #define NS_LAST		0x04	/* Last segment */
385:                 #define NS_BODY		0x08	/* Lower case flag (body) */
386:                 #define NS_EXT		0x10	/* Lower case flag (ext) */
387:                 #define NS_DOT		0x20	/* Dot entry */
388:                 
389:                 
390:                 /* FAT sub-type boundaries */
391:                 /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
392:                 #define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
393:                 #define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
394:                 
395:                 
396:                 /* FatFs refers the members in the FAT structures as byte array instead of
397:                 / structure member because the structure is not binary compatible between
398:                 / different platforms */
399:                 
400:                 #define BS_jmpBoot			0	/* Jump instruction (3) */
401:                 #define BS_OEMName			3	/* OEM name (8) */
402:                 #define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
403:                 #define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
404:                 #define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
405:                 #define BPB_NumFATs			16	/* Number of FAT copies (1) */
406:                 #define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
407:                 #define BPB_TotSec16		19	/* Volume size [sector] (2) */
408:                 #define BPB_Media			21	/* Media descriptor (1) */
409:                 #define BPB_FATSz16			22	/* FAT size [sector] (2) */
410:                 #define BPB_SecPerTrk		24	/* Track size [sector] (2) */
411:                 #define BPB_NumHeads		26	/* Number of heads (2) */
412:                 #define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
413:                 #define BPB_TotSec32		32	/* Volume size [sector] (4) */
414:                 #define BS_DrvNum			36	/* Physical drive number (2) */
415:                 #define BS_BootSig			38	/* Extended boot signature (1) */
416:                 #define BS_VolID			39	/* Volume serial number (4) */
417:                 #define BS_VolLab			43	/* Volume label (8) */
418:                 #define BS_FilSysType		54	/* File system type (1) */
419:                 #define BPB_FATSz32			36	/* FAT size [sector] (4) */
420:                 #define BPB_ExtFlags		40	/* Extended flags (2) */
421:                 #define BPB_FSVer			42	/* File system version (2) */
422:                 #define BPB_RootClus		44	/* Root dir first cluster (4) */
423:                 #define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
424:                 #define BPB_BkBootSec		50	/* Offset of backup boot sectot (2) */
425:                 #define BS_DrvNum32			64	/* Physical drive number (2) */
426:                 #define BS_BootSig32		66	/* Extended boot signature (1) */
427:                 #define BS_VolID32			67	/* Volume serial number (4) */
428:                 #define BS_VolLab32			71	/* Volume label (8) */
429:                 #define BS_FilSysType32		82	/* File system type (1) */
430:                 #define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
431:                 #define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
432:                 #define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
433:                 #define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
434:                 #define MBR_Table			446	/* MBR: Partition table offset (2) */
435:                 #define	SZ_PTE				16	/* MBR: Size of a partition table entry */
436:                 #define BS_55AA				510	/* Boot sector signature (2) */
437:                 
438:                 #define	DIR_Name			0	/* Short file name (11) */
439:                 #define	DIR_Attr			11	/* Attribute (1) */
440:                 #define	DIR_NTres			12	/* NT flag (1) */
441:                 #define	DIR_CrtTime			14	/* Created time (2) */
442:                 #define	DIR_CrtDate			16	/* Created date (2) */
443:                 #define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
444:                 #define	DIR_WrtTime			22	/* Modified time (2) */
445:                 #define	DIR_WrtDate			24	/* Modified date (2) */
446:                 #define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
447:                 #define	DIR_FileSize		28	/* File size (4) */
448:                 #define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
449:                 #define	LDIR_Attr			11	/* LFN attribute (1) */
450:                 #define	LDIR_Type			12	/* LFN type (1) */
451:                 #define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
452:                 #define	LDIR_FstClusLO		26	/* Filled by zero (0) */
453:                 #define	SZ_DIR				32		/* Size of a directory entry */
454:                 #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
455:                 #define	DDE					0xE5	/* Deleted directory enrty mark in DIR_Name[0] */
456:                 #define	NDDE				0x05	/* Replacement of a character collides with DDE */
457:                 
458:                 
459:                 /*------------------------------------------------------------*/
460:                 /* Module private work area                                   */
461:                 /*------------------------------------------------------------*/
462:                 /* Note that uninitialized variables with static duration are
463:                 /  zeroed/nulled at start-up. If not, the compiler or start-up
464:                 /  routine is out of ANSI-C standard.
465:                  */
466:                 
467:                 #if _VOLUMES
468:                 static
469:                 FATFS *FatFs[_VOLUMES]; /* Pointer to the file system objects (logical drives) */
470:                 #else
471:                 #error Number of volumes must not be 0.
472:                 #endif
473:                 
474:                 static
475:                 WORD Fsid; /* File system mount ID */
476:                 
477:                 #if _FS_RPATH
478:                 static
479:                 BYTE CurrVol; /* Current drive */
480:                 #endif
481:                 
482:                 #if _FS_SHARE
483:                 static
484:                 FILESEM Files[_FS_SHARE]; /* File lock semaphores */
485:                 #endif
486:                 
487:                 #if _USE_LFN == 0			/* No LFN feature */
488:                 #define	DEF_NAMEBUF			BYTE sfn[12]
489:                 #define INIT_BUF(dobj)		(dobj).fn = sfn
490:                 #define	FREE_BUF()
491:                 
492:                 #elif _USE_LFN == 1			/* LFN feature with static working buffer */
493:                 static WCHAR LfnBuf[_MAX_LFN + 1];
494:                 #define	DEF_NAMEBUF			BYTE sfn[12]
495:                 #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
496:                 #define	FREE_BUF()
497:                 
498:                 #elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
499:                 #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
500:                 #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
501:                 #define	FREE_BUF()
502:                 
503:                 #elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
504:                 #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR *lfn
505:                 #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
506:                 							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
507:                 							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
508:                 #define	FREE_BUF()			ff_memfree(lfn)
509:                 
510:                 #else
511:                 #error Wrong LFN configuration.
512:                 #endif
513:                 
514:                 
515:                 
516:                 
517:                 /*--------------------------------------------------------------------------
518:                 
519:                    Module Private Functions
520:                 
521:                 ---------------------------------------------------------------------------*/
522:                 
523:                 
524:                 /*-----------------------------------------------------------------------*/
525:                 /* String functions                                                      */
526:                 /*-----------------------------------------------------------------------*/
527:                 
528:                 /* Copy memory to memory */
529:                 static
530:                 void mem_cpy(void* dst, const void* src, UINT cnt) {
9D000020  27BDFFF0   ADDIU SP, SP, -16
9D000024  AFBE000C   SW S8, 12(SP)
9D000028  03A0F021   ADDU S8, SP, ZERO
9D00002C  AFC40010   SW A0, 16(S8)
9D000030  AFC50014   SW A1, 20(S8)
9D000034  AFC60018   SW A2, 24(S8)
531:                     BYTE *d = (BYTE*) dst;
9D000038  8FC20010   LW V0, 16(S8)
9D00003C  AFC20000   SW V0, 0(S8)
532:                     const BYTE *s = (const BYTE*) src;
9D000040  8FC20014   LW V0, 20(S8)
9D000044  AFC20004   SW V0, 4(S8)
533:                 
534:                 #if _WORD_ACCESS == 1
535:                     while (cnt >= sizeof (int)) {
536:                         *(int*) d = *(int*) s;
537:                         d += sizeof (int);
538:                         s += sizeof (int);
539:                         cnt -= sizeof (int);
540:                     }
541:                 #endif
542:                     while (cnt--)
9D000048  0B40001E   J 0x9D000078
9D00004C  00000000   NOP
9D000078  8FC20018   LW V0, 24(S8)
9D00007C  0002102B   SLTU V0, ZERO, V0
9D000080  304200FF   ANDI V0, V0, 255
9D000084  8FC30018   LW V1, 24(S8)
9D000088  2463FFFF   ADDIU V1, V1, -1
9D00008C  AFC30018   SW V1, 24(S8)
9D000090  1440FFEF   BNE V0, ZERO, 0x9D000050
9D000094  00000000   NOP
543:                         *d++ = *s++;
9D000050  8FC20004   LW V0, 4(S8)
9D000054  90430000   LBU V1, 0(V0)
9D000058  8FC20000   LW V0, 0(S8)
9D00005C  A0430000   SB V1, 0(V0)
9D000060  8FC20000   LW V0, 0(S8)
9D000064  24420001   ADDIU V0, V0, 1
9D000068  AFC20000   SW V0, 0(S8)
9D00006C  8FC20004   LW V0, 4(S8)
9D000070  24420001   ADDIU V0, V0, 1
9D000074  AFC20004   SW V0, 4(S8)
544:                 }
9D000098  03C0E821   ADDU SP, S8, ZERO
9D00009C  8FBE000C   LW S8, 12(SP)
9D0000A0  27BD0010   ADDIU SP, SP, 16
9D0000A4  03E00008   JR RA
9D0000A8  00000000   NOP
545:                 
546:                 /* Fill memory */
547:                 static
548:                 void mem_set(void* dst, int val, UINT cnt) {
9D0000AC  27BDFFF0   ADDIU SP, SP, -16
9D0000B0  AFBE000C   SW S8, 12(SP)
9D0000B4  03A0F021   ADDU S8, SP, ZERO
9D0000B8  AFC40010   SW A0, 16(S8)
9D0000BC  AFC50014   SW A1, 20(S8)
9D0000C0  AFC60018   SW A2, 24(S8)
549:                     BYTE *d = (BYTE*) dst;
9D0000C4  8FC20010   LW V0, 16(S8)
9D0000C8  AFC20000   SW V0, 0(S8)
550:                 
551:                     while (cnt--)
9D0000CC  0B40003C   J 0x9D0000F0
9D0000D0  00000000   NOP
9D0000F0  8FC20018   LW V0, 24(S8)
9D0000F4  0002102B   SLTU V0, ZERO, V0
9D0000F8  304200FF   ANDI V0, V0, 255
9D0000FC  8FC30018   LW V1, 24(S8)
9D000100  2463FFFF   ADDIU V1, V1, -1
9D000104  AFC30018   SW V1, 24(S8)
9D000108  1440FFF2   BNE V0, ZERO, 0x9D0000D4
9D00010C  00000000   NOP
552:                         *d++ = (BYTE) val;
9D0000D4  8FC20014   LW V0, 20(S8)
9D0000D8  304300FF   ANDI V1, V0, 255
9D0000DC  8FC20000   LW V0, 0(S8)
9D0000E0  A0430000   SB V1, 0(V0)
9D0000E4  8FC20000   LW V0, 0(S8)
9D0000E8  24420001   ADDIU V0, V0, 1
9D0000EC  AFC20000   SW V0, 0(S8)
553:                 }
9D000110  03C0E821   ADDU SP, S8, ZERO
9D000114  8FBE000C   LW S8, 12(SP)
9D000118  27BD0010   ADDIU SP, SP, 16
9D00011C  03E00008   JR RA
9D000120  00000000   NOP
554:                 
555:                 /* Compare memory to memory */
556:                 static
557:                 int mem_cmp(const void* dst, const void* src, UINT cnt) {
9D000124  27BDFFE8   ADDIU SP, SP, -24
9D000128  AFBE0014   SW S8, 20(SP)
9D00012C  03A0F021   ADDU S8, SP, ZERO
9D000130  AFC40018   SW A0, 24(S8)
9D000134  AFC5001C   SW A1, 28(S8)
9D000138  AFC60020   SW A2, 32(S8)
558:                     const BYTE *d = (const BYTE *) dst, *s = (const BYTE *) src;
9D00013C  8FC20018   LW V0, 24(S8)
9D000140  AFC20000   SW V0, 0(S8)
9D000144  8FC2001C   LW V0, 28(S8)
9D000148  AFC20004   SW V0, 4(S8)
559:                     int r = 0;
9D00014C  AFC00008   SW ZERO, 8(S8)
560:                 
561:                     while (cnt-- && (r = *d++ - *s++) == 0);
9D000150  00000000   NOP
9D000154  8FC20020   LW V0, 32(S8)
9D000158  0002102B   SLTU V0, ZERO, V0
9D00015C  304200FF   ANDI V0, V0, 255
9D000160  8FC30020   LW V1, 32(S8)
9D000164  2463FFFF   ADDIU V1, V1, -1
9D000168  AFC30020   SW V1, 32(S8)
9D00016C  10400013   BEQ V0, ZERO, 0x9D0001BC
9D000170  00000000   NOP
9D000174  8FC20000   LW V0, 0(S8)
9D000178  90420000   LBU V0, 0(V0)
9D00017C  00401821   ADDU V1, V0, ZERO
9D000180  8FC20004   LW V0, 4(S8)
9D000184  90420000   LBU V0, 0(V0)
9D000188  00621023   SUBU V0, V1, V0
9D00018C  AFC20008   SW V0, 8(S8)
9D000190  8FC20008   LW V0, 8(S8)
9D000194  2C420001   SLTIU V0, V0, 1
9D000198  304200FF   ANDI V0, V0, 255
9D00019C  8FC30000   LW V1, 0(S8)
9D0001A0  24630001   ADDIU V1, V1, 1
9D0001A4  AFC30000   SW V1, 0(S8)
9D0001A8  8FC30004   LW V1, 4(S8)
9D0001AC  24630001   ADDIU V1, V1, 1
9D0001B0  AFC30004   SW V1, 4(S8)
9D0001B4  1440FFE7   BNE V0, ZERO, 0x9D000154
9D0001B8  00000000   NOP
562:                     return r;
9D0001BC  8FC20008   LW V0, 8(S8)
563:                 }
9D0001C0  03C0E821   ADDU SP, S8, ZERO
9D0001C4  8FBE0014   LW S8, 20(SP)
9D0001C8  27BD0018   ADDIU SP, SP, 24
9D0001CC  03E00008   JR RA
9D0001D0  00000000   NOP
564:                 
565:                 /* Check if chr is contained in the string */
566:                 static
567:                 int chk_chr(const char* str, int chr) {
9D0001D4  27BDFFF8   ADDIU SP, SP, -8
9D0001D8  AFBE0004   SW S8, 4(SP)
9D0001DC  03A0F021   ADDU S8, SP, ZERO
9D0001E0  AFC40008   SW A0, 8(S8)
9D0001E4  AFC5000C   SW A1, 12(S8)
568:                     while (*str && *str != chr) str++;
9D0001E8  0B40007F   J 0x9D0001FC
9D0001EC  00000000   NOP
9D0001F0  8FC20008   LW V0, 8(S8)
9D0001F4  24420001   ADDIU V0, V0, 1
9D0001F8  AFC20008   SW V0, 8(S8)
9D0001FC  8FC20008   LW V0, 8(S8)
9D000200  80420000   LB V0, 0(V0)
9D000204  10400007   BEQ V0, ZERO, 0x9D000224
9D000208  00000000   NOP
9D00020C  8FC20008   LW V0, 8(S8)
9D000210  80420000   LB V0, 0(V0)
9D000214  00401821   ADDU V1, V0, ZERO
9D000218  8FC2000C   LW V0, 12(S8)
9D00021C  1462FFF4   BNE V1, V0, 0x9D0001F0
9D000220  00000000   NOP
569:                     return *str;
9D000224  8FC20008   LW V0, 8(S8)
9D000228  80420000   LB V0, 0(V0)
570:                 }
9D00022C  03C0E821   ADDU SP, S8, ZERO
9D000230  8FBE0004   LW S8, 4(SP)
9D000234  27BD0008   ADDIU SP, SP, 8
9D000238  03E00008   JR RA
9D00023C  00000000   NOP
571:                 
572:                 
573:                 
574:                 /*-----------------------------------------------------------------------*/
575:                 /* Request/Release grant to access the volume                            */
576:                 /*-----------------------------------------------------------------------*/
577:                 #if _FS_REENTRANT
578:                 
579:                 static
580:                 int lock_fs(
581:                         FATFS *fs /* File system object */
582:                         ) {
583:                     return ff_req_grant(fs->sobj);
584:                 }
585:                 
586:                 static
587:                 void unlock_fs(
588:                         FATFS *fs, /* File system object */
589:                         FRESULT res /* Result code to be returned */
590:                         ) {
591:                     if (res != FR_NOT_ENABLED &&
592:                             res != FR_INVALID_DRIVE &&
593:                             res != FR_INVALID_OBJECT &&
594:                             res != FR_TIMEOUT) {
595:                         ff_rel_grant(fs->sobj);
596:                     }
597:                 }
598:                 #endif
599:                 
600:                 
601:                 
602:                 /*-----------------------------------------------------------------------*/
603:                 /* File shareing control functions                                       */
604:                 /*-----------------------------------------------------------------------*/
605:                 #if _FS_SHARE
606:                 
607:                 static
608:                 FRESULT chk_lock(/* Check if the file can be accessed */
609:                         DIR* dj, /* Directory object pointing the file to be checked */
610:                         int acc /* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
611:                         ) {
612:                     UINT i, be;
613:                 
614:                     /* Search file semaphore table */
615:                     for (i = be = 0; i < _FS_SHARE; i++) {
616:                         if (Files[i].fs) { /* Existing entry */
617:                             if (Files[i].fs == dj->fs && /* Check if the file matched with an open file */
618:                                     Files[i].clu == dj->sclust &&
619:                                     Files[i].idx == dj->index) break;
620:                         } else { /* Blank entry */
621:                             be++;
622:                         }
623:                     }
624:                     if (i == _FS_SHARE) /* The file is not opened */
625:                         return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES; /* Is there a blank entry for new file? */
626:                 
627:                     /* The file has been opened. Reject any open against writing file and all write mode open */
628:                     return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
629:                 }
630:                 
631:                 static
632:                 int enq_lock(void) /* Check if an entry is available for a new file */ {
633:                     UINT i;
634:                 
635:                     for (i = 0; i < _FS_SHARE && Files[i].fs; i++);
636:                     return (i == _FS_SHARE) ? 0 : 1;
637:                 }
638:                 
639:                 static
640:                 UINT inc_lock(/* Increment file open counter and returns its index (0:int error) */
641:                         DIR* dj, /* Directory object pointing the file to register or increment */
642:                         int acc /* Desired access mode (0:Read, !0:Write) */
643:                         ) {
644:                     UINT i;
645:                 
646:                 
647:                     for (i = 0; i < _FS_SHARE; i++) { /* Find the file */
648:                         if (Files[i].fs == dj->fs &&
649:                                 Files[i].clu == dj->sclust &&
650:                                 Files[i].idx == dj->index) break;
651:                     }
652:                 
653:                     if (i == _FS_SHARE) { /* Not opened. Register it as new. */
654:                         for (i = 0; i < _FS_SHARE && Files[i].fs; i++);
655:                         if (i == _FS_SHARE) return 0; /* No space to register (int err) */
656:                         Files[i].fs = dj->fs;
657:                         Files[i].clu = dj->sclust;
658:                         Files[i].idx = dj->index;
659:                         Files[i].ctr = 0;
660:                     }
661:                 
662:                     if (acc && Files[i].ctr) return 0; /* Access violation (int err) */
663:                 
664:                     Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1; /* Set semaphore value */
665:                 
666:                     return i + 1;
667:                 }
668:                 
669:                 static
670:                 FRESULT dec_lock(/* Decrement file open counter */
671:                         UINT i /* Semaphore index */
672:                         ) {
673:                     WORD n;
674:                     FRESULT res;
675:                 
676:                 
677:                     if (--i < _FS_SHARE) {
678:                         n = Files[i].ctr;
679:                         if (n == 0x100) n = 0;
680:                         if (n) n--;
681:                         Files[i].ctr = n;
682:                         if (!n) Files[i].fs = 0;
683:                         res = FR_OK;
684:                     } else {
685:                         res = FR_INT_ERR;
686:                     }
687:                     return res;
688:                 }
689:                 
690:                 static
691:                 void clear_lock(/* Clear lock entries of the volume */
692:                         FATFS *fs
693:                         ) {
694:                     UINT i;
695:                 
696:                     for (i = 0; i < _FS_SHARE; i++) {
697:                         if (Files[i].fs == fs) Files[i].fs = 0;
698:                     }
699:                 }
700:                 #endif
701:                 
702:                 
703:                 
704:                 /*-----------------------------------------------------------------------*/
705:                 /* Change window offset                                                  */
706:                 
707:                 /*-----------------------------------------------------------------------*/
708:                 
709:                 static
710:                 FRESULT move_window(
711:                         FATFS *fs, /* File system object */
712:                         DWORD sector /* Sector number to make appearance in the fs->win[] */
713:                         ) /* Move to zero only writes back dirty window */ {
9D000240  27BDFFE0   ADDIU SP, SP, -32
9D000244  AFBF001C   SW RA, 28(SP)
9D000248  AFBE0018   SW S8, 24(SP)
9D00024C  03A0F021   ADDU S8, SP, ZERO
9D000250  AFC40020   SW A0, 32(S8)
9D000254  AFC50024   SW A1, 36(S8)
714:                     DWORD wsect;
715:                 
716:                 
717:                     wsect = fs->winsect;
9D000258  8FC20020   LW V0, 32(S8)
9D00025C  8C420030   LW V0, 48(V0)
9D000260  AFC20010   SW V0, 16(S8)
718:                     if (wsect != sector) { /* Changed current window */
9D000264  8FC30010   LW V1, 16(S8)
9D000268  8FC20024   LW V0, 36(S8)
9D00026C  10620052   BEQ V1, V0, 0x9D0003B8
9D000270  00000000   NOP
719:                 #if !_FS_READONLY
720:                         if (fs->wflag) { /* Write back dirty window if needed */
9D000274  8FC20020   LW V0, 32(S8)
9D000278  90420004   LBU V0, 4(V0)
9D00027C  10400038   BEQ V0, ZERO, 0x9D000360
9D000280  00000000   NOP
721:                             if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
9D000284  8FC20020   LW V0, 32(S8)
9D000288  90420001   LBU V0, 1(V0)
9D00028C  00401821   ADDU V1, V0, ZERO
9D000290  8FC20020   LW V0, 32(S8)
9D000294  24420034   ADDIU V0, V0, 52
9D000298  00602021   ADDU A0, V1, ZERO
9D00029C  00402821   ADDU A1, V0, ZERO
9D0002A0  8FC60010   LW A2, 16(S8)
9D0002A4  24070001   ADDIU A3, ZERO, 1
9D0002A8  0F40218C   JAL disk_write
9D0002AC  00000000   NOP
9D0002B0  10400004   BEQ V0, ZERO, 0x9D0002C4
9D0002B4  00000000   NOP
722:                                 return FR_DISK_ERR;
9D0002B8  24020001   ADDIU V0, ZERO, 1
9D0002BC  0B4000EF   J 0x9D0003BC
9D0002C0  00000000   NOP
723:                             fs->wflag = 0;
9D0002C4  8FC20020   LW V0, 32(S8)
9D0002C8  A0400004   SB ZERO, 4(V0)
724:                             if (wsect < (fs->fatbase + fs->fsize)) { /* In FAT area */
9D0002CC  8FC20020   LW V0, 32(S8)
9D0002D0  8C430024   LW V1, 36(V0)
9D0002D4  8FC20020   LW V0, 32(S8)
9D0002D8  8C420020   LW V0, 32(V0)
9D0002DC  00621821   ADDU V1, V1, V0
9D0002E0  8FC20010   LW V0, 16(S8)
9D0002E4  0043102B   SLTU V0, V0, V1
9D0002E8  1040001D   BEQ V0, ZERO, 0x9D000360
9D0002EC  00000000   NOP
725:                                 BYTE nf;
726:                                 for (nf = fs->n_fats; nf > 1; nf--) { /* Reflect the change to all FAT copies */
9D0002F0  8FC20020   LW V0, 32(S8)
9D0002F4  90420003   LBU V0, 3(V0)
9D0002F8  A3C20014   SB V0, 20(S8)
9D0002FC  0B4000D4   J 0x9D000350
9D000300  00000000   NOP
9D000344  93C20014   LBU V0, 20(S8)
9D000348  2442FFFF   ADDIU V0, V0, -1
9D00034C  A3C20014   SB V0, 20(S8)
9D000350  93C20014   LBU V0, 20(S8)
9D000354  2C420002   SLTIU V0, V0, 2
9D000358  1040FFEA   BEQ V0, ZERO, 0x9D000304
9D00035C  00000000   NOP
727:                                     wsect += fs->fsize;
9D000304  8FC20020   LW V0, 32(S8)
9D000308  8C420020   LW V0, 32(V0)
9D00030C  8FC30010   LW V1, 16(S8)
9D000310  00621021   ADDU V0, V1, V0
9D000314  AFC20010   SW V0, 16(S8)
728:                                     disk_write(fs->drv, fs->win, wsect, 1);
9D000318  8FC20020   LW V0, 32(S8)
9D00031C  90420001   LBU V0, 1(V0)
9D000320  00401821   ADDU V1, V0, ZERO
9D000324  8FC20020   LW V0, 32(S8)
9D000328  24420034   ADDIU V0, V0, 52
9D00032C  00602021   ADDU A0, V1, ZERO
9D000330  00402821   ADDU A1, V0, ZERO
9D000334  8FC60010   LW A2, 16(S8)
9D000338  24070001   ADDIU A3, ZERO, 1
9D00033C  0F40218C   JAL disk_write
9D000340  00000000   NOP
729:                                 }
730:                             }
731:                         }
732:                 #endif
733:                         if (sector) {
9D000360  8FC20024   LW V0, 36(S8)
9D000364  10400014   BEQ V0, ZERO, 0x9D0003B8
9D000368  00000000   NOP
734:                             if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
9D00036C  8FC20020   LW V0, 32(S8)
9D000370  90420001   LBU V0, 1(V0)
9D000374  00401821   ADDU V1, V0, ZERO
9D000378  8FC20020   LW V0, 32(S8)
9D00037C  24420034   ADDIU V0, V0, 52
9D000380  00602021   ADDU A0, V1, ZERO
9D000384  00402821   ADDU A1, V0, ZERO
9D000388  8FC60024   LW A2, 36(S8)
9D00038C  24070001   ADDIU A3, ZERO, 1
9D000390  0F402130   JAL disk_read
9D000394  00000000   NOP
9D000398  10400004   BEQ V0, ZERO, 0x9D0003AC
9D00039C  00000000   NOP
735:                                 return FR_DISK_ERR;
9D0003A0  24020001   ADDIU V0, ZERO, 1
9D0003A4  0B4000EF   J 0x9D0003BC
9D0003A8  00000000   NOP
736:                             fs->winsect = sector;
9D0003AC  8FC20020   LW V0, 32(S8)
9D0003B0  8FC30024   LW V1, 36(S8)
9D0003B4  AC430030   SW V1, 48(V0)
737:                         }
738:                     }
739:                 
740:                     return FR_OK;
9D0003B8  00001021   ADDU V0, ZERO, ZERO
741:                 }
9D0003BC  03C0E821   ADDU SP, S8, ZERO
9D0003C0  8FBF001C   LW RA, 28(SP)
9D0003C4  8FBE0018   LW S8, 24(SP)
9D0003C8  27BD0020   ADDIU SP, SP, 32
9D0003CC  03E00008   JR RA
9D0003D0  00000000   NOP
742:                 
743:                 
744:                 
745:                 
746:                 /*-----------------------------------------------------------------------*/
747:                 /* Clean-up cached data                                                  */
748:                 /*-----------------------------------------------------------------------*/
749:                 #if !_FS_READONLY
750:                 
751:                 static
752:                 FRESULT sync(/* FR_OK: successful, FR_DISK_ERR: failed */
753:                         FATFS *fs /* File system object */
754:                         ) {
9D0003D4  27BDFFE0   ADDIU SP, SP, -32
9D0003D8  AFBF001C   SW RA, 28(SP)
9D0003DC  AFBE0018   SW S8, 24(SP)
9D0003E0  03A0F021   ADDU S8, SP, ZERO
9D0003E4  AFC40020   SW A0, 32(S8)
755:                     FRESULT res;
756:                 
757:                 
758:                     res = move_window(fs, 0);
9D0003E8  8FC40020   LW A0, 32(S8)
9D0003EC  00002821   ADDU A1, ZERO, ZERO
9D0003F0  0F400090   JAL 0x9D000240
9D0003F4  00000000   NOP
9D0003F8  AFC20010   SW V0, 16(S8)
759:                     if (res == FR_OK) {
9D0003FC  8FC20010   LW V0, 16(S8)
9D000400  1440008D   BNE V0, ZERO, 0x9D000638
9D000404  00000000   NOP
760:                         /* Update FSInfo sector if needed */
761:                         if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
9D000408  8FC20020   LW V0, 32(S8)
9D00040C  90430000   LBU V1, 0(V0)
9D000410  24020003   ADDIU V0, ZERO, 3
9D000414  1462007D   BNE V1, V0, 0x9D00060C
9D000418  00000000   NOP
9D00041C  8FC20020   LW V0, 32(S8)
9D000420  90420005   LBU V0, 5(V0)
9D000424  10400079   BEQ V0, ZERO, 0x9D00060C
9D000428  00000000   NOP
762:                             fs->winsect = 0;
9D00042C  8FC20020   LW V0, 32(S8)
9D000430  AC400030   SW ZERO, 48(V0)
763:                             /* Create FSInfo structure */
764:                             mem_set(fs->win, 0, 512);
9D000434  8FC20020   LW V0, 32(S8)
9D000438  24420034   ADDIU V0, V0, 52
9D00043C  00402021   ADDU A0, V0, ZERO
9D000440  00002821   ADDU A1, ZERO, ZERO
9D000444  24060200   ADDIU A2, ZERO, 512
9D000448  0F40002B   JAL 0x9D0000AC
9D00044C  00000000   NOP
765:                             ST_WORD(fs->win + BS_55AA, 0xAA55);
9D000450  8FC20020   LW V0, 32(S8)
9D000454  24420232   ADDIU V0, V0, 562
9D000458  24030055   ADDIU V1, ZERO, 85
9D00045C  A0430000   SB V1, 0(V0)
9D000460  8FC20020   LW V0, 32(S8)
9D000464  24420233   ADDIU V0, V0, 563
9D000468  2403FFAA   ADDIU V1, ZERO, -86
9D00046C  A0430000   SB V1, 0(V0)
766:                             ST_DWORD(fs->win + FSI_LeadSig, 0x41615252);
9D000470  8FC20020   LW V0, 32(S8)
9D000474  24030052   ADDIU V1, ZERO, 82
9D000478  A0430034   SB V1, 52(V0)
9D00047C  8FC20020   LW V0, 32(S8)
9D000480  24420035   ADDIU V0, V0, 53
9D000484  24030052   ADDIU V1, ZERO, 82
9D000488  A0430000   SB V1, 0(V0)
9D00048C  8FC20020   LW V0, 32(S8)
9D000490  24420036   ADDIU V0, V0, 54
9D000494  24030061   ADDIU V1, ZERO, 97
9D000498  A0430000   SB V1, 0(V0)
9D00049C  8FC20020   LW V0, 32(S8)
9D0004A0  24420037   ADDIU V0, V0, 55
9D0004A4  24030041   ADDIU V1, ZERO, 65
9D0004A8  A0430000   SB V1, 0(V0)
767:                             ST_DWORD(fs->win + FSI_StrucSig, 0x61417272);
9D0004AC  8FC20020   LW V0, 32(S8)
9D0004B0  24420218   ADDIU V0, V0, 536
9D0004B4  24030072   ADDIU V1, ZERO, 114
9D0004B8  A0430000   SB V1, 0(V0)
9D0004BC  8FC20020   LW V0, 32(S8)
9D0004C0  24420219   ADDIU V0, V0, 537
9D0004C4  24030072   ADDIU V1, ZERO, 114
9D0004C8  A0430000   SB V1, 0(V0)
9D0004CC  8FC20020   LW V0, 32(S8)
9D0004D0  2442021A   ADDIU V0, V0, 538
9D0004D4  24030041   ADDIU V1, ZERO, 65
9D0004D8  A0430000   SB V1, 0(V0)
9D0004DC  8FC20020   LW V0, 32(S8)
9D0004E0  2442021B   ADDIU V0, V0, 539
9D0004E4  24030061   ADDIU V1, ZERO, 97
9D0004E8  A0430000   SB V1, 0(V0)
768:                             ST_DWORD(fs->win + FSI_Free_Count, fs->free_clust);
9D0004EC  8FC20020   LW V0, 32(S8)
9D0004F0  2442021C   ADDIU V0, V0, 540
9D0004F4  8FC30020   LW V1, 32(S8)
9D0004F8  8C630010   LW V1, 16(V1)
9D0004FC  306300FF   ANDI V1, V1, 255
9D000500  A0430000   SB V1, 0(V0)
9D000504  8FC20020   LW V0, 32(S8)
9D000508  2442021D   ADDIU V0, V0, 541
9D00050C  8FC30020   LW V1, 32(S8)
9D000510  8C630010   LW V1, 16(V1)
9D000514  3063FFFF   ANDI V1, V1, -1
9D000518  00031A02   SRL V1, V1, 8
9D00051C  3063FFFF   ANDI V1, V1, -1
9D000520  306300FF   ANDI V1, V1, 255
9D000524  A0430000   SB V1, 0(V0)
9D000528  8FC20020   LW V0, 32(S8)
9D00052C  2442021E   ADDIU V0, V0, 542
9D000530  8FC30020   LW V1, 32(S8)
9D000534  8C630010   LW V1, 16(V1)
9D000538  00031C02   SRL V1, V1, 16
9D00053C  306300FF   ANDI V1, V1, 255
9D000540  A0430000   SB V1, 0(V0)
9D000544  8FC20020   LW V0, 32(S8)
9D000548  2442021F   ADDIU V0, V0, 543
9D00054C  8FC30020   LW V1, 32(S8)
9D000550  8C630010   LW V1, 16(V1)
9D000554  00031E02   SRL V1, V1, 24
9D000558  306300FF   ANDI V1, V1, 255
9D00055C  A0430000   SB V1, 0(V0)
769:                             ST_DWORD(fs->win + FSI_Nxt_Free, fs->last_clust);
9D000560  8FC20020   LW V0, 32(S8)
9D000564  24420220   ADDIU V0, V0, 544
9D000568  8FC30020   LW V1, 32(S8)
9D00056C  8C63000C   LW V1, 12(V1)
9D000570  306300FF   ANDI V1, V1, 255
9D000574  A0430000   SB V1, 0(V0)
9D000578  8FC20020   LW V0, 32(S8)
9D00057C  24420221   ADDIU V0, V0, 545
9D000580  8FC30020   LW V1, 32(S8)
9D000584  8C63000C   LW V1, 12(V1)
9D000588  3063FFFF   ANDI V1, V1, -1
9D00058C  00031A02   SRL V1, V1, 8
9D000590  3063FFFF   ANDI V1, V1, -1
9D000594  306300FF   ANDI V1, V1, 255
9D000598  A0430000   SB V1, 0(V0)
9D00059C  8FC20020   LW V0, 32(S8)
9D0005A0  24420222   ADDIU V0, V0, 546
9D0005A4  8FC30020   LW V1, 32(S8)
9D0005A8  8C63000C   LW V1, 12(V1)
9D0005AC  00031C02   SRL V1, V1, 16
9D0005B0  306300FF   ANDI V1, V1, 255
9D0005B4  A0430000   SB V1, 0(V0)
9D0005B8  8FC20020   LW V0, 32(S8)
9D0005BC  24420223   ADDIU V0, V0, 547
9D0005C0  8FC30020   LW V1, 32(S8)
9D0005C4  8C63000C   LW V1, 12(V1)
9D0005C8  00031E02   SRL V1, V1, 24
9D0005CC  306300FF   ANDI V1, V1, 255
9D0005D0  A0430000   SB V1, 0(V0)
770:                             /* Write it into the FSInfo sector */
771:                             disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
9D0005D4  8FC20020   LW V0, 32(S8)
9D0005D8  90420001   LBU V0, 1(V0)
9D0005DC  00402021   ADDU A0, V0, ZERO
9D0005E0  8FC20020   LW V0, 32(S8)
9D0005E4  24430034   ADDIU V1, V0, 52
9D0005E8  8FC20020   LW V0, 32(S8)
9D0005EC  8C420014   LW V0, 20(V0)
9D0005F0  00602821   ADDU A1, V1, ZERO
9D0005F4  00403021   ADDU A2, V0, ZERO
9D0005F8  24070001   ADDIU A3, ZERO, 1
9D0005FC  0F40218C   JAL disk_write
9D000600  00000000   NOP
772:                             fs->fsi_flag = 0;
9D000604  8FC20020   LW V0, 32(S8)
9D000608  A0400005   SB ZERO, 5(V0)
773:                         }
774:                         /* Make sure that no pending write process in the physical drive */
775:                         if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
9D00060C  8FC20020   LW V0, 32(S8)
9D000610  90420001   LBU V0, 1(V0)
9D000614  00402021   ADDU A0, V0, ZERO
9D000618  00002821   ADDU A1, ZERO, ZERO
9D00061C  00003021   ADDU A2, ZERO, ZERO
9D000620  0F4021FD   JAL disk_ioctl
9D000624  00000000   NOP
9D000628  10400003   BEQ V0, ZERO, 0x9D000638
9D00062C  00000000   NOP
776:                             res = FR_DISK_ERR;
9D000630  24020001   ADDIU V0, ZERO, 1
9D000634  AFC20010   SW V0, 16(S8)
777:                     }
778:                 
779:                     return res;
9D000638  8FC20010   LW V0, 16(S8)
780:                 }
9D00063C  03C0E821   ADDU SP, S8, ZERO
9D000640  8FBF001C   LW RA, 28(SP)
9D000644  8FBE0018   LW S8, 24(SP)
9D000648  27BD0020   ADDIU SP, SP, 32
9D00064C  03E00008   JR RA
9D000650  00000000   NOP
781:                 #endif
782:                 
783:                 
784:                 
785:                 
786:                 /*-----------------------------------------------------------------------*/
787:                 /* Get sector# from cluster#                                             */
788:                 
789:                 /*-----------------------------------------------------------------------*/
790:                 
791:                 
792:                 DWORD clust2sect(/* !=0: Sector number, 0: Failed - invalid cluster# */
793:                         FATFS *fs, /* File system object */
794:                         DWORD clst /* Cluster# to be converted */
795:                         ) {
9D000654  27BDFFF8   ADDIU SP, SP, -8
9D000658  AFBE0004   SW S8, 4(SP)
9D00065C  03A0F021   ADDU S8, SP, ZERO
9D000660  AFC40008   SW A0, 8(S8)
9D000664  AFC5000C   SW A1, 12(S8)
796:                     clst -= 2;
9D000668  8FC2000C   LW V0, 12(S8)
9D00066C  2442FFFE   ADDIU V0, V0, -2
9D000670  AFC2000C   SW V0, 12(S8)
797:                     if (clst >= (fs->n_fatent - 2)) return 0; /* Invalid cluster# */
9D000674  8FC20008   LW V0, 8(S8)
9D000678  8C42001C   LW V0, 28(V0)
9D00067C  2443FFFE   ADDIU V1, V0, -2
9D000680  8FC2000C   LW V0, 12(S8)
9D000684  0043102B   SLTU V0, V0, V1
9D000688  14400004   BNE V0, ZERO, 0x9D00069C
9D00068C  00000000   NOP
9D000690  00001021   ADDU V0, ZERO, ZERO
9D000694  0B4001AF   J 0x9D0006BC
9D000698  00000000   NOP
798:                     return clst * fs->csize + fs->database;
9D00069C  8FC20008   LW V0, 8(S8)
9D0006A0  90420002   LBU V0, 2(V0)
9D0006A4  00401821   ADDU V1, V0, ZERO
9D0006A8  8FC2000C   LW V0, 12(S8)
9D0006AC  70621802   MUL V1, V1, V0
9D0006B0  8FC20008   LW V0, 8(S8)
9D0006B4  8C42002C   LW V0, 44(V0)
9D0006B8  00621021   ADDU V0, V1, V0
799:                 }
9D0006BC  03C0E821   ADDU SP, S8, ZERO
9D0006C0  8FBE0004   LW S8, 4(SP)
9D0006C4  27BD0008   ADDIU SP, SP, 8
9D0006C8  03E00008   JR RA
9D0006CC  00000000   NOP
800:                 
801:                 
802:                 
803:                 
804:                 /*-----------------------------------------------------------------------*/
805:                 /* FAT access - Read value of a FAT entry                                */
806:                 
807:                 /*-----------------------------------------------------------------------*/
808:                 
809:                 
810:                 DWORD get_fat(/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
811:                         FATFS *fs, /* File system object */
812:                         DWORD clst /* Cluster# to get the link information */
813:                         ) {
9D0006D0  27BDFFD8   ADDIU SP, SP, -40
9D0006D4  AFBF0024   SW RA, 36(SP)
9D0006D8  AFBE0020   SW S8, 32(SP)
9D0006DC  03A0F021   ADDU S8, SP, ZERO
9D0006E0  AFC40028   SW A0, 40(S8)
9D0006E4  AFC5002C   SW A1, 44(S8)
814:                     UINT wc, bc;
815:                     BYTE *p;
816:                 
817:                 
818:                     if (clst < 2 || clst >= fs->n_fatent) /* Chack range */
9D0006E8  8FC2002C   LW V0, 44(S8)
9D0006EC  2C420002   SLTIU V0, V0, 2
9D0006F0  14400007   BNE V0, ZERO, 0x9D000710
9D0006F4  00000000   NOP
9D0006F8  8FC20028   LW V0, 40(S8)
9D0006FC  8C43001C   LW V1, 28(V0)
9D000700  8FC2002C   LW V0, 44(S8)
9D000704  0043102B   SLTU V0, V0, V1
9D000708  14400004   BNE V0, ZERO, 0x9D00071C
9D00070C  00000000   NOP
819:                         return 1;
9D000710  24020001   ADDIU V0, ZERO, 1
9D000714  0B40025E   J 0x9D000978
9D000718  00000000   NOP
820:                 
821:                     switch (fs->fs_type) {
9D00071C  8FC20028   LW V0, 40(S8)
9D000720  90420000   LBU V0, 0(V0)
9D000724  24030002   ADDIU V1, ZERO, 2
9D000728  10430043   BEQ V0, V1, 0x9D000838
9D00072C  00000000   NOP
9D000730  24030003   ADDIU V1, ZERO, 3
9D000734  1043005F   BEQ V0, V1, 0x9D0008B4
9D000738  00000000   NOP
9D00073C  24030001   ADDIU V1, ZERO, 1
9D000740  1443008C   BNE V0, V1, 0x9D000974
9D000744  00000000   NOP
822:                         case FS_FAT12:
823:                             bc = (UINT) clst;
9D000748  8FC2002C   LW V0, 44(S8)
9D00074C  AFC20010   SW V0, 16(S8)
824:                             bc += bc / 2;
9D000750  8FC20010   LW V0, 16(S8)
9D000754  00021042   SRL V0, V0, 1
9D000758  8FC30010   LW V1, 16(S8)
9D00075C  00621021   ADDU V0, V1, V0
9D000760  AFC20010   SW V0, 16(S8)
825:                             if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
9D000764  8FC20028   LW V0, 40(S8)
9D000768  8C430024   LW V1, 36(V0)
9D00076C  8FC20010   LW V0, 16(S8)
9D000770  00021242   SRL V0, V0, 9
9D000774  00621021   ADDU V0, V1, V0
9D000778  8FC40028   LW A0, 40(S8)
9D00077C  00402821   ADDU A1, V0, ZERO
9D000780  0F400090   JAL 0x9D000240
9D000784  00000000   NOP
9D000788  14400070   BNE V0, ZERO, 0x9D00094C
9D00078C  00000000   NOP
9D00094C  00000000   NOP
9D000950  0B40025D   J 0x9D000974
9D000954  00000000   NOP
826:                             wc = fs->win[bc % SS(fs)];
9D000790  8FC20010   LW V0, 16(S8)
9D000794  304201FF   ANDI V0, V0, 511
9D000798  8FC30028   LW V1, 40(S8)
9D00079C  00621021   ADDU V0, V1, V0
9D0007A0  90420034   LBU V0, 52(V0)
9D0007A4  AFC20014   SW V0, 20(S8)
827:                             bc++;
9D0007A8  8FC20010   LW V0, 16(S8)
9D0007AC  24420001   ADDIU V0, V0, 1
9D0007B0  AFC20010   SW V0, 16(S8)
828:                             if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
9D0007B4  8FC20028   LW V0, 40(S8)
9D0007B8  8C430024   LW V1, 36(V0)
9D0007BC  8FC20010   LW V0, 16(S8)
9D0007C0  00021242   SRL V0, V0, 9
9D0007C4  00621021   ADDU V0, V1, V0
9D0007C8  8FC40028   LW A0, 40(S8)
9D0007CC  00402821   ADDU A1, V0, ZERO
9D0007D0  0F400090   JAL 0x9D000240
9D0007D4  00000000   NOP
9D0007D8  1440005F   BNE V0, ZERO, 0x9D000958
9D0007DC  00000000   NOP
9D000958  00000000   NOP
9D00095C  0B40025D   J 0x9D000974
9D000960  00000000   NOP
829:                             wc |= fs->win[bc % SS(fs)] << 8;
9D0007E0  8FC20010   LW V0, 16(S8)
9D0007E4  304201FF   ANDI V0, V0, 511
9D0007E8  8FC30028   LW V1, 40(S8)
9D0007EC  00621021   ADDU V0, V1, V0
9D0007F0  90420034   LBU V0, 52(V0)
9D0007F4  00021200   SLL V0, V0, 8
9D0007F8  8FC30014   LW V1, 20(S8)
9D0007FC  00621025   OR V0, V1, V0
9D000800  AFC20014   SW V0, 20(S8)
830:                             return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
9D000804  8FC2002C   LW V0, 44(S8)
9D000808  30420001   ANDI V0, V0, 1
9D00080C  304200FF   ANDI V0, V0, 255
9D000810  10400005   BEQ V0, ZERO, 0x9D000828
9D000814  00000000   NOP
9D000818  8FC20014   LW V0, 20(S8)
9D00081C  00021102   SRL V0, V0, 4
9D000820  0B40020C   J 0x9D000830
9D000824  00000000   NOP
9D000828  8FC20014   LW V0, 20(S8)
9D00082C  30420FFF   ANDI V0, V0, 4095
9D000830  0B40025E   J 0x9D000978
9D000834  00000000   NOP
831:                 
832:                         case FS_FAT16:
833:                             if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
9D000838  8FC20028   LW V0, 40(S8)
9D00083C  8C430024   LW V1, 36(V0)
9D000840  8FC2002C   LW V0, 44(S8)
9D000844  00021202   SRL V0, V0, 8
9D000848  00621021   ADDU V0, V1, V0
9D00084C  8FC40028   LW A0, 40(S8)
9D000850  00402821   ADDU A1, V0, ZERO
9D000854  0F400090   JAL 0x9D000240
9D000858  00000000   NOP
9D00085C  14400041   BNE V0, ZERO, 0x9D000964
9D000860  00000000   NOP
9D000964  00000000   NOP
9D000968  0B40025D   J 0x9D000974
9D00096C  00000000   NOP
834:                             p = &fs->win[clst * 2 % SS(fs)];
9D000864  8FC20028   LW V0, 40(S8)
9D000868  24430034   ADDIU V1, V0, 52
9D00086C  8FC2002C   LW V0, 44(S8)
9D000870  00021040   SLL V0, V0, 1
9D000874  304201FF   ANDI V0, V0, 511
9D000878  00621021   ADDU V0, V1, V0
9D00087C  AFC20018   SW V0, 24(S8)
835:                             return LD_WORD(p);
9D000880  8FC20018   LW V0, 24(S8)
9D000884  24420001   ADDIU V0, V0, 1
9D000888  90420000   LBU V0, 0(V0)
9D00088C  00021200   SLL V0, V0, 8
9D000890  7C021E20   SEH V1, V0
9D000894  8FC20018   LW V0, 24(S8)
9D000898  90420000   LBU V0, 0(V0)
9D00089C  7C021620   SEH V0, V0
9D0008A0  00621025   OR V0, V1, V0
9D0008A4  7C021620   SEH V0, V0
9D0008A8  3042FFFF   ANDI V0, V0, -1
9D0008AC  0B40025E   J 0x9D000978
9D0008B0  00000000   NOP
836:                 
837:                         case FS_FAT32:
838:                             if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
9D0008B4  8FC20028   LW V0, 40(S8)
9D0008B8  8C430024   LW V1, 36(V0)
9D0008BC  8FC2002C   LW V0, 44(S8)
9D0008C0  000211C2   SRL V0, V0, 7
9D0008C4  00621021   ADDU V0, V1, V0
9D0008C8  8FC40028   LW A0, 40(S8)
9D0008CC  00402821   ADDU A1, V0, ZERO
9D0008D0  0F400090   JAL 0x9D000240
9D0008D4  00000000   NOP
9D0008D8  14400025   BNE V0, ZERO, 0x9D000970
9D0008DC  00000000   NOP
9D000970  00000000   NOP
839:                             p = &fs->win[clst * 4 % SS(fs)];
9D0008E0  8FC20028   LW V0, 40(S8)
9D0008E4  24430034   ADDIU V1, V0, 52
9D0008E8  8FC2002C   LW V0, 44(S8)
9D0008EC  00021080   SLL V0, V0, 2
9D0008F0  304201FF   ANDI V0, V0, 511
9D0008F4  00621021   ADDU V0, V1, V0
9D0008F8  AFC20018   SW V0, 24(S8)
840:                             return LD_DWORD(p) & 0x0FFFFFFF;
9D0008FC  8FC20018   LW V0, 24(S8)
9D000900  24420003   ADDIU V0, V0, 3
9D000904  90420000   LBU V0, 0(V0)
9D000908  00021E00   SLL V1, V0, 24
9D00090C  8FC20018   LW V0, 24(S8)
9D000910  24420002   ADDIU V0, V0, 2
9D000914  90420000   LBU V0, 0(V0)
9D000918  00021400   SLL V0, V0, 16
9D00091C  00621825   OR V1, V1, V0
9D000920  8FC20018   LW V0, 24(S8)
9D000924  24420001   ADDIU V0, V0, 1
9D000928  90420000   LBU V0, 0(V0)
9D00092C  00021200   SLL V0, V0, 8
9D000930  00621825   OR V1, V1, V0
9D000934  8FC20018   LW V0, 24(S8)
9D000938  90420000   LBU V0, 0(V0)
9D00093C  00621025   OR V0, V1, V0
9D000940  7C42D800   EXT V0, V0, 0, 28
9D000944  0B40025E   J 0x9D000978
9D000948  00000000   NOP
841:                     }
842:                 
843:                     return 0xFFFFFFFF; /* An error occurred at the disk I/O layer */
9D000974  2402FFFF   ADDIU V0, ZERO, -1
844:                 }
9D000978  03C0E821   ADDU SP, S8, ZERO
9D00097C  8FBF0024   LW RA, 36(SP)
9D000980  8FBE0020   LW S8, 32(SP)
9D000984  27BD0028   ADDIU SP, SP, 40
9D000988  03E00008   JR RA
9D00098C  00000000   NOP
845:                 
846:                 
847:                 
848:                 
849:                 /*-----------------------------------------------------------------------*/
850:                 /* FAT access - Change value of a FAT entry                              */
851:                 /*-----------------------------------------------------------------------*/
852:                 #if !_FS_READONLY
853:                 
854:                 FRESULT put_fat(
855:                         FATFS *fs, /* File system object */
856:                         DWORD clst, /* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
857:                         DWORD val /* New value to mark the cluster */
858:                         ) {
9D000990  27BDFFD8   ADDIU SP, SP, -40
9D000994  AFBF0024   SW RA, 36(SP)
9D000998  AFBE0020   SW S8, 32(SP)
9D00099C  03A0F021   ADDU S8, SP, ZERO
9D0009A0  AFC40028   SW A0, 40(S8)
9D0009A4  AFC5002C   SW A1, 44(S8)
9D0009A8  AFC60030   SW A2, 48(S8)
859:                     UINT bc;
860:                     BYTE *p;
861:                     FRESULT res;
862:                 
863:                 
864:                     if (clst < 2 || clst >= fs->n_fatent) { /* Check range */
9D0009AC  8FC2002C   LW V0, 44(S8)
9D0009B0  2C420002   SLTIU V0, V0, 2
9D0009B4  14400007   BNE V0, ZERO, 0x9D0009D4
9D0009B8  00000000   NOP
9D0009BC  8FC20028   LW V0, 40(S8)
9D0009C0  8C43001C   LW V1, 28(V0)
9D0009C4  8FC2002C   LW V0, 44(S8)
9D0009C8  0043102B   SLTU V0, V0, V1
9D0009CC  14400005   BNE V0, ZERO, 0x9D0009E4
9D0009D0  00000000   NOP
865:                         res = FR_INT_ERR;
9D0009D4  24020002   ADDIU V0, ZERO, 2
9D0009D8  AFC20010   SW V0, 16(S8)
9D0009DC  0B400361   J 0x9D000D84
9D0009E0  00000000   NOP
866:                 
867:                     } else {
868:                         switch (fs->fs_type) {
9D0009E4  8FC20028   LW V0, 40(S8)
9D0009E8  90420000   LBU V0, 0(V0)
9D0009EC  24030002   ADDIU V1, ZERO, 2
9D0009F0  1043006D   BEQ V0, V1, 0x9D000BA8
9D0009F4  00000000   NOP
9D0009F8  24030003   ADDIU V1, ZERO, 3
9D0009FC  1043008C   BEQ V0, V1, 0x9D000C30
9D000A00  00000000   NOP
9D000A04  24030001   ADDIU V1, ZERO, 1
9D000A08  144300CD   BNE V0, V1, 0x9D000D40
9D000A0C  00000000   NOP
869:                             case FS_FAT12:
870:                                 bc = clst;
9D000A10  8FC2002C   LW V0, 44(S8)
9D000A14  AFC20014   SW V0, 20(S8)
871:                                 bc += bc / 2;
9D000A18  8FC20014   LW V0, 20(S8)
9D000A1C  00021042   SRL V0, V0, 1
9D000A20  8FC30014   LW V1, 20(S8)
9D000A24  00621021   ADDU V0, V1, V0
9D000A28  AFC20014   SW V0, 20(S8)
872:                                 res = move_window(fs, fs->fatbase + (bc / SS(fs)));
9D000A2C  8FC20028   LW V0, 40(S8)
9D000A30  8C430024   LW V1, 36(V0)
9D000A34  8FC20014   LW V0, 20(S8)
9D000A38  00021242   SRL V0, V0, 9
9D000A3C  00621021   ADDU V0, V1, V0
9D000A40  8FC40028   LW A0, 40(S8)
9D000A44  00402821   ADDU A1, V0, ZERO
9D000A48  0F400090   JAL 0x9D000240
9D000A4C  00000000   NOP
9D000A50  AFC20010   SW V0, 16(S8)
873:                                 if (res != FR_OK) break;
9D000A54  8FC20010   LW V0, 16(S8)
9D000A58  144000BD   BNE V0, ZERO, 0x9D000D50
9D000A5C  00000000   NOP
9D000D50  00000000   NOP
9D000D54  0B40035E   J 0x9D000D78
9D000D58  00000000   NOP
874:                                 p = &fs->win[bc % SS(fs)];
9D000A60  8FC20028   LW V0, 40(S8)
9D000A64  24430034   ADDIU V1, V0, 52
9D000A68  8FC20014   LW V0, 20(S8)
9D000A6C  304201FF   ANDI V0, V0, 511
9D000A70  00621021   ADDU V0, V1, V0
9D000A74  AFC20018   SW V0, 24(S8)
875:                                 *p = (clst & 1) ? ((*p & 0x0F) | ((BYTE) val << 4)) : (BYTE) val;
9D000A78  8FC2002C   LW V0, 44(S8)
9D000A7C  30420001   ANDI V0, V0, 1
9D000A80  304200FF   ANDI V0, V0, 255
9D000A84  1040000F   BEQ V0, ZERO, 0x9D000AC4
9D000A88  00000000   NOP
9D000A8C  8FC20018   LW V0, 24(S8)
9D000A90  90420000   LBU V0, 0(V0)
9D000A94  7C021420   SEB V0, V0
9D000A98  3042000F   ANDI V0, V0, 15
9D000A9C  7C021C20   SEB V1, V0
9D000AA0  8FC20030   LW V0, 48(S8)
9D000AA4  304200FF   ANDI V0, V0, 255
9D000AA8  00021100   SLL V0, V0, 4
9D000AAC  7C021420   SEB V0, V0
9D000AB0  00621025   OR V0, V1, V0
9D000AB4  7C021420   SEB V0, V0
9D000AB8  304200FF   ANDI V0, V0, 255
9D000ABC  0B4002B3   J 0x9D000ACC
9D000AC0  00000000   NOP
9D000AC4  8FC20030   LW V0, 48(S8)
9D000AC8  304200FF   ANDI V0, V0, 255
9D000ACC  8FC30018   LW V1, 24(S8)
9D000AD0  A0620000   SB V0, 0(V1)
876:                                 bc++;
9D000AD4  8FC20014   LW V0, 20(S8)
9D000AD8  24420001   ADDIU V0, V0, 1
9D000ADC  AFC20014   SW V0, 20(S8)
877:                                 fs->wflag = 1;
9D000AE0  8FC20028   LW V0, 40(S8)
9D000AE4  24030001   ADDIU V1, ZERO, 1
9D000AE8  A0430004   SB V1, 4(V0)
878:                                 res = move_window(fs, fs->fatbase + (bc / SS(fs)));
9D000AEC  8FC20028   LW V0, 40(S8)
9D000AF0  8C430024   LW V1, 36(V0)
9D000AF4  8FC20014   LW V0, 20(S8)
9D000AF8  00021242   SRL V0, V0, 9
9D000AFC  00621021   ADDU V0, V1, V0
9D000B00  8FC40028   LW A0, 40(S8)
9D000B04  00402821   ADDU A1, V0, ZERO
9D000B08  0F400090   JAL 0x9D000240
9D000B0C  00000000   NOP
9D000B10  AFC20010   SW V0, 16(S8)
879:                                 if (res != FR_OK) break;
9D000B14  8FC20010   LW V0, 16(S8)
9D000B18  14400090   BNE V0, ZERO, 0x9D000D5C
9D000B1C  00000000   NOP
9D000D5C  00000000   NOP
9D000D60  0B40035E   J 0x9D000D78
9D000D64  00000000   NOP
880:                                 p = &fs->win[bc % SS(fs)];
9D000B20  8FC20028   LW V0, 40(S8)
9D000B24  24430034   ADDIU V1, V0, 52
9D000B28  8FC20014   LW V0, 20(S8)
9D000B2C  304201FF   ANDI V0, V0, 511
9D000B30  00621021   ADDU V0, V1, V0
9D000B34  AFC20018   SW V0, 24(S8)
881:                                 *p = (clst & 1) ? (BYTE) (val >> 4) : ((*p & 0xF0) | ((BYTE) (val >> 8) & 0x0F));
9D000B38  8FC2002C   LW V0, 44(S8)
9D000B3C  30420001   ANDI V0, V0, 1
9D000B40  304200FF   ANDI V0, V0, 255
9D000B44  10400006   BEQ V0, ZERO, 0x9D000B60
9D000B48  00000000   NOP
9D000B4C  8FC20030   LW V0, 48(S8)
9D000B50  00021102   SRL V0, V0, 4
9D000B54  304200FF   ANDI V0, V0, 255
9D000B58  0B4002E6   J 0x9D000B98
9D000B5C  00000000   NOP
9D000B60  8FC20018   LW V0, 24(S8)
9D000B64  90420000   LBU V0, 0(V0)
9D000B68  7C021C20   SEB V1, V0
9D000B6C  2402FFF0   ADDIU V0, ZERO, -16
9D000B70  00621024   AND V0, V1, V0
9D000B74  7C021C20   SEB V1, V0
9D000B78  8FC20030   LW V0, 48(S8)
9D000B7C  00021202   SRL V0, V0, 8
9D000B80  7C021420   SEB V0, V0
9D000B84  3042000F   ANDI V0, V0, 15
9D000B88  7C021420   SEB V0, V0
9D000B8C  00621025   OR V0, V1, V0
9D000B90  7C021420   SEB V0, V0
9D000B94  304200FF   ANDI V0, V0, 255
9D000B98  8FC30018   LW V1, 24(S8)
9D000B9C  A0620000   SB V0, 0(V1)
882:                                 break;
9D000BA0  0B40035E   J 0x9D000D78
9D000BA4  00000000   NOP
883:                 
884:                             case FS_FAT16:
885:                                 res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
9D000BA8  8FC20028   LW V0, 40(S8)
9D000BAC  8C430024   LW V1, 36(V0)
9D000BB0  8FC2002C   LW V0, 44(S8)
9D000BB4  00021202   SRL V0, V0, 8
9D000BB8  00621021   ADDU V0, V1, V0
9D000BBC  8FC40028   LW A0, 40(S8)
9D000BC0  00402821   ADDU A1, V0, ZERO
9D000BC4  0F400090   JAL 0x9D000240
9D000BC8  00000000   NOP
9D000BCC  AFC20010   SW V0, 16(S8)
886:                                 if (res != FR_OK) break;
9D000BD0  8FC20010   LW V0, 16(S8)
9D000BD4  14400064   BNE V0, ZERO, 0x9D000D68
9D000BD8  00000000   NOP
9D000D68  00000000   NOP
9D000D6C  0B40035E   J 0x9D000D78
9D000D70  00000000   NOP
887:                                 p = &fs->win[clst * 2 % SS(fs)];
9D000BDC  8FC20028   LW V0, 40(S8)
9D000BE0  24430034   ADDIU V1, V0, 52
9D000BE4  8FC2002C   LW V0, 44(S8)
9D000BE8  00021040   SLL V0, V0, 1
9D000BEC  304201FF   ANDI V0, V0, 511
9D000BF0  00621021   ADDU V0, V1, V0
9D000BF4  AFC20018   SW V0, 24(S8)
888:                                 ST_WORD(p, (WORD) val);
9D000BF8  8FC20030   LW V0, 48(S8)
9D000BFC  304300FF   ANDI V1, V0, 255
9D000C00  8FC20018   LW V0, 24(S8)
9D000C04  A0430000   SB V1, 0(V0)
9D000C08  8FC20018   LW V0, 24(S8)
9D000C0C  24420001   ADDIU V0, V0, 1
9D000C10  8FC30030   LW V1, 48(S8)
9D000C14  3063FFFF   ANDI V1, V1, -1
9D000C18  00031A02   SRL V1, V1, 8
9D000C1C  3063FFFF   ANDI V1, V1, -1
9D000C20  306300FF   ANDI V1, V1, 255
9D000C24  A0430000   SB V1, 0(V0)
889:                                 break;
9D000C28  0B40035E   J 0x9D000D78
9D000C2C  00000000   NOP
890:                 
891:                             case FS_FAT32:
892:                                 res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
9D000C30  8FC20028   LW V0, 40(S8)
9D000C34  8C430024   LW V1, 36(V0)
9D000C38  8FC2002C   LW V0, 44(S8)
9D000C3C  000211C2   SRL V0, V0, 7
9D000C40  00621021   ADDU V0, V1, V0
9D000C44  8FC40028   LW A0, 40(S8)
9D000C48  00402821   ADDU A1, V0, ZERO
9D000C4C  0F400090   JAL 0x9D000240
9D000C50  00000000   NOP
9D000C54  AFC20010   SW V0, 16(S8)
893:                                 if (res != FR_OK) break;
9D000C58  8FC20010   LW V0, 16(S8)
9D000C5C  14400045   BNE V0, ZERO, 0x9D000D74
9D000C60  00000000   NOP
9D000D74  00000000   NOP
894:                                 p = &fs->win[clst * 4 % SS(fs)];
9D000C64  8FC20028   LW V0, 40(S8)
9D000C68  24430034   ADDIU V1, V0, 52
9D000C6C  8FC2002C   LW V0, 44(S8)
9D000C70  00021080   SLL V0, V0, 2
9D000C74  304201FF   ANDI V0, V0, 511
9D000C78  00621021   ADDU V0, V1, V0
9D000C7C  AFC20018   SW V0, 24(S8)
895:                                 val |= LD_DWORD(p) & 0xF0000000;
9D000C80  8FC20018   LW V0, 24(S8)
9D000C84  24420003   ADDIU V0, V0, 3
9D000C88  90420000   LBU V0, 0(V0)
9D000C8C  00021E00   SLL V1, V0, 24
9D000C90  8FC20018   LW V0, 24(S8)
9D000C94  24420002   ADDIU V0, V0, 2
9D000C98  90420000   LBU V0, 0(V0)
9D000C9C  00021400   SLL V0, V0, 16
9D000CA0  00621825   OR V1, V1, V0
9D000CA4  8FC20018   LW V0, 24(S8)
9D000CA8  24420001   ADDIU V0, V0, 1
9D000CAC  90420000   LBU V0, 0(V0)
9D000CB0  00021200   SLL V0, V0, 8
9D000CB4  00621825   OR V1, V1, V0
9D000CB8  8FC20018   LW V0, 24(S8)
9D000CBC  90420000   LBU V0, 0(V0)
9D000CC0  00621825   OR V1, V1, V0
9D000CC4  3C02F000   LUI V0, -4096
9D000CC8  00621024   AND V0, V1, V0
9D000CCC  8FC30030   LW V1, 48(S8)
9D000CD0  00621025   OR V0, V1, V0
9D000CD4  AFC20030   SW V0, 48(S8)
896:                                 ST_DWORD(p, val);
9D000CD8  8FC20030   LW V0, 48(S8)
9D000CDC  304300FF   ANDI V1, V0, 255
9D000CE0  8FC20018   LW V0, 24(S8)
9D000CE4  A0430000   SB V1, 0(V0)
9D000CE8  8FC20018   LW V0, 24(S8)
9D000CEC  24420001   ADDIU V0, V0, 1
9D000CF0  8FC30030   LW V1, 48(S8)
9D000CF4  3063FFFF   ANDI V1, V1, -1
9D000CF8  00031A02   SRL V1, V1, 8
9D000CFC  3063FFFF   ANDI V1, V1, -1
9D000D00  306300FF   ANDI V1, V1, 255
9D000D04  A0430000   SB V1, 0(V0)
9D000D08  8FC20018   LW V0, 24(S8)
9D000D0C  24420002   ADDIU V0, V0, 2
9D000D10  8FC30030   LW V1, 48(S8)
9D000D14  00031C02   SRL V1, V1, 16
9D000D18  306300FF   ANDI V1, V1, 255
9D000D1C  A0430000   SB V1, 0(V0)
9D000D20  8FC20018   LW V0, 24(S8)
9D000D24  24420003   ADDIU V0, V0, 3
9D000D28  8FC30030   LW V1, 48(S8)
9D000D2C  00031E02   SRL V1, V1, 24
9D000D30  306300FF   ANDI V1, V1, 255
9D000D34  A0430000   SB V1, 0(V0)
897:                                 break;
9D000D38  0B40035E   J 0x9D000D78
9D000D3C  00000000   NOP
898:                 
899:                             default:
900:                                 res = FR_INT_ERR;
9D000D40  24020002   ADDIU V0, ZERO, 2
9D000D44  AFC20010   SW V0, 16(S8)
9D000D48  0B40035E   J 0x9D000D78
9D000D4C  00000000   NOP
901:                         }
902:                         fs->wflag = 1;
9D000D78  8FC20028   LW V0, 40(S8)
9D000D7C  24030001   ADDIU V1, ZERO, 1
9D000D80  A0430004   SB V1, 4(V0)
903:                     }
904:                 
905:                     return res;
9D000D84  8FC20010   LW V0, 16(S8)
906:                 }
9D000D88  03C0E821   ADDU SP, S8, ZERO
9D000D8C  8FBF0024   LW RA, 36(SP)
9D000D90  8FBE0020   LW S8, 32(SP)
9D000D94  27BD0028   ADDIU SP, SP, 40
9D000D98  03E00008   JR RA
9D000D9C  00000000   NOP
907:                 #endif /* !_FS_READONLY */
908:                 
909:                 
910:                 
911:                 
912:                 /*-----------------------------------------------------------------------*/
913:                 /* FAT handling - Remove a cluster chain                                 */
914:                 /*-----------------------------------------------------------------------*/
915:                 #if !_FS_READONLY
916:                 
917:                 static
918:                 FRESULT remove_chain(
919:                         FATFS *fs, /* File system object */
920:                         DWORD clst /* Cluster# to remove a chain from */
921:                         ) {
9D000DA0  27BDFFE0   ADDIU SP, SP, -32
9D000DA4  AFBF001C   SW RA, 28(SP)
9D000DA8  AFBE0018   SW S8, 24(SP)
9D000DAC  03A0F021   ADDU S8, SP, ZERO
9D000DB0  AFC40020   SW A0, 32(S8)
9D000DB4  AFC50024   SW A1, 36(S8)
922:                     FRESULT res;
923:                     DWORD nxt;
924:                 #if _USE_ERASE
925:                     DWORD scl = clst, ecl = clst, resion[2];
926:                 #endif
927:                 
928:                     if (clst < 2 || clst >= fs->n_fatent) { /* Check range */
9D000DB8  8FC20024   LW V0, 36(S8)
9D000DBC  2C420002   SLTIU V0, V0, 2
9D000DC0  14400007   BNE V0, ZERO, 0x9D000DE0
9D000DC4  00000000   NOP
9D000DC8  8FC20020   LW V0, 32(S8)
9D000DCC  8C43001C   LW V1, 28(V0)
9D000DD0  8FC20024   LW V0, 36(S8)
9D000DD4  0043102B   SLTU V0, V0, V1
9D000DD8  14400005   BNE V0, ZERO, 0x9D000DF0
9D000DDC  00000000   NOP
929:                         res = FR_INT_ERR;
9D000DE0  24020002   ADDIU V0, ZERO, 2
9D000DE4  AFC20010   SW V0, 16(S8)
9D000DE8  0B4003BB   J 0x9D000EEC
9D000DEC  00000000   NOP
930:                 
931:                     } else {
932:                         res = FR_OK;
9D000DF0  AFC00010   SW ZERO, 16(S8)
933:                         while (clst < fs->n_fatent) { /* Not a last link? */
9D000DF4  0B4003AF   J 0x9D000EBC
9D000DF8  00000000   NOP
9D000EBC  8FC20020   LW V0, 32(S8)
9D000EC0  8C43001C   LW V1, 28(V0)
9D000EC4  8FC20024   LW V0, 36(S8)
9D000EC8  0043102B   SLTU V0, V0, V1
9D000ECC  1440FFCB   BNE V0, ZERO, 0x9D000DFC
9D000ED0  00000000   NOP
9D000ED4  0B4003BB   J 0x9D000EEC
9D000ED8  00000000   NOP
934:                             nxt = get_fat(fs, clst); /* Get cluster status */
9D000DFC  8FC40020   LW A0, 32(S8)
9D000E00  8FC50024   LW A1, 36(S8)
9D000E04  0F4001B4   JAL get_fat
9D000E08  00000000   NOP
9D000E0C  AFC20014   SW V0, 20(S8)
935:                             if (nxt == 0) break; /* Empty cluster? */
9D000E10  8FC20014   LW V0, 20(S8)
9D000E14  10400031   BEQ V0, ZERO, 0x9D000EDC
9D000E18  00000000   NOP
9D000EDC  00000000   NOP
9D000EE0  0B4003BB   J 0x9D000EEC
9D000EE4  00000000   NOP
936:                             if (nxt == 1) {
9D000E1C  8FC30014   LW V1, 20(S8)
9D000E20  24020001   ADDIU V0, ZERO, 1
9D000E24  14620005   BNE V1, V0, 0x9D000E3C
9D000E28  00000000   NOP
937:                                 res = FR_INT_ERR;
9D000E2C  24020002   ADDIU V0, ZERO, 2
9D000E30  AFC20010   SW V0, 16(S8)
938:                                 break;
9D000E34  0B4003BB   J 0x9D000EEC
9D000E38  00000000   NOP
939:                             } /* Internal error? */
940:                             if (nxt == 0xFFFFFFFF) {
9D000E3C  8FC30014   LW V1, 20(S8)
9D000E40  2402FFFF   ADDIU V0, ZERO, -1
9D000E44  14620005   BNE V1, V0, 0x9D000E5C
9D000E48  00000000   NOP
941:                                 res = FR_DISK_ERR;
9D000E4C  24020001   ADDIU V0, ZERO, 1
9D000E50  AFC20010   SW V0, 16(S8)
942:                                 break;
9D000E54  0B4003BB   J 0x9D000EEC
9D000E58  00000000   NOP
943:                             } /* Disk error? */
944:                             res = put_fat(fs, clst, 0); /* Mark the cluster "empty" */
9D000E5C  8FC40020   LW A0, 32(S8)
9D000E60  8FC50024   LW A1, 36(S8)
9D000E64  00003021   ADDU A2, ZERO, ZERO
9D000E68  0F400264   JAL put_fat
9D000E6C  00000000   NOP
9D000E70  AFC20010   SW V0, 16(S8)
945:                             if (res != FR_OK) break;
9D000E74  8FC20010   LW V0, 16(S8)
9D000E78  1440001B   BNE V0, ZERO, 0x9D000EE8
9D000E7C  00000000   NOP
9D000EE8  00000000   NOP
946:                             if (fs->free_clust != 0xFFFFFFFF) { /* Update FSInfo */
9D000E80  8FC20020   LW V0, 32(S8)
9D000E84  8C430010   LW V1, 16(V0)
9D000E88  2402FFFF   ADDIU V0, ZERO, -1
9D000E8C  10620009   BEQ V1, V0, 0x9D000EB4
9D000E90  00000000   NOP
947:                                 fs->free_clust++;
9D000E94  8FC20020   LW V0, 32(S8)
9D000E98  8C420010   LW V0, 16(V0)
9D000E9C  24430001   ADDIU V1, V0, 1
9D000EA0  8FC20020   LW V0, 32(S8)
9D000EA4  AC430010   SW V1, 16(V0)
948:                                 fs->fsi_flag = 1;
9D000EA8  8FC20020   LW V0, 32(S8)
9D000EAC  24030001   ADDIU V1, ZERO, 1
9D000EB0  A0430005   SB V1, 5(V0)
949:                             }
950:                 #if _USE_ERASE
951:                             if (ecl + 1 == nxt) { /* Next cluster is contiguous */
952:                                 ecl = nxt;
953:                             } else { /* End of contiguous clusters */
954:                                 resion[0] = clust2sect(fs, scl); /* Start sector */
955:                                 resion[1] = clust2sect(fs, ecl) + fs->csize - 1; /* End sector */
956:                                 disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, resion); /* Erase the block */
957:                                 scl = ecl = nxt;
958:                             }
959:                 #endif
960:                             clst = nxt; /* Next cluster */
9D000EB4  8FC20014   LW V0, 20(S8)
9D000EB8  AFC20024   SW V0, 36(S8)
961:                         }
962:                     }
963:                 
964:                     return res;
9D000EEC  8FC20010   LW V0, 16(S8)
965:                 }
9D000EF0  03C0E821   ADDU SP, S8, ZERO
9D000EF4  8FBF001C   LW RA, 28(SP)
9D000EF8  8FBE0018   LW S8, 24(SP)
9D000EFC  27BD0020   ADDIU SP, SP, 32
9D000F00  03E00008   JR RA
9D000F04  00000000   NOP
966:                 #endif
967:                 
968:                 
969:                 
970:                 
971:                 /*-----------------------------------------------------------------------*/
972:                 /* FAT handling - Stretch or Create a cluster chain                      */
973:                 /*-----------------------------------------------------------------------*/
974:                 #if !_FS_READONLY
975:                 
976:                 static
977:                 DWORD create_chain(/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
978:                         FATFS *fs, /* File system object */
979:                         DWORD clst /* Cluster# to stretch. 0 means create a new chain. */
980:                         ) {
9D000F08  27BDFFD8   ADDIU SP, SP, -40
9D000F0C  AFBF0024   SW RA, 36(SP)
9D000F10  AFBE0020   SW S8, 32(SP)
9D000F14  03A0F021   ADDU S8, SP, ZERO
9D000F18  AFC40028   SW A0, 40(S8)
9D000F1C  AFC5002C   SW A1, 44(S8)
981:                     DWORD cs, ncl, scl;
982:                     FRESULT res;
983:                 
984:                 
985:                     if (clst == 0) { /* Create a new chain */
9D000F20  8FC2002C   LW V0, 44(S8)
9D000F24  14400011   BNE V0, ZERO, 0x9D000F6C
9D000F28  00000000   NOP
986:                         scl = fs->last_clust; /* Get suggested start point */
9D000F2C  8FC20028   LW V0, 40(S8)
9D000F30  8C42000C   LW V0, 12(V0)
9D000F34  AFC20014   SW V0, 20(S8)
987:                         if (!scl || scl >= fs->n_fatent) scl = 1;
9D000F38  8FC20014   LW V0, 20(S8)
9D000F3C  10400007   BEQ V0, ZERO, 0x9D000F5C
9D000F40  00000000   NOP
9D000F44  8FC20028   LW V0, 40(S8)
9D000F48  8C43001C   LW V1, 28(V0)
9D000F4C  8FC20014   LW V0, 20(S8)
9D000F50  0043102B   SLTU V0, V0, V1
9D000F54  1440001C   BNE V0, ZERO, 0x9D000FC8
9D000F58  00000000   NOP
9D000F5C  24020001   ADDIU V0, ZERO, 1
9D000F60  AFC20014   SW V0, 20(S8)
9D000F64  0B4003F2   J 0x9D000FC8
9D000F68  00000000   NOP
988:                     } else { /* Stretch the current chain */
989:                         cs = get_fat(fs, clst); /* Check the cluster status */
9D000F6C  8FC40028   LW A0, 40(S8)
9D000F70  8FC5002C   LW A1, 44(S8)
9D000F74  0F4001B4   JAL get_fat
9D000F78  00000000   NOP
9D000F7C  AFC2001C   SW V0, 28(S8)
990:                         if (cs < 2) return 1; /* It is an invalid cluster */
9D000F80  8FC2001C   LW V0, 28(S8)
9D000F84  2C420002   SLTIU V0, V0, 2
9D000F88  10400004   BEQ V0, ZERO, 0x9D000F9C
9D000F8C  00000000   NOP
9D000F90  24020001   ADDIU V0, ZERO, 1
9D000F94  0B400458   J 0x9D001160
9D000F98  00000000   NOP
991:                         if (cs < fs->n_fatent) return cs; /* It is already followed by next cluster */
9D000F9C  8FC20028   LW V0, 40(S8)
9D000FA0  8C43001C   LW V1, 28(V0)
9D000FA4  8FC2001C   LW V0, 28(S8)
9D000FA8  0043102B   SLTU V0, V0, V1
9D000FAC  10400004   BEQ V0, ZERO, 0x9D000FC0
9D000FB0  00000000   NOP
9D000FB4  8FC2001C   LW V0, 28(S8)
9D000FB8  0B400458   J 0x9D001160
9D000FBC  00000000   NOP
992:                         scl = clst;
9D000FC0  8FC2002C   LW V0, 44(S8)
9D000FC4  AFC20014   SW V0, 20(S8)
993:                     }
994:                 
995:                     ncl = scl; /* Start cluster */
9D000FC8  8FC20014   LW V0, 20(S8)
9D000FCC  AFC20010   SW V0, 16(S8)
9D000FD0  0B4003F7   J 0x9D000FDC
9D000FD4  00000000   NOP
996:                     for (;;) {
997:                         ncl++; /* Next cluster */
9D000FDC  8FC20010   LW V0, 16(S8)
9D000FE0  24420001   ADDIU V0, V0, 1
9D000FE4  AFC20010   SW V0, 16(S8)
998:                         if (ncl >= fs->n_fatent) { /* Wrap around */
9D000FE8  8FC20028   LW V0, 40(S8)
9D000FEC  8C43001C   LW V1, 28(V0)
9D000FF0  8FC20010   LW V0, 16(S8)
9D000FF4  0043102B   SLTU V0, V0, V1
9D000FF8  1440000B   BNE V0, ZERO, 0x9D001028
9D000FFC  00000000   NOP
999:                             ncl = 2;
9D001000  24020002   ADDIU V0, ZERO, 2
9D001004  AFC20010   SW V0, 16(S8)
1000:                            if (ncl > scl) return 0; /* No free cluster */
9D001008  8FC30010   LW V1, 16(S8)
9D00100C  8FC20014   LW V0, 20(S8)
9D001010  0043102B   SLTU V0, V0, V1
9D001014  10400004   BEQ V0, ZERO, 0x9D001028
9D001018  00000000   NOP
9D00101C  00001021   ADDU V0, ZERO, ZERO
9D001020  0B400458   J 0x9D001160
9D001024  00000000   NOP
1001:                        }
1002:                        cs = get_fat(fs, ncl); /* Get the cluster status */
9D001028  8FC40028   LW A0, 40(S8)
9D00102C  8FC50010   LW A1, 16(S8)
9D001030  0F4001B4   JAL get_fat
9D001034  00000000   NOP
9D001038  AFC2001C   SW V0, 28(S8)
1003:                        if (cs == 0) break; /* Found a free cluster */
9D00103C  8FC2001C   LW V0, 28(S8)
9D001040  1440000D   BNE V0, ZERO, 0x9D001078
9D001044  00000000   NOP
1004:                        if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
9D001078  8FC3001C   LW V1, 28(S8)
9D00107C  2402FFFF   ADDIU V0, ZERO, -1
9D001080  10620005   BEQ V1, V0, 0x9D001098
9D001084  00000000   NOP
9D001088  8FC3001C   LW V1, 28(S8)
9D00108C  24020001   ADDIU V0, ZERO, 1
9D001090  14620004   BNE V1, V0, 0x9D0010A4
9D001094  00000000   NOP
1005:                            return cs;
9D001098  8FC2001C   LW V0, 28(S8)
9D00109C  0B400458   J 0x9D001160
9D0010A0  00000000   NOP
1006:                        if (ncl == scl) return 0; /* No free cluster */
9D0010A4  8FC30010   LW V1, 16(S8)
9D0010A8  8FC20014   LW V0, 20(S8)
9D0010AC  1462FFCA   BNE V1, V0, 0x9D000FD8
9D0010B0  00000000   NOP
9D0010B4  00001021   ADDU V0, ZERO, ZERO
9D0010B8  0B400458   J 0x9D001160
9D0010BC  00000000   NOP
1007:                    }
9D000FD8  00000000   NOP
1008:                
1009:                    res = put_fat(fs, ncl, 0x0FFFFFFF); /* Mark the new cluster "last link" */
9D001048  8FC40028   LW A0, 40(S8)
9D00104C  8FC50010   LW A1, 16(S8)
9D001050  3C020FFF   LUI V0, 4095
9D001054  3446FFFF   ORI A2, V0, -1
9D001058  0F400264   JAL put_fat
9D00105C  00000000   NOP
9D001060  AFC20018   SW V0, 24(S8)
1010:                    if (res == FR_OK && clst != 0) {
9D001064  8FC20018   LW V0, 24(S8)
9D001068  10400015   BEQ V0, ZERO, 0x9D0010C0
9D00106C  00000000   NOP
9D001070  0B400439   J 0x9D0010E4
9D001074  00000000   NOP
9D0010C0  8FC2002C   LW V0, 44(S8)
9D0010C4  10400007   BEQ V0, ZERO, 0x9D0010E4
9D0010C8  00000000   NOP
1011:                        res = put_fat(fs, clst, ncl); /* Link it to the previous one if needed */
9D0010CC  8FC40028   LW A0, 40(S8)
9D0010D0  8FC5002C   LW A1, 44(S8)
9D0010D4  8FC60010   LW A2, 16(S8)
9D0010D8  0F400264   JAL put_fat
9D0010DC  00000000   NOP
9D0010E0  AFC20018   SW V0, 24(S8)
1012:                    }
1013:                    if (res == FR_OK) {
9D0010E4  8FC20018   LW V0, 24(S8)
9D0010E8  14400013   BNE V0, ZERO, 0x9D001138
9D0010EC  00000000   NOP
1014:                        fs->last_clust = ncl; /* Update FSINFO */
9D0010F0  8FC20028   LW V0, 40(S8)
9D0010F4  8FC30010   LW V1, 16(S8)
9D0010F8  AC43000C   SW V1, 12(V0)
1015:                        if (fs->free_clust != 0xFFFFFFFF) {
9D0010FC  8FC20028   LW V0, 40(S8)
9D001100  8C430010   LW V1, 16(V0)
9D001104  2402FFFF   ADDIU V0, ZERO, -1
9D001108  10620014   BEQ V1, V0, 0x9D00115C
9D00110C  00000000   NOP
1016:                            fs->free_clust--;
9D001110  8FC20028   LW V0, 40(S8)
9D001114  8C420010   LW V0, 16(V0)
9D001118  2443FFFF   ADDIU V1, V0, -1
9D00111C  8FC20028   LW V0, 40(S8)
9D001120  AC430010   SW V1, 16(V0)
1017:                            fs->fsi_flag = 1;
9D001124  8FC20028   LW V0, 40(S8)
9D001128  24030001   ADDIU V1, ZERO, 1
9D00112C  A0430005   SB V1, 5(V0)
9D001130  0B400457   J 0x9D00115C
9D001134  00000000   NOP
1018:                        }
1019:                    } else {
1020:                        ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
9D001138  8FC30018   LW V1, 24(S8)
9D00113C  24020001   ADDIU V0, ZERO, 1
9D001140  14620004   BNE V1, V0, 0x9D001154
9D001144  00000000   NOP
9D001148  2402FFFF   ADDIU V0, ZERO, -1
9D00114C  0B400456   J 0x9D001158
9D001150  00000000   NOP
9D001154  24020001   ADDIU V0, ZERO, 1
9D001158  AFC20010   SW V0, 16(S8)
1021:                    }
1022:                
1023:                    return ncl; /* Return new cluster number or error code */
9D00115C  8FC20010   LW V0, 16(S8)
1024:                }
9D001160  03C0E821   ADDU SP, S8, ZERO
9D001164  8FBF0024   LW RA, 36(SP)
9D001168  8FBE0020   LW S8, 32(SP)
9D00116C  27BD0028   ADDIU SP, SP, 40
9D001170  03E00008   JR RA
9D001174  00000000   NOP
1025:                #endif /* !_FS_READONLY */
1026:                
1027:                
1028:                
1029:                /*-----------------------------------------------------------------------*/
1030:                /* FAT handling - Convert offset into cluster with link map table        */
1031:                /*-----------------------------------------------------------------------*/
1032:                
1033:                #if _USE_FASTSEEK
1034:                
1035:                static
1036:                DWORD clmt_clust(/* <2:Error, >=2:Cluster number */
1037:                        FIL* fp, /* Pointer to the file object */
1038:                        DWORD ofs /* File offset to be converted to cluster# */
1039:                        ) {
1040:                    DWORD cl, ncl, *tbl;
1041:                
1042:                
1043:                    tbl = fp->cltbl + 1; /* Top of CLMT */
1044:                    cl = ofs / SS(fp->fs) / fp->fs->csize; /* Cluster order from top of the file */
1045:                    for (;;) {
1046:                        ncl = *tbl++; /* Number of cluters in the fragment */
1047:                        if (!ncl) return 0; /* End of table? (error) */
1048:                        if (cl < ncl) break; /* In this fragment? */
1049:                        cl -= ncl;
1050:                        tbl++; /* Next fragment */
1051:                    }
1052:                    return cl + *tbl; /* Return the cluster number */
1053:                }
1054:                #endif	/* _USE_FASTSEEK */
1055:                
1056:                
1057:                
1058:                /*-----------------------------------------------------------------------*/
1059:                /* Directory handling - Set directory index                              */
1060:                
1061:                /*-----------------------------------------------------------------------*/
1062:                
1063:                static
1064:                FRESULT dir_sdi(
1065:                        DIR *dj, /* Pointer to directory object */
1066:                        WORD idx /* Directory index number */
1067:                        ) {
9D001178  27BDFFE0   ADDIU SP, SP, -32
9D00117C  AFBF001C   SW RA, 28(SP)
9D001180  AFBE0018   SW S8, 24(SP)
9D001184  03A0F021   ADDU S8, SP, ZERO
9D001188  AFC40020   SW A0, 32(S8)
9D00118C  00A01021   ADDU V0, A1, ZERO
9D001190  A7C20024   SH V0, 36(S8)
1068:                    DWORD clst;
1069:                    WORD ic;
1070:                
1071:                
1072:                    dj->index = idx;
9D001194  8FC20020   LW V0, 32(S8)
9D001198  97C30024   LHU V1, 36(S8)
9D00119C  A4430006   SH V1, 6(V0)
1073:                    clst = dj->sclust;
9D0011A0  8FC20020   LW V0, 32(S8)
9D0011A4  8C420008   LW V0, 8(V0)
9D0011A8  AFC20010   SW V0, 16(S8)
1074:                    if (clst == 1 || clst >= dj->fs->n_fatent) /* Check start cluster range */
9D0011AC  8FC30010   LW V1, 16(S8)
9D0011B0  24020001   ADDIU V0, ZERO, 1
9D0011B4  10620008   BEQ V1, V0, 0x9D0011D8
9D0011B8  00000000   NOP
9D0011BC  8FC20020   LW V0, 32(S8)
9D0011C0  8C420000   LW V0, 0(V0)
9D0011C4  8C43001C   LW V1, 28(V0)
9D0011C8  8FC20010   LW V0, 16(S8)
9D0011CC  0043102B   SLTU V0, V0, V1
9D0011D0  14400004   BNE V0, ZERO, 0x9D0011E4
9D0011D4  00000000   NOP
1075:                        return FR_INT_ERR;
9D0011D8  24020002   ADDIU V0, ZERO, 2
9D0011DC  0B4004E7   J 0x9D00139C
9D0011E0  00000000   NOP
1076:                    if (!clst && dj->fs->fs_type == FS_FAT32) /* Replace cluster# 0 with root cluster# if in FAT32 */
9D0011E4  8FC20010   LW V0, 16(S8)
9D0011E8  1440000B   BNE V0, ZERO, 0x9D001218
9D0011EC  00000000   NOP
9D0011F0  8FC20020   LW V0, 32(S8)
9D0011F4  8C420000   LW V0, 0(V0)
9D0011F8  90430000   LBU V1, 0(V0)
9D0011FC  24020003   ADDIU V0, ZERO, 3
9D001200  14620005   BNE V1, V0, 0x9D001218
9D001204  00000000   NOP
1077:                        clst = dj->fs->dirbase;
9D001208  8FC20020   LW V0, 32(S8)
9D00120C  8C420000   LW V0, 0(V0)
9D001210  8C420028   LW V0, 40(V0)
9D001214  AFC20010   SW V0, 16(S8)
1078:                
1079:                    if (clst == 0) { /* Static table (root-dir in FAT12/16) */
9D001218  8FC20010   LW V0, 16(S8)
9D00121C  14400019   BNE V0, ZERO, 0x9D001284
9D001220  00000000   NOP
1080:                        dj->clust = clst;
9D001224  8FC20020   LW V0, 32(S8)
9D001228  8FC30010   LW V1, 16(S8)
9D00122C  AC43000C   SW V1, 12(V0)
1081:                        if (idx >= dj->fs->n_rootdir) /* Index is out of range */
9D001230  8FC20020   LW V0, 32(S8)
9D001234  8C420000   LW V0, 0(V0)
9D001238  94420008   LHU V0, 8(V0)
9D00123C  97C30024   LHU V1, 36(S8)
9D001240  0062102B   SLTU V0, V1, V0
9D001244  14400004   BNE V0, ZERO, 0x9D001258
9D001248  00000000   NOP
1082:                            return FR_INT_ERR;
9D00124C  24020002   ADDIU V0, ZERO, 2
9D001250  0B4004E7   J 0x9D00139C
9D001254  00000000   NOP
1083:                        dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR); /* Sector# */
9D001258  8FC20020   LW V0, 32(S8)
9D00125C  8C420000   LW V0, 0(V0)
9D001260  8C430028   LW V1, 40(V0)
9D001264  97C20024   LHU V0, 36(S8)
9D001268  00021102   SRL V0, V0, 4
9D00126C  3042FFFF   ANDI V0, V0, -1
9D001270  00621821   ADDU V1, V1, V0
9D001274  8FC20020   LW V0, 32(S8)
9D001278  AC430010   SW V1, 16(V0)
9D00127C  0B4004DD   J 0x9D001374
9D001280  00000000   NOP
1084:                    } else { /* Dynamic table (sub-dirs or root-dir in FAT32) */
1085:                        ic = SS(dj->fs) / SZ_DIR * dj->fs->csize; /* Entries per cluster */
9D001284  8FC20020   LW V0, 32(S8)
9D001288  8C420000   LW V0, 0(V0)
9D00128C  90420002   LBU V0, 2(V0)
9D001290  00021100   SLL V0, V0, 4
9D001294  A7C20014   SH V0, 20(S8)
1086:                        while (idx >= ic) { /* Follow cluster chain */
9D001298  0B4004C8   J 0x9D001320
9D00129C  00000000   NOP
9D001320  97C30024   LHU V1, 36(S8)
9D001324  97C20014   LHU V0, 20(S8)
9D001328  0062102B   SLTU V0, V1, V0
9D00132C  1040FFDC   BEQ V0, ZERO, 0x9D0012A0
9D001330  00000000   NOP
1087:                            clst = get_fat(dj->fs, clst); /* Get next cluster */
9D0012A0  8FC20020   LW V0, 32(S8)
9D0012A4  8C420000   LW V0, 0(V0)
9D0012A8  00402021   ADDU A0, V0, ZERO
9D0012AC  8FC50010   LW A1, 16(S8)
9D0012B0  0F4001B4   JAL get_fat
9D0012B4  00000000   NOP
9D0012B8  AFC20010   SW V0, 16(S8)
1088:                            if (clst == 0xFFFFFFFF) return FR_DISK_ERR; /* Disk error */
9D0012BC  8FC30010   LW V1, 16(S8)
9D0012C0  2402FFFF   ADDIU V0, ZERO, -1
9D0012C4  14620004   BNE V1, V0, 0x9D0012D8
9D0012C8  00000000   NOP
9D0012CC  24020001   ADDIU V0, ZERO, 1
9D0012D0  0B4004E7   J 0x9D00139C
9D0012D4  00000000   NOP
1089:                            if (clst < 2 || clst >= dj->fs->n_fatent) /* Reached to end of table or int error */
9D0012D8  8FC20010   LW V0, 16(S8)
9D0012DC  2C420002   SLTIU V0, V0, 2
9D0012E0  14400008   BNE V0, ZERO, 0x9D001304
9D0012E4  00000000   NOP
9D0012E8  8FC20020   LW V0, 32(S8)
9D0012EC  8C420000   LW V0, 0(V0)
9D0012F0  8C43001C   LW V1, 28(V0)
9D0012F4  8FC20010   LW V0, 16(S8)
9D0012F8  0043102B   SLTU V0, V0, V1
9D0012FC  14400004   BNE V0, ZERO, 0x9D001310
9D001300  00000000   NOP
1090:                                return FR_INT_ERR;
9D001304  24020002   ADDIU V0, ZERO, 2
9D001308  0B4004E7   J 0x9D00139C
9D00130C  00000000   NOP
1091:                            idx -= ic;
9D001310  97C30024   LHU V1, 36(S8)
9D001314  97C20014   LHU V0, 20(S8)
9D001318  00621023   SUBU V0, V1, V0
9D00131C  A7C20024   SH V0, 36(S8)
1092:                        }
1093:                        dj->clust = clst;
9D001334  8FC20020   LW V0, 32(S8)
9D001338  8FC30010   LW V1, 16(S8)
9D00133C  AC43000C   SW V1, 12(V0)
1094:                        dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR); /* Sector# */
9D001340  8FC20020   LW V0, 32(S8)
9D001344  8C420000   LW V0, 0(V0)
9D001348  00402021   ADDU A0, V0, ZERO
9D00134C  8FC50010   LW A1, 16(S8)
9D001350  0F400195   JAL clust2sect
9D001354  00000000   NOP
9D001358  00401821   ADDU V1, V0, ZERO
9D00135C  97C20024   LHU V0, 36(S8)
9D001360  00021102   SRL V0, V0, 4
9D001364  3042FFFF   ANDI V0, V0, -1
9D001368  00621821   ADDU V1, V1, V0
9D00136C  8FC20020   LW V0, 32(S8)
9D001370  AC430010   SW V1, 16(V0)
1095:                    }
1096:                
1097:                    dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR; /* Ptr to the entry in the sector */
9D001374  8FC20020   LW V0, 32(S8)
9D001378  8C420000   LW V0, 0(V0)
9D00137C  24430034   ADDIU V1, V0, 52
9D001380  97C20024   LHU V0, 36(S8)
9D001384  3042000F   ANDI V0, V0, 15
9D001388  00021140   SLL V0, V0, 5
9D00138C  00621821   ADDU V1, V1, V0
9D001390  8FC20020   LW V0, 32(S8)
9D001394  AC430014   SW V1, 20(V0)
1098:                
1099:                    return FR_OK; /* Seek succeeded */
9D001398  00001021   ADDU V0, ZERO, ZERO
1100:                }
9D00139C  03C0E821   ADDU SP, S8, ZERO
9D0013A0  8FBF001C   LW RA, 28(SP)
9D0013A4  8FBE0018   LW S8, 24(SP)
9D0013A8  27BD0020   ADDIU SP, SP, 32
9D0013AC  03E00008   JR RA
9D0013B0  00000000   NOP
1101:                
1102:                
1103:                
1104:                
1105:                /*-----------------------------------------------------------------------*/
1106:                /* Directory handling - Move directory index next                        */
1107:                
1108:                /*-----------------------------------------------------------------------*/
1109:                
1110:                static
1111:                FRESULT dir_next(/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
1112:                        DIR *dj, /* Pointer to directory object */
1113:                        int stretch /* 0: Do not stretch table, 1: Stretch table if needed */
1114:                        ) {
9D0013B4  27BDFFD8   ADDIU SP, SP, -40
9D0013B8  AFBF0024   SW RA, 36(SP)
9D0013BC  AFBE0020   SW S8, 32(SP)
9D0013C0  AFB0001C   SW S0, 28(SP)
9D0013C4  03A0F021   ADDU S8, SP, ZERO
9D0013C8  AFC40028   SW A0, 40(S8)
9D0013CC  AFC5002C   SW A1, 44(S8)
1115:                    DWORD clst;
1116:                    WORD i;
1117:                
1118:                
1119:                    stretch = stretch; /* To suppress warning on read-only cfg. */
1120:                    i = dj->index + 1;
9D0013D0  8FC20028   LW V0, 40(S8)
9D0013D4  94420006   LHU V0, 6(V0)
9D0013D8  24420001   ADDIU V0, V0, 1
9D0013DC  A7C20016   SH V0, 22(S8)
1121:                    if (!i || !dj->sect) /* Report EOT when index has reached 65535 */
9D0013E0  97C20016   LHU V0, 22(S8)
9D0013E4  10400005   BEQ V0, ZERO, 0x9D0013FC
9D0013E8  00000000   NOP
9D0013EC  8FC20028   LW V0, 40(S8)
9D0013F0  8C420010   LW V0, 16(V0)
9D0013F4  14400004   BNE V0, ZERO, 0x9D001408
9D0013F8  00000000   NOP
1122:                        return FR_NO_FILE;
9D0013FC  24020004   ADDIU V0, ZERO, 4
9D001400  0B4005C4   J 0x9D001710
9D001404  00000000   NOP
1123:                
1124:                    if (!(i % (SS(dj->fs) / SZ_DIR))) { /* Sector changed? */
9D001408  97C20016   LHU V0, 22(S8)
9D00140C  3042000F   ANDI V0, V0, 15
9D001410  3042FFFF   ANDI V0, V0, -1
9D001414  144000B1   BNE V0, ZERO, 0x9D0016DC
9D001418  00000000   NOP
1125:                        dj->sect++; /* Next sector */
9D00141C  8FC20028   LW V0, 40(S8)
9D001420  8C420010   LW V0, 16(V0)
9D001424  24430001   ADDIU V1, V0, 1
9D001428  8FC20028   LW V0, 40(S8)
9D00142C  AC430010   SW V1, 16(V0)
1126:                
1127:                        if (dj->clust == 0) { /* Static table */
9D001430  8FC20028   LW V0, 40(S8)
9D001434  8C42000C   LW V0, 12(V0)
9D001438  1440000B   BNE V0, ZERO, 0x9D001468
9D00143C  00000000   NOP
1128:                            if (i >= dj->fs->n_rootdir) /* Report EOT when end of table */
9D001440  8FC20028   LW V0, 40(S8)
9D001444  8C420000   LW V0, 0(V0)
9D001448  94420008   LHU V0, 8(V0)
9D00144C  97C30016   LHU V1, 22(S8)
9D001450  0062102B   SLTU V0, V1, V0
9D001454  144000A1   BNE V0, ZERO, 0x9D0016DC
9D001458  00000000   NOP
1129:                                return FR_NO_FILE;
9D00145C  24020004   ADDIU V0, ZERO, 4
9D001460  0B4005C4   J 0x9D001710
9D001464  00000000   NOP
1130:                        } else { /* Dynamic table */
1131:                            if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) { /* Cluster changed? */
9D001468  97C20016   LHU V0, 22(S8)
9D00146C  00021102   SRL V0, V0, 4
9D001470  3042FFFF   ANDI V0, V0, -1
9D001474  00401821   ADDU V1, V0, ZERO
9D001478  8FC20028   LW V0, 40(S8)
9D00147C  8C420000   LW V0, 0(V0)
9D001480  90420002   LBU V0, 2(V0)
9D001484  2442FFFF   ADDIU V0, V0, -1
9D001488  00621024   AND V0, V1, V0
9D00148C  14400093   BNE V0, ZERO, 0x9D0016DC
9D001490  00000000   NOP
1132:                                clst = get_fat(dj->fs, dj->clust); /* Get next cluster */
9D001494  8FC20028   LW V0, 40(S8)
9D001498  8C430000   LW V1, 0(V0)
9D00149C  8FC20028   LW V0, 40(S8)
9D0014A0  8C42000C   LW V0, 12(V0)
9D0014A4  00602021   ADDU A0, V1, ZERO
9D0014A8  00402821   ADDU A1, V0, ZERO
9D0014AC  0F4001B4   JAL get_fat
9D0014B0  00000000   NOP
9D0014B4  AFC20010   SW V0, 16(S8)
1133:                                if (clst <= 1) return FR_INT_ERR;
9D0014B8  8FC20010   LW V0, 16(S8)
9D0014BC  2C420002   SLTIU V0, V0, 2
9D0014C0  10400004   BEQ V0, ZERO, 0x9D0014D4
9D0014C4  00000000   NOP
9D0014C8  24020002   ADDIU V0, ZERO, 2
9D0014CC  0B4005C4   J 0x9D001710
9D0014D0  00000000   NOP
1134:                                if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
9D0014D4  8FC30010   LW V1, 16(S8)
9D0014D8  2402FFFF   ADDIU V0, ZERO, -1
9D0014DC  14620004   BNE V1, V0, 0x9D0014F0
9D0014E0  00000000   NOP
9D0014E4  24020001   ADDIU V0, ZERO, 1
9D0014E8  0B4005C4   J 0x9D001710
9D0014EC  00000000   NOP
1135:                                if (clst >= dj->fs->n_fatent) { /* When it reached end of dynamic table */
9D0014F0  8FC20028   LW V0, 40(S8)
9D0014F4  8C420000   LW V0, 0(V0)
9D0014F8  8C43001C   LW V1, 28(V0)
9D0014FC  8FC20010   LW V0, 16(S8)
9D001500  0043102B   SLTU V0, V0, V1
9D001504  14400069   BNE V0, ZERO, 0x9D0016AC
9D001508  00000000   NOP
1136:                #if !_FS_READONLY
1137:                                    BYTE c;
1138:                                    if (!stretch) return FR_NO_FILE; /* When do not stretch, report EOT */
9D00150C  8FC2002C   LW V0, 44(S8)
9D001510  14400004   BNE V0, ZERO, 0x9D001524
9D001514  00000000   NOP
9D001518  24020004   ADDIU V0, ZERO, 4
9D00151C  0B4005C4   J 0x9D001710
9D001520  00000000   NOP
1139:                                    clst = create_chain(dj->fs, dj->clust); /* Stretch cluster chain */
9D001524  8FC20028   LW V0, 40(S8)
9D001528  8C430000   LW V1, 0(V0)
9D00152C  8FC20028   LW V0, 40(S8)
9D001530  8C42000C   LW V0, 12(V0)
9D001534  00602021   ADDU A0, V1, ZERO
9D001538  00402821   ADDU A1, V0, ZERO
9D00153C  0F4003C2   JAL 0x9D000F08
9D001540  00000000   NOP
9D001544  AFC20010   SW V0, 16(S8)
1140:                                    if (clst == 0) return FR_DENIED; /* No free cluster */
9D001548  8FC20010   LW V0, 16(S8)
9D00154C  14400004   BNE V0, ZERO, 0x9D001560
9D001550  00000000   NOP
9D001554  24020007   ADDIU V0, ZERO, 7
9D001558  0B4005C4   J 0x9D001710
9D00155C  00000000   NOP
1141:                                    if (clst == 1) return FR_INT_ERR;
9D001560  8FC30010   LW V1, 16(S8)
9D001564  24020001   ADDIU V0, ZERO, 1
9D001568  14620004   BNE V1, V0, 0x9D00157C
9D00156C  00000000   NOP
9D001570  24020002   ADDIU V0, ZERO, 2
9D001574  0B4005C4   J 0x9D001710
9D001578  00000000   NOP
1142:                                    if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
9D00157C  8FC30010   LW V1, 16(S8)
9D001580  2402FFFF   ADDIU V0, ZERO, -1
9D001584  14620004   BNE V1, V0, 0x9D001598
9D001588  00000000   NOP
9D00158C  24020001   ADDIU V0, ZERO, 1
9D001590  0B4005C4   J 0x9D001710
9D001594  00000000   NOP
1143:                                    /* Clean-up stretched table */
1144:                                    if (move_window(dj->fs, 0)) return FR_DISK_ERR; /* Flush active window */
9D001598  8FC20028   LW V0, 40(S8)
9D00159C  8C420000   LW V0, 0(V0)
9D0015A0  00402021   ADDU A0, V0, ZERO
9D0015A4  00002821   ADDU A1, ZERO, ZERO
9D0015A8  0F400090   JAL 0x9D000240
9D0015AC  00000000   NOP
9D0015B0  10400004   BEQ V0, ZERO, 0x9D0015C4
9D0015B4  00000000   NOP
9D0015B8  24020001   ADDIU V0, ZERO, 1
9D0015BC  0B4005C4   J 0x9D001710
9D0015C0  00000000   NOP
1145:                                    mem_set(dj->fs->win, 0, SS(dj->fs)); /* Clear window buffer */
9D0015C4  8FC20028   LW V0, 40(S8)
9D0015C8  8C420000   LW V0, 0(V0)
9D0015CC  24420034   ADDIU V0, V0, 52
9D0015D0  00402021   ADDU A0, V0, ZERO
9D0015D4  00002821   ADDU A1, ZERO, ZERO
9D0015D8  24060200   ADDIU A2, ZERO, 512
9D0015DC  0F40002B   JAL 0x9D0000AC
9D0015E0  00000000   NOP
1146:                                    dj->fs->winsect = clust2sect(dj->fs, clst); /* Cluster start sector */
9D0015E4  8FC20028   LW V0, 40(S8)
9D0015E8  8C500000   LW S0, 0(V0)
9D0015EC  8FC20028   LW V0, 40(S8)
9D0015F0  8C420000   LW V0, 0(V0)
9D0015F4  00402021   ADDU A0, V0, ZERO
9D0015F8  8FC50010   LW A1, 16(S8)
9D0015FC  0F400195   JAL clust2sect
9D001600  00000000   NOP
9D001604  AE020030   SW V0, 48(S0)
1147:                                    for (c = 0; c < dj->fs->csize; c++) { /* Fill the new cluster with 0 */
9D001608  A3C00014   SB ZERO, 20(S8)
9D00160C  0B40059C   J 0x9D001670
9D001610  00000000   NOP
9D001664  93C20014   LBU V0, 20(S8)
9D001668  24420001   ADDIU V0, V0, 1
9D00166C  A3C20014   SB V0, 20(S8)
9D001670  8FC20028   LW V0, 40(S8)
9D001674  8C420000   LW V0, 0(V0)
9D001678  90420002   LBU V0, 2(V0)
9D00167C  93C30014   LBU V1, 20(S8)
9D001680  0062102B   SLTU V0, V1, V0
9D001684  1440FFE3   BNE V0, ZERO, 0x9D001614
9D001688  00000000   NOP
1148:                                        dj->fs->wflag = 1;
9D001614  8FC20028   LW V0, 40(S8)
9D001618  8C420000   LW V0, 0(V0)
9D00161C  24030001   ADDIU V1, ZERO, 1
9D001620  A0430004   SB V1, 4(V0)
1149:                                        if (move_window(dj->fs, 0)) return FR_DISK_ERR;
9D001624  8FC20028   LW V0, 40(S8)
9D001628  8C420000   LW V0, 0(V0)
9D00162C  00402021   ADDU A0, V0, ZERO
9D001630  00002821   ADDU A1, ZERO, ZERO
9D001634  0F400090   JAL 0x9D000240
9D001638  00000000   NOP
9D00163C  10400004   BEQ V0, ZERO, 0x9D001650
9D001640  00000000   NOP
9D001644  24020001   ADDIU V0, ZERO, 1
9D001648  0B4005C4   J 0x9D001710
9D00164C  00000000   NOP
1150:                                        dj->fs->winsect++;
9D001650  8FC20028   LW V0, 40(S8)
9D001654  8C420000   LW V0, 0(V0)
9D001658  8C430030   LW V1, 48(V0)
9D00165C  24630001   ADDIU V1, V1, 1
9D001660  AC430030   SW V1, 48(V0)
1151:                                    }
1152:                                    dj->fs->winsect -= c; /* Rewind window address */
9D00168C  8FC20028   LW V0, 40(S8)
9D001690  8C420000   LW V0, 0(V0)
9D001694  8FC30028   LW V1, 40(S8)
9D001698  8C630000   LW V1, 0(V1)
9D00169C  8C640030   LW A0, 48(V1)
9D0016A0  93C30014   LBU V1, 20(S8)
9D0016A4  00831823   SUBU V1, A0, V1
9D0016A8  AC430030   SW V1, 48(V0)
1153:                #else
1154:                                    return FR_NO_FILE; /* Report EOT */
1155:                #endif
1156:                                }
1157:                                dj->clust = clst; /* Initialize data for new cluster */
9D0016AC  8FC20028   LW V0, 40(S8)
9D0016B0  8FC30010   LW V1, 16(S8)
9D0016B4  AC43000C   SW V1, 12(V0)
1158:                                dj->sect = clust2sect(dj->fs, clst);
9D0016B8  8FC20028   LW V0, 40(S8)
9D0016BC  8C420000   LW V0, 0(V0)
9D0016C0  00402021   ADDU A0, V0, ZERO
9D0016C4  8FC50010   LW A1, 16(S8)
9D0016C8  0F400195   JAL clust2sect
9D0016CC  00000000   NOP
9D0016D0  00401821   ADDU V1, V0, ZERO
9D0016D4  8FC20028   LW V0, 40(S8)
9D0016D8  AC430010   SW V1, 16(V0)
1159:                            }
1160:                        }
1161:                    }
1162:                
1163:                    dj->index = i;
9D0016DC  8FC20028   LW V0, 40(S8)
9D0016E0  97C30016   LHU V1, 22(S8)
9D0016E4  A4430006   SH V1, 6(V0)
1164:                    dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
9D0016E8  8FC20028   LW V0, 40(S8)
9D0016EC  8C420000   LW V0, 0(V0)
9D0016F0  24430034   ADDIU V1, V0, 52
9D0016F4  97C20016   LHU V0, 22(S8)
9D0016F8  3042000F   ANDI V0, V0, 15
9D0016FC  00021140   SLL V0, V0, 5
9D001700  00621821   ADDU V1, V1, V0
9D001704  8FC20028   LW V0, 40(S8)
9D001708  AC430014   SW V1, 20(V0)
1165:                
1166:                    return FR_OK;
9D00170C  00001021   ADDU V0, ZERO, ZERO
1167:                }
9D001710  03C0E821   ADDU SP, S8, ZERO
9D001714  8FBF0024   LW RA, 36(SP)
9D001718  8FBE0020   LW S8, 32(SP)
9D00171C  8FB0001C   LW S0, 28(SP)
9D001720  27BD0028   ADDIU SP, SP, 40
9D001724  03E00008   JR RA
9D001728  00000000   NOP
1168:                
1169:                
1170:                
1171:                
1172:                /*-----------------------------------------------------------------------*/
1173:                /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
1174:                /*-----------------------------------------------------------------------*/
1175:                #if _USE_LFN
1176:                static
1177:                const BYTE LfnOfs[] = {1, 3, 5, 7, 9, 14, 16, 18, 20, 22, 24, 28, 30}; /* Offset of LFN chars in the directory entry */
1178:                
1179:                static
1180:                int cmp_lfn(/* 1:Matched, 0:Not matched */
1181:                        WCHAR *lfnbuf, /* Pointer to the LFN to be compared */
1182:                        BYTE *dir /* Pointer to the directory entry containing a part of LFN */
1183:                        ) {
1184:                    UINT i, s;
1185:                    WCHAR wc, uc;
1186:                
1187:                
1188:                    i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13; /* Get offset in the LFN buffer */
1189:                    s = 0;
1190:                    wc = 1;
1191:                    do {
1192:                        uc = LD_WORD(dir + LfnOfs[s]); /* Pick an LFN character from the entry */
1193:                        if (wc) { /* Last char has not been processed */
1194:                            wc = ff_wtoupper(uc); /* Convert it to upper case */
1195:                            if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++])) /* Compare it */
1196:                                return 0; /* Not matched */
1197:                        } else {
1198:                            if (uc != 0xFFFF) return 0; /* Check filler */
1199:                        }
1200:                    } while (++s < 13); /* Repeat until all chars in the entry are checked */
1201:                
1202:                    if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i]) /* Last segment matched but different length */
1203:                        return 0;
1204:                
1205:                    return 1; /* The part of LFN matched */
1206:                }
1207:                
1208:                static
1209:                int pick_lfn(/* 1:Succeeded, 0:Buffer overflow */
1210:                        WCHAR *lfnbuf, /* Pointer to the Unicode-LFN buffer */
1211:                        BYTE *dir /* Pointer to the directory entry */
1212:                        ) {
1213:                    UINT i, s;
1214:                    WCHAR wc, uc;
1215:                
1216:                
1217:                    i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13; /* Offset in the LFN buffer */
1218:                
1219:                    s = 0;
1220:                    wc = 1;
1221:                    do {
1222:                        uc = LD_WORD(dir + LfnOfs[s]); /* Pick an LFN character from the entry */
1223:                        if (wc) { /* Last char has not been processed */
1224:                            if (i >= _MAX_LFN) return 0; /* Buffer overflow? */
1225:                            lfnbuf[i++] = wc = uc; /* Store it */
1226:                        } else {
1227:                            if (uc != 0xFFFF) return 0; /* Check filler */
1228:                        }
1229:                    } while (++s < 13); /* Read all character in the entry */
1230:                
1231:                    if (dir[LDIR_Ord] & LLE) { /* Put terminator if it is the last LFN part */
1232:                        if (i >= _MAX_LFN) return 0; /* Buffer overflow? */
1233:                        lfnbuf[i] = 0;
1234:                    }
1235:                
1236:                    return 1;
1237:                }
1238:                
1239:                
1240:                #if !_FS_READONLY
1241:                
1242:                static
1243:                void fit_lfn(
1244:                        const WCHAR *lfnbuf, /* Pointer to the LFN buffer */
1245:                        BYTE *dir, /* Pointer to the directory entry */
1246:                        BYTE ord, /* LFN order (1-20) */
1247:                        BYTE sum /* SFN sum */
1248:                        ) {
1249:                    UINT i, s;
1250:                    WCHAR wc;
1251:                
1252:                
1253:                    dir[LDIR_Chksum] = sum; /* Set check sum */
1254:                    dir[LDIR_Attr] = AM_LFN; /* Set attribute. LFN entry */
1255:                    dir[LDIR_Type] = 0;
1256:                    ST_WORD(dir + LDIR_FstClusLO, 0);
1257:                
1258:                    i = (ord - 1) * 13; /* Get offset in the LFN buffer */
1259:                    s = wc = 0;
1260:                    do {
1261:                        if (wc != 0xFFFF) wc = lfnbuf[i++]; /* Get an effective char */
1262:                        ST_WORD(dir + LfnOfs[s], wc); /* Put it */
1263:                        if (!wc) wc = 0xFFFF; /* Padding chars following last char */
1264:                    } while (++s < 13);
1265:                    if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE; /* Bottom LFN part is the start of LFN sequence */
1266:                    dir[LDIR_Ord] = ord; /* Set the LFN order */
1267:                }
1268:                
1269:                #endif
1270:                #endif
1271:                
1272:                
1273:                
1274:                /*-----------------------------------------------------------------------*/
1275:                /* Create numbered name                                                  */
1276:                /*-----------------------------------------------------------------------*/
1277:                #if _USE_LFN
1278:                
1279:                void gen_numname(
1280:                        BYTE *dst, /* Pointer to generated SFN */
1281:                        const BYTE *src, /* Pointer to source SFN to be modified */
1282:                        const WCHAR *lfn, /* Pointer to LFN */
1283:                        WORD seq /* Sequence number */
1284:                        ) {
1285:                    BYTE ns[8], c;
1286:                    UINT i, j;
1287:                
1288:                
1289:                    mem_cpy(dst, src, 11);
1290:                
1291:                    if (seq > 5) { /* On many collisions, generate a hash number instead of sequential number */
1292:                        do seq = (seq >> 1) + (seq << 15) + (WORD) * lfn++; while (*lfn);
1293:                    }
1294:                
1295:                    /* itoa (hexdecimal) */
1296:                    i = 7;
1297:                    do {
1298:                        c = (seq % 16) + '0';
1299:                        if (c > '9') c += 7;
1300:                        ns[i--] = c;
1301:                        seq /= 16;
1302:                    } while (seq);
1303:                    ns[i] = '~';
1304:                
1305:                    /* Append the number */
1306:                    for (j = 0; j < i && dst[j] != ' '; j++) {
1307:                        if (IsDBCS1(dst[j])) {
1308:                            if (j == i - 1) break;
1309:                            j++;
1310:                        }
1311:                    }
1312:                    do {
1313:                        dst[j++] = (i < 8) ? ns[i++] : ' ';
1314:                    } while (j < 8);
1315:                }
1316:                #endif
1317:                
1318:                
1319:                
1320:                
1321:                /*-----------------------------------------------------------------------*/
1322:                /* Calculate sum of an SFN                                               */
1323:                /*-----------------------------------------------------------------------*/
1324:                #if _USE_LFN
1325:                
1326:                static
1327:                BYTE sum_sfn(
1328:                        const BYTE *dir /* Ptr to directory entry */
1329:                        ) {
1330:                    BYTE sum = 0;
1331:                    UINT n = 11;
1332:                
1333:                    do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
1334:                    return sum;
1335:                }
1336:                #endif
1337:                
1338:                
1339:                
1340:                
1341:                /*-----------------------------------------------------------------------*/
1342:                /* Directory handling - Find an object in the directory                  */
1343:                
1344:                /*-----------------------------------------------------------------------*/
1345:                
1346:                static
1347:                FRESULT dir_find(
1348:                        DIR *dj /* Pointer to the directory object linked to the file name */
1349:                        ) {
9D00172C  27BDFFD8   ADDIU SP, SP, -40
9D001730  AFBF0024   SW RA, 36(SP)
9D001734  AFBE0020   SW S8, 32(SP)
9D001738  03A0F021   ADDU S8, SP, ZERO
9D00173C  AFC40028   SW A0, 40(S8)
1350:                    FRESULT res;
1351:                    BYTE c, *dir;
1352:                #if _USE_LFN
1353:                    BYTE a, ord, sum;
1354:                #endif
1355:                
1356:                    res = dir_sdi(dj, 0); /* Rewind directory object */
9D001740  8FC40028   LW A0, 40(S8)
9D001744  00002821   ADDU A1, ZERO, ZERO
9D001748  0F40045E   JAL 0x9D001178
9D00174C  00000000   NOP
9D001750  AFC20010   SW V0, 16(S8)
1357:                    if (res != FR_OK) return res;
9D001754  8FC20010   LW V0, 16(S8)
9D001758  10400004   BEQ V0, ZERO, 0x9D00176C
9D00175C  00000000   NOP
9D001760  8FC20010   LW V0, 16(S8)
9D001764  0B400612   J 0x9D001848
9D001768  00000000   NOP
1358:                
1359:                #if _USE_LFN
1360:                    ord = sum = 0xFF;
1361:                #endif
1362:                    do {
1363:                        res = move_window(dj->fs, dj->sect);
9D00176C  8FC20028   LW V0, 40(S8)
9D001770  8C430000   LW V1, 0(V0)
9D001774  8FC20028   LW V0, 40(S8)
9D001778  8C420010   LW V0, 16(V0)
9D00177C  00602021   ADDU A0, V1, ZERO
9D001780  00402821   ADDU A1, V0, ZERO
9D001784  0F400090   JAL 0x9D000240
9D001788  00000000   NOP
9D00178C  AFC20010   SW V0, 16(S8)
1364:                        if (res != FR_OK) break;
9D001790  8FC20010   LW V0, 16(S8)
9D001794  14400027   BNE V0, ZERO, 0x9D001834
9D001798  00000000   NOP
9D001834  00000000   NOP
9D001838  0B400611   J 0x9D001844
9D00183C  00000000   NOP
1365:                        dir = dj->dir; /* Ptr to the directory entry of current index */
9D00179C  8FC20028   LW V0, 40(S8)
9D0017A0  8C420014   LW V0, 20(V0)
9D0017A4  AFC20014   SW V0, 20(S8)
1366:                        c = dir[DIR_Name];
9D0017A8  8FC20014   LW V0, 20(S8)
9D0017AC  90420000   LBU V0, 0(V0)
9D0017B0  A3C20018   SB V0, 24(S8)
1367:                        if (c == 0) {
9D0017B4  93C20018   LBU V0, 24(S8)
9D0017B8  14400005   BNE V0, ZERO, 0x9D0017D0
9D0017BC  00000000   NOP
1368:                            res = FR_NO_FILE;
9D0017C0  24020004   ADDIU V0, ZERO, 4
9D0017C4  AFC20010   SW V0, 16(S8)
1369:                            break;
9D0017C8  0B400611   J 0x9D001844
9D0017CC  00000000   NOP
1370:                        } /* Reached to end of table */
1371:                #if _USE_LFN	/* LFN configuration */
1372:                        a = dir[DIR_Attr] & AM_MASK;
1373:                        if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) { /* An entry without valid data */
1374:                            ord = 0xFF;
1375:                        } else {
1376:                            if (a == AM_LFN) { /* An LFN entry is found */
1377:                                if (dj->lfn) {
1378:                                    if (c & LLE) { /* Is it start of LFN sequence? */
1379:                                        sum = dir[LDIR_Chksum];
1380:                                        c &= ~LLE;
1381:                                        ord = c; /* LFN start order */
1382:                                        dj->lfn_idx = dj->index;
1383:                                    }
1384:                                    /* Check validity of the LFN entry and compare it with given name */
1385:                                    ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
1386:                                }
1387:                            } else { /* An SFN entry is found */
1388:                                if (!ord && sum == sum_sfn(dir)) break; /* LFN matched? */
1389:                                ord = 0xFF;
1390:                                dj->lfn_idx = 0xFFFF; /* Reset LFN sequence */
1391:                                if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break; /* SFN matched? */
1392:                            }
1393:                        }
1394:                #else		/* Non LFN configuration */
1395:                        if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
9D0017D0  8FC20014   LW V0, 20(S8)
9D0017D4  2442000B   ADDIU V0, V0, 11
9D0017D8  90420000   LBU V0, 0(V0)
9D0017DC  30420008   ANDI V0, V0, 8
9D0017E0  1440000A   BNE V0, ZERO, 0x9D00180C
9D0017E4  00000000   NOP
9D0017E8  8FC20028   LW V0, 40(S8)
9D0017EC  8C420018   LW V0, 24(V0)
9D0017F0  8FC40014   LW A0, 20(S8)
9D0017F4  00402821   ADDU A1, V0, ZERO
9D0017F8  2406000B   ADDIU A2, ZERO, 11
9D0017FC  0F400049   JAL 0x9D000124
9D001800  00000000   NOP
9D001804  1040000E   BEQ V0, ZERO, 0x9D001840
9D001808  00000000   NOP
1396:                            break;
9D001840  00000000   NOP
1397:                #endif
1398:                        res = dir_next(dj, 0); /* Next entry */
9D00180C  8FC40028   LW A0, 40(S8)
9D001810  00002821   ADDU A1, ZERO, ZERO
9D001814  0F4004ED   JAL 0x9D0013B4
9D001818  00000000   NOP
9D00181C  AFC20010   SW V0, 16(S8)
1399:                    } while (res == FR_OK);
9D001820  8FC20010   LW V0, 16(S8)
9D001824  1040FFD1   BEQ V0, ZERO, 0x9D00176C
9D001828  00000000   NOP
9D00182C  0B400611   J 0x9D001844
9D001830  00000000   NOP
1400:                
1401:                    return res;
9D001844  8FC20010   LW V0, 16(S8)
1402:                }
9D001848  03C0E821   ADDU SP, S8, ZERO
9D00184C  8FBF0024   LW RA, 36(SP)
9D001850  8FBE0020   LW S8, 32(SP)
9D001854  27BD0028   ADDIU SP, SP, 40
9D001858  03E00008   JR RA
9D00185C  00000000   NOP
1403:                
1404:                
1405:                
1406:                
1407:                /*-----------------------------------------------------------------------*/
1408:                /* Read an object from the directory                                     */
1409:                /*-----------------------------------------------------------------------*/
1410:                #if _FS_MINIMIZE <= 1
1411:                
1412:                static
1413:                FRESULT dir_read(
1414:                        DIR *dj /* Pointer to the directory object that pointing the entry to be read */
1415:                        ) {
9D001860  27BDFFD8   ADDIU SP, SP, -40
9D001864  AFBF0024   SW RA, 36(SP)
9D001868  AFBE0020   SW S8, 32(SP)
9D00186C  03A0F021   ADDU S8, SP, ZERO
9D001870  AFC40028   SW A0, 40(S8)
1416:                    FRESULT res;
1417:                    BYTE c, *dir;
1418:                #if _USE_LFN
1419:                    BYTE a, ord = 0xFF, sum = 0xFF;
1420:                #endif
1421:                
1422:                    res = FR_NO_FILE;
9D001874  24020004   ADDIU V0, ZERO, 4
9D001878  AFC20010   SW V0, 16(S8)
1423:                    while (dj->sect) {
9D00187C  0B40064C   J 0x9D001930
9D001880  00000000   NOP
9D001930  8FC20028   LW V0, 40(S8)
9D001934  8C420010   LW V0, 16(V0)
9D001938  1440FFD2   BNE V0, ZERO, 0x9D001884
9D00193C  00000000   NOP
9D001940  0B400659   J 0x9D001964
9D001944  00000000   NOP
1424:                        res = move_window(dj->fs, dj->sect);
9D001884  8FC20028   LW V0, 40(S8)
9D001888  8C430000   LW V1, 0(V0)
9D00188C  8FC20028   LW V0, 40(S8)
9D001890  8C420010   LW V0, 16(V0)
9D001894  00602021   ADDU A0, V1, ZERO
9D001898  00402821   ADDU A1, V0, ZERO
9D00189C  0F400090   JAL 0x9D000240
9D0018A0  00000000   NOP
9D0018A4  AFC20010   SW V0, 16(S8)
1425:                        if (res != FR_OK) break;
9D0018A8  8FC20010   LW V0, 16(S8)
9D0018AC  14400026   BNE V0, ZERO, 0x9D001948
9D0018B0  00000000   NOP
9D001948  00000000   NOP
9D00194C  0B400659   J 0x9D001964
9D001950  00000000   NOP
1426:                        dir = dj->dir; /* Ptr to the directory entry of current index */
9D0018B4  8FC20028   LW V0, 40(S8)
9D0018B8  8C420014   LW V0, 20(V0)
9D0018BC  AFC20014   SW V0, 20(S8)
1427:                        c = dir[DIR_Name];
9D0018C0  8FC20014   LW V0, 20(S8)
9D0018C4  90420000   LBU V0, 0(V0)
9D0018C8  A3C20018   SB V0, 24(S8)
1428:                        if (c == 0) {
9D0018CC  93C20018   LBU V0, 24(S8)
9D0018D0  14400005   BNE V0, ZERO, 0x9D0018E8
9D0018D4  00000000   NOP
1429:                            res = FR_NO_FILE;
9D0018D8  24020004   ADDIU V0, ZERO, 4
9D0018DC  AFC20010   SW V0, 16(S8)
1430:                            break;
9D0018E0  0B400659   J 0x9D001964
9D0018E4  00000000   NOP
1431:                        } /* Reached to end of table */
1432:                #if _USE_LFN	/* LFN configuration */
1433:                        a = dir[DIR_Attr] & AM_MASK;
1434:                        if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) { /* An entry without valid data */
1435:                            ord = 0xFF;
1436:                        } else {
1437:                            if (a == AM_LFN) { /* An LFN entry is found */
1438:                                if (c & LLE) { /* Is it start of LFN sequence? */
1439:                                    sum = dir[LDIR_Chksum];
1440:                                    c &= ~LLE;
1441:                                    ord = c;
1442:                                    dj->lfn_idx = dj->index;
1443:                                }
1444:                                /* Check LFN validity and capture it */
1445:                                ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
1446:                            } else { /* An SFN entry is found */
1447:                                if (ord || sum != sum_sfn(dir)) /* Is there a valid LFN? */
1448:                                    dj->lfn_idx = 0xFFFF; /* It has no LFN. */
1449:                                break;
1450:                            }
1451:                        }
1452:                #else		/* Non LFN configuration */
1453:                        if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL)) /* Is it a valid entry? */
9D0018E8  93C30018   LBU V1, 24(S8)
9D0018EC  240200E5   ADDIU V0, ZERO, 229
9D0018F0  10620007   BEQ V1, V0, 0x9D001910
9D0018F4  00000000   NOP
9D0018F8  8FC20014   LW V0, 20(S8)
9D0018FC  2442000B   ADDIU V0, V0, 11
9D001900  90420000   LBU V0, 0(V0)
9D001904  30420008   ANDI V0, V0, 8
9D001908  10400012   BEQ V0, ZERO, 0x9D001954
9D00190C  00000000   NOP
1454:                            break;
9D001954  00000000   NOP
9D001958  0B400659   J 0x9D001964
9D00195C  00000000   NOP
1455:                #endif
1456:                        res = dir_next(dj, 0); /* Next entry */
9D001910  8FC40028   LW A0, 40(S8)
9D001914  00002821   ADDU A1, ZERO, ZERO
9D001918  0F4004ED   JAL 0x9D0013B4
9D00191C  00000000   NOP
9D001920  AFC20010   SW V0, 16(S8)
1457:                        if (res != FR_OK) break;
9D001924  8FC20010   LW V0, 16(S8)
9D001928  1440000D   BNE V0, ZERO, 0x9D001960
9D00192C  00000000   NOP
9D001960  00000000   NOP
1458:                    }
1459:                
1460:                    if (res != FR_OK) dj->sect = 0;
9D001964  8FC20010   LW V0, 16(S8)
9D001968  10400003   BEQ V0, ZERO, 0x9D001978
9D00196C  00000000   NOP
9D001970  8FC20028   LW V0, 40(S8)
9D001974  AC400010   SW ZERO, 16(V0)
1461:                
1462:                    return res;
9D001978  8FC20010   LW V0, 16(S8)
1463:                }
9D00197C  03C0E821   ADDU SP, S8, ZERO
9D001980  8FBF0024   LW RA, 36(SP)
9D001984  8FBE0020   LW S8, 32(SP)
9D001988  27BD0028   ADDIU SP, SP, 40
9D00198C  03E00008   JR RA
9D001990  00000000   NOP
1464:                #endif
1465:                
1466:                
1467:                
1468:                /*-----------------------------------------------------------------------*/
1469:                /* Register an object to the directory                                   */
1470:                /*-----------------------------------------------------------------------*/
1471:                #if !_FS_READONLY
1472:                
1473:                static
1474:                FRESULT dir_register(/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
1475:                        DIR *dj /* Target directory with object name to be created */
1476:                        ) {
9D001994  27BDFFD8   ADDIU SP, SP, -40
9D001998  AFBF0024   SW RA, 36(SP)
9D00199C  AFBE0020   SW S8, 32(SP)
9D0019A0  03A0F021   ADDU S8, SP, ZERO
9D0019A4  AFC40028   SW A0, 40(S8)
1477:                    FRESULT res;
1478:                    BYTE c, *dir;
1479:                #if _USE_LFN	/* LFN configuration */
1480:                    WORD n, ne, is;
1481:                    BYTE sn[12], *fn, sum;
1482:                    WCHAR *lfn;
1483:                
1484:                
1485:                    fn = dj->fn;
1486:                    lfn = dj->lfn;
1487:                    mem_cpy(sn, fn, 12);
1488:                
1489:                    if (_FS_RPATH && (sn[NS] & NS_DOT)) /* Cannot create dot entry */
1490:                        return FR_INVALID_NAME;
1491:                
1492:                    if (sn[NS] & NS_LOSS) { /* When LFN is out of 8.3 format, generate a numbered name */
1493:                        fn[NS] = 0;
1494:                        dj->lfn = 0; /* Find only SFN */
1495:                        for (n = 1; n < 100; n++) {
1496:                            gen_numname(fn, sn, lfn, n); /* Generate a numbered name */
1497:                            res = dir_find(dj); /* Check if the name collides with existing SFN */
1498:                            if (res != FR_OK) break;
1499:                        }
1500:                        if (n == 100) return FR_DENIED; /* Abort if too many collisions */
1501:                        if (res != FR_NO_FILE) return res; /* Abort if the result is other than 'not collided' */
1502:                        fn[NS] = sn[NS];
1503:                        dj->lfn = lfn;
1504:                    }
1505:                
1506:                    if (sn[NS] & NS_LFN) { /* When LFN is to be created, reserve an SFN + LFN entries. */
1507:                        for (ne = 0; lfn[ne]; ne++);
1508:                        ne = (ne + 25) / 13;
1509:                    } else { /* Otherwise reserve only an SFN entry. */
1510:                        ne = 1;
1511:                    }
1512:                
1513:                    /* Reserve contiguous entries */
1514:                    res = dir_sdi(dj, 0);
1515:                    if (res != FR_OK) return res;
1516:                    n = is = 0;
1517:                    do {
1518:                        res = move_window(dj->fs, dj->sect);
1519:                        if (res != FR_OK) break;
1520:                        c = *dj->dir; /* Check the entry status */
1521:                        if (c == DDE || c == 0) { /* Is it a blank entry? */
1522:                            if (n == 0) is = dj->index; /* First index of the contiguous entry */
1523:                            if (++n == ne) break; /* A contiguous entry that required count is found */
1524:                        } else {
1525:                            n = 0; /* Not a blank entry. Restart to search */
1526:                        }
1527:                        res = dir_next(dj, 1); /* Next entry with table stretch */
1528:                    } while (res == FR_OK);
1529:                
1530:                    if (res == FR_OK && ne > 1) { /* Initialize LFN entry if needed */
1531:                        res = dir_sdi(dj, is);
1532:                        if (res == FR_OK) {
1533:                            sum = sum_sfn(dj->fn); /* Sum of the SFN tied to the LFN */
1534:                            ne--;
1535:                            do { /* Store LFN entries in bottom first */
1536:                                res = move_window(dj->fs, dj->sect);
1537:                                if (res != FR_OK) break;
1538:                                fit_lfn(dj->lfn, dj->dir, (BYTE) ne, sum);
1539:                                dj->fs->wflag = 1;
1540:                                res = dir_next(dj, 0); /* Next entry */
1541:                            } while (res == FR_OK && --ne);
1542:                        }
1543:                    }
1544:                
1545:                #else	/* Non LFN configuration */
1546:                    res = dir_sdi(dj, 0);
9D0019A8  8FC40028   LW A0, 40(S8)
9D0019AC  00002821   ADDU A1, ZERO, ZERO
9D0019B0  0F40045E   JAL 0x9D001178
9D0019B4  00000000   NOP
9D0019B8  AFC20010   SW V0, 16(S8)
1547:                    if (res == FR_OK) {
9D0019BC  8FC20010   LW V0, 16(S8)
9D0019C0  14400023   BNE V0, ZERO, 0x9D001A50
9D0019C4  00000000   NOP
1548:                        do { /* Find a blank entry for the SFN */
1549:                            res = move_window(dj->fs, dj->sect);
9D0019C8  8FC20028   LW V0, 40(S8)
9D0019CC  8C430000   LW V1, 0(V0)
9D0019D0  8FC20028   LW V0, 40(S8)
9D0019D4  8C420010   LW V0, 16(V0)
9D0019D8  00602021   ADDU A0, V1, ZERO
9D0019DC  00402821   ADDU A1, V0, ZERO
9D0019E0  0F400090   JAL 0x9D000240
9D0019E4  00000000   NOP
9D0019E8  AFC20010   SW V0, 16(S8)
1550:                            if (res != FR_OK) break;
9D0019EC  8FC20010   LW V0, 16(S8)
9D0019F0  14400016   BNE V0, ZERO, 0x9D001A4C
9D0019F4  00000000   NOP
9D001A4C  00000000   NOP
1551:                            c = *dj->dir;
9D0019F8  8FC20028   LW V0, 40(S8)
9D0019FC  8C420014   LW V0, 20(V0)
9D001A00  90420000   LBU V0, 0(V0)
9D001A04  A3C20014   SB V0, 20(S8)
1552:                            if (c == DDE || c == 0) break; /* Is it a blank entry? */
9D001A08  93C30014   LBU V1, 20(S8)
9D001A0C  240200E5   ADDIU V0, ZERO, 229
9D001A10  1062000F   BEQ V1, V0, 0x9D001A50
9D001A14  00000000   NOP
9D001A18  93C20014   LBU V0, 20(S8)
9D001A1C  1040000C   BEQ V0, ZERO, 0x9D001A50
9D001A20  00000000   NOP
1553:                            res = dir_next(dj, 1); /* Next entry with table stretch */
9D001A24  8FC40028   LW A0, 40(S8)
9D001A28  24050001   ADDIU A1, ZERO, 1
9D001A2C  0F4004ED   JAL 0x9D0013B4
9D001A30  00000000   NOP
9D001A34  AFC20010   SW V0, 16(S8)
1554:                        } while (res == FR_OK);
9D001A38  8FC20010   LW V0, 16(S8)
9D001A3C  1040FFE2   BEQ V0, ZERO, 0x9D0019C8
9D001A40  00000000   NOP
9D001A44  0B400694   J 0x9D001A50
9D001A48  00000000   NOP
1555:                    }
1556:                #endif
1557:                
1558:                    if (res == FR_OK) { /* Initialize the SFN entry */
9D001A50  8FC20010   LW V0, 16(S8)
9D001A54  14400020   BNE V0, ZERO, 0x9D001AD8
9D001A58  00000000   NOP
1559:                        res = move_window(dj->fs, dj->sect);
9D001A5C  8FC20028   LW V0, 40(S8)
9D001A60  8C430000   LW V1, 0(V0)
9D001A64  8FC20028   LW V0, 40(S8)
9D001A68  8C420010   LW V0, 16(V0)
9D001A6C  00602021   ADDU A0, V1, ZERO
9D001A70  00402821   ADDU A1, V0, ZERO
9D001A74  0F400090   JAL 0x9D000240
9D001A78  00000000   NOP
9D001A7C  AFC20010   SW V0, 16(S8)
1560:                        if (res == FR_OK) {
9D001A80  8FC20010   LW V0, 16(S8)
9D001A84  14400014   BNE V0, ZERO, 0x9D001AD8
9D001A88  00000000   NOP
1561:                            dir = dj->dir;
9D001A8C  8FC20028   LW V0, 40(S8)
9D001A90  8C420014   LW V0, 20(V0)
9D001A94  AFC20018   SW V0, 24(S8)
1562:                            mem_set(dir, 0, SZ_DIR); /* Clean the entry */
9D001A98  8FC40018   LW A0, 24(S8)
9D001A9C  00002821   ADDU A1, ZERO, ZERO
9D001AA0  24060020   ADDIU A2, ZERO, 32
9D001AA4  0F40002B   JAL 0x9D0000AC
9D001AA8  00000000   NOP
1563:                            mem_cpy(dir, dj->fn, 11); /* Put SFN */
9D001AAC  8FC20028   LW V0, 40(S8)
9D001AB0  8C420018   LW V0, 24(V0)
9D001AB4  8FC40018   LW A0, 24(S8)
9D001AB8  00402821   ADDU A1, V0, ZERO
9D001ABC  2406000B   ADDIU A2, ZERO, 11
9D001AC0  0F400008   JAL 0x9D000020
9D001AC4  00000000   NOP
1564:                #if _USE_LFN
1565:                            dir[DIR_NTres] = *(dj->fn + NS) & (NS_BODY | NS_EXT); /* Put NT flag */
1566:                #endif
1567:                            dj->fs->wflag = 1;
9D001AC8  8FC20028   LW V0, 40(S8)
9D001ACC  8C420000   LW V0, 0(V0)
9D001AD0  24030001   ADDIU V1, ZERO, 1
9D001AD4  A0430004   SB V1, 4(V0)
1568:                        }
1569:                    }
1570:                
1571:                    return res;
9D001AD8  8FC20010   LW V0, 16(S8)
1572:                }
9D001ADC  03C0E821   ADDU SP, S8, ZERO
9D001AE0  8FBF0024   LW RA, 36(SP)
9D001AE4  8FBE0020   LW S8, 32(SP)
9D001AE8  27BD0028   ADDIU SP, SP, 40
9D001AEC  03E00008   JR RA
9D001AF0  00000000   NOP
1573:                #endif /* !_FS_READONLY */
1574:                
1575:                
1576:                
1577:                
1578:                /*-----------------------------------------------------------------------*/
1579:                /* Remove an object from the directory                                   */
1580:                /*-----------------------------------------------------------------------*/
1581:                #if !_FS_READONLY && !_FS_MINIMIZE
1582:                
1583:                static
1584:                FRESULT dir_remove(/* FR_OK: Successful, FR_DISK_ERR: A disk error */
1585:                        DIR *dj /* Directory object pointing the entry to be removed */
1586:                        ) {
9D001AF4  27BDFFE0   ADDIU SP, SP, -32
9D001AF8  AFBF001C   SW RA, 28(SP)
9D001AFC  AFBE0018   SW S8, 24(SP)
9D001B00  03A0F021   ADDU S8, SP, ZERO
9D001B04  AFC40020   SW A0, 32(S8)
1587:                    FRESULT res;
1588:                #if _USE_LFN	/* LFN configuration */
1589:                    WORD i;
1590:                
1591:                    i = dj->index; /* SFN index */
1592:                    res = dir_sdi(dj, (WORD) ((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx)); /* Goto the SFN or top of the LFN entries */
1593:                    if (res == FR_OK) {
1594:                        do {
1595:                            res = move_window(dj->fs, dj->sect);
1596:                            if (res != FR_OK) break;
1597:                            *dj->dir = DDE; /* Mark the entry "deleted" */
1598:                            dj->fs->wflag = 1;
1599:                            if (dj->index >= i) break; /* When reached SFN, all entries of the object has been deleted. */
1600:                            res = dir_next(dj, 0); /* Next entry */
1601:                        } while (res == FR_OK);
1602:                        if (res == FR_NO_FILE) res = FR_INT_ERR;
1603:                    }
1604:                
1605:                #else			/* Non LFN configuration */
1606:                    res = dir_sdi(dj, dj->index);
9D001B08  8FC20020   LW V0, 32(S8)
9D001B0C  94420006   LHU V0, 6(V0)
9D001B10  8FC40020   LW A0, 32(S8)
9D001B14  00402821   ADDU A1, V0, ZERO
9D001B18  0F40045E   JAL 0x9D001178
9D001B1C  00000000   NOP
9D001B20  AFC20010   SW V0, 16(S8)
1607:                    if (res == FR_OK) {
9D001B24  8FC20010   LW V0, 16(S8)
9D001B28  14400015   BNE V0, ZERO, 0x9D001B80
9D001B2C  00000000   NOP
1608:                        res = move_window(dj->fs, dj->sect);
9D001B30  8FC20020   LW V0, 32(S8)
9D001B34  8C430000   LW V1, 0(V0)
9D001B38  8FC20020   LW V0, 32(S8)
9D001B3C  8C420010   LW V0, 16(V0)
9D001B40  00602021   ADDU A0, V1, ZERO
9D001B44  00402821   ADDU A1, V0, ZERO
9D001B48  0F400090   JAL 0x9D000240
9D001B4C  00000000   NOP
9D001B50  AFC20010   SW V0, 16(S8)
1609:                        if (res == FR_OK) {
9D001B54  8FC20010   LW V0, 16(S8)
9D001B58  14400009   BNE V0, ZERO, 0x9D001B80
9D001B5C  00000000   NOP
1610:                            *dj->dir = DDE; /* Mark the entry "deleted" */
9D001B60  8FC20020   LW V0, 32(S8)
9D001B64  8C420014   LW V0, 20(V0)
9D001B68  2403FFE5   ADDIU V1, ZERO, -27
9D001B6C  A0430000   SB V1, 0(V0)
1611:                            dj->fs->wflag = 1;
9D001B70  8FC20020   LW V0, 32(S8)
9D001B74  8C420000   LW V0, 0(V0)
9D001B78  24030001   ADDIU V1, ZERO, 1
9D001B7C  A0430004   SB V1, 4(V0)
1612:                        }
1613:                    }
1614:                #endif
1615:                
1616:                    return res;
9D001B80  8FC20010   LW V0, 16(S8)
1617:                }
9D001B84  03C0E821   ADDU SP, S8, ZERO
9D001B88  8FBF001C   LW RA, 28(SP)
9D001B8C  8FBE0018   LW S8, 24(SP)
9D001B90  27BD0020   ADDIU SP, SP, 32
9D001B94  03E00008   JR RA
9D001B98  00000000   NOP
1618:                #endif /* !_FS_READONLY */
1619:                
1620:                
1621:                
1622:                
1623:                /*-----------------------------------------------------------------------*/
1624:                /* Pick a segment and create the object name in directory form           */
1625:                
1626:                /*-----------------------------------------------------------------------*/
1627:                
1628:                static
1629:                FRESULT create_name(
1630:                        DIR *dj, /* Pointer to the directory object */
1631:                        const TCHAR **path /* Pointer to pointer to the segment in the path string */
1632:                        ) {
9D001B9C  27BDFFD0   ADDIU SP, SP, -48
9D001BA0  AFBF002C   SW RA, 44(SP)
9D001BA4  AFBE0028   SW S8, 40(SP)
9D001BA8  03A0F021   ADDU S8, SP, ZERO
9D001BAC  AFC40030   SW A0, 48(S8)
9D001BB0  AFC50034   SW A1, 52(S8)
1633:                #ifdef _EXCVT
1634:                    static const BYTE excvt[] = _EXCVT; /* Upper conversion table for extended chars */
1635:                #endif
1636:                
1637:                #if _USE_LFN	/* LFN configuration */
1638:                    BYTE b, cf;
1639:                    WCHAR w, *lfn;
1640:                    UINT i, ni, si, di;
1641:                    const TCHAR *p;
1642:                
1643:                    /* Create LFN in Unicode */
1644:                    for (p = *path; *p == '/' || *p == '\\'; p++); /* Strip duplicated separator */
1645:                    lfn = dj->lfn;
1646:                    si = di = 0;
1647:                    for (;;) {
1648:                        w = p[si++]; /* Get a character */
1649:                        if (w < ' ' || w == '/' || w == '\\') break; /* Break on end of segment */
1650:                        if (di >= _MAX_LFN) /* Reject too long name */
1651:                            return FR_INVALID_NAME;
1652:                #if !_LFN_UNICODE
1653:                        w &= 0xFF;
1654:                        if (IsDBCS1(w)) { /* Check if it is a DBC 1st byte (always false on SBCS cfg) */
1655:                            b = (BYTE) p[si++]; /* Get 2nd byte */
1656:                            if (!IsDBCS2(b))
1657:                                return FR_INVALID_NAME; /* Reject invalid sequence */
1658:                            w = (w << 8) + b; /* Create a DBC */
1659:                        }
1660:                        w = ff_convert(w, 1); /* Convert ANSI/OEM to Unicode */
1661:                        if (!w) return FR_INVALID_NAME; /* Reject invalid code */
1662:                #endif
1663:                        if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
1664:                            return FR_INVALID_NAME;
1665:                        lfn[di++] = w; /* Store the Unicode char */
1666:                    }
1667:                    *path = &p[si]; /* Return pointer to the next segment */
1668:                    cf = (w < ' ') ? NS_LAST : 0; /* Set last segment flag if end of path */
1669:                #if _FS_RPATH
1670:                    if ((di == 1 && lfn[di - 1] == '.') || /* Is this a dot entry? */
1671:                            (di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {
1672:                        lfn[di] = 0;
1673:                        for (i = 0; i < 11; i++)
1674:                            dj->fn[i] = (i < di) ? '.' : ' ';
1675:                        dj->fn[i] = cf | NS_DOT; /* This is a dot entry */
1676:                        return FR_OK;
1677:                    }
1678:                #endif
1679:                    while (di) { /* Strip trailing spaces and dots */
1680:                        w = lfn[di - 1];
1681:                        if (w != ' ' && w != '.') break;
1682:                        di--;
1683:                    }
1684:                    if (!di) return FR_INVALID_NAME; /* Reject nul string */
1685:                
1686:                    lfn[di] = 0; /* LFN is created */
1687:                
1688:                    /* Create SFN in directory form */
1689:                    mem_set(dj->fn, ' ', 11);
1690:                    for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++); /* Strip leading spaces and dots */
1691:                    if (si) cf |= NS_LOSS | NS_LFN;
1692:                    while (di && lfn[di - 1] != '.') di--; /* Find extension (di<=si: no extension) */
1693:                
1694:                    b = i = 0;
1695:                    ni = 8;
1696:                    for (;;) {
1697:                        w = lfn[si++]; /* Get an LFN char */
1698:                        if (!w) break; /* Break on end of the LFN */
1699:                        if (w == ' ' || (w == '.' && si != di)) { /* Remove spaces and dots */
1700:                            cf |= NS_LOSS | NS_LFN;
1701:                            continue;
1702:                        }
1703:                
1704:                        if (i >= ni || si == di) { /* Extension or end of SFN */
1705:                            if (ni == 11) { /* Long extension */
1706:                                cf |= NS_LOSS | NS_LFN;
1707:                                break;
1708:                            }
1709:                            if (si != di) cf |= NS_LOSS | NS_LFN; /* Out of 8.3 format */
1710:                            if (si > di) break; /* No extension */
1711:                            si = di;
1712:                            i = 8;
1713:                            ni = 11; /* Enter extension section */
1714:                            b <<= 2;
1715:                            continue;
1716:                        }
1717:                
1718:                        if (w >= 0x80) { /* Non ASCII char */
1719:                #ifdef _EXCVT
1720:                            w = ff_convert(w, 0); /* Unicode -> OEM code */
1721:                            if (w) w = excvt[w - 0x80]; /* Convert extended char to upper (SBCS) */
1722:                #else
1723:                            w = ff_convert(ff_wtoupper(w), 0); /* Upper converted Unicode -> OEM code */
1724:                #endif
1725:                            cf |= NS_LFN; /* Force create LFN entry */
1726:                        }
1727:                
1728:                        if (_DF1S && w >= 0x100) { /* Double byte char (always false on SBCS cfg) */
1729:                            if (i >= ni - 1) {
1730:                                cf |= NS_LOSS | NS_LFN;
1731:                                i = ni;
1732:                                continue;
1733:                            }
1734:                            dj->fn[i++] = (BYTE) (w >> 8);
1735:                        } else { /* Single byte char */
1736:                            if (!w || chk_chr("+,;=[]", w)) { /* Replace illegal chars for SFN */
1737:                                w = '_';
1738:                                cf |= NS_LOSS | NS_LFN; /* Lossy conversion */
1739:                            } else {
1740:                                if (IsUpper(w)) { /* ASCII large capital */
1741:                                    b |= 2;
1742:                                } else {
1743:                                    if (IsLower(w)) { /* ASCII small capital */
1744:                                        b |= 1;
1745:                                        w -= 0x20;
1746:                                    }
1747:                                }
1748:                            }
1749:                        }
1750:                        dj->fn[i++] = (BYTE) w;
1751:                    }
1752:                
1753:                    if (dj->fn[0] == DDE) dj->fn[0] = NDDE; /* If the first char collides with deleted mark, replace it with 0x05 */
1754:                
1755:                    if (ni == 8) b <<= 2;
1756:                    if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) /* Create LFN entry when there are composite capitals */
1757:                        cf |= NS_LFN;
1758:                    if (!(cf & NS_LFN)) { /* When LFN is in 8.3 format without extended char, NT flags are created */
1759:                        if ((b & 0x03) == 0x01) cf |= NS_EXT; /* NT flag (Extension has only small capital) */
1760:                        if ((b & 0x0C) == 0x04) cf |= NS_BODY; /* NT flag (Filename has only small capital) */
1761:                    }
1762:                
1763:                    dj->fn[NS] = cf; /* SFN is created */
1764:                
1765:                    return FR_OK;
1766:                
1767:                
1768:                #else	/* Non-LFN configuration */
1769:                    BYTE b, c, d, *sfn;
1770:                    UINT ni, si, i;
1771:                    const char *p;
1772:                
1773:                    /* Create file name in directory form */
1774:                    for (p = *path; *p == '/' || *p == '\\'; p++); /* Strip duplicated separator */
9D001BB4  8FC20034   LW V0, 52(S8)
9D001BB8  8C420000   LW V0, 0(V0)
9D001BBC  AFC20020   SW V0, 32(S8)
9D001BC0  0B4006F5   J 0x9D001BD4
9D001BC4  00000000   NOP
9D001BC8  8FC20020   LW V0, 32(S8)
9D001BCC  24420001   ADDIU V0, V0, 1
9D001BD0  AFC20020   SW V0, 32(S8)
9D001BD4  8FC20020   LW V0, 32(S8)
9D001BD8  80430000   LB V1, 0(V0)
9D001BDC  2402002F   ADDIU V0, ZERO, 47
9D001BE0  1062FFF9   BEQ V1, V0, 0x9D001BC8
9D001BE4  00000000   NOP
9D001BE8  8FC20020   LW V0, 32(S8)
9D001BEC  80430000   LB V1, 0(V0)
9D001BF0  2402005C   ADDIU V0, ZERO, 92
9D001BF4  1062FFF4   BEQ V1, V0, 0x9D001BC8
9D001BF8  00000000   NOP
1775:                    sfn = dj->fn;
9D001BFC  8FC20030   LW V0, 48(S8)
9D001C00  8C420018   LW V0, 24(V0)
9D001C04  AFC20024   SW V0, 36(S8)
1776:                    mem_set(sfn, ' ', 11);
9D001C08  8FC40024   LW A0, 36(S8)
9D001C0C  24050020   ADDIU A1, ZERO, 32
9D001C10  2406000B   ADDIU A2, ZERO, 11
9D001C14  0F40002B   JAL 0x9D0000AC
9D001C18  00000000   NOP
1777:                    si = i = b = 0;
9D001C1C  A3C00010   SB ZERO, 16(S8)
9D001C20  AFC0001C   SW ZERO, 28(S8)
9D001C24  8FC2001C   LW V0, 28(S8)
9D001C28  AFC20018   SW V0, 24(S8)
1778:                    ni = 8;
9D001C2C  24020008   ADDIU V0, ZERO, 8
9D001C30  AFC20014   SW V0, 20(S8)
1779:                #if _FS_RPATH
1780:                    if (p[si] == '.') { /* Is this a dot entry? */
9D001C34  8FC30020   LW V1, 32(S8)
9D001C38  8FC20018   LW V0, 24(S8)
9D001C3C  00621021   ADDU V0, V1, V0
9D001C40  80430000   LB V1, 0(V0)
9D001C44  2402002E   ADDIU V0, ZERO, 46
9D001C48  1462003D   BNE V1, V0, 0x9D001D40
9D001C4C  00000000   NOP
1781:                        for (;;) {
1782:                            c = (BYTE) p[si++];
9D001C50  8FC30020   LW V1, 32(S8)
9D001C54  8FC20018   LW V0, 24(S8)
9D001C58  00621021   ADDU V0, V1, V0
9D001C5C  80420000   LB V0, 0(V0)
9D001C60  A3C20011   SB V0, 17(S8)
9D001C64  8FC20018   LW V0, 24(S8)
9D001C68  24420001   ADDIU V0, V0, 1
9D001C6C  AFC20018   SW V0, 24(S8)
1783:                            if (c != '.' || si >= 3) break;
9D001C70  93C30011   LBU V1, 17(S8)
9D001C74  2402002E   ADDIU V0, ZERO, 46
9D001C78  1462000F   BNE V1, V0, 0x9D001CB8
9D001C7C  00000000   NOP
9D001C80  8FC20018   LW V0, 24(S8)
9D001C84  2C420003   SLTIU V0, V0, 3
9D001C88  1040000B   BEQ V0, ZERO, 0x9D001CB8
9D001C8C  00000000   NOP
1784:                            sfn[i++] = c;
9D001C90  8FC30024   LW V1, 36(S8)
9D001C94  8FC2001C   LW V0, 28(S8)
9D001C98  00621021   ADDU V0, V1, V0
9D001C9C  93C30011   LBU V1, 17(S8)
9D001CA0  A0430000   SB V1, 0(V0)
9D001CA4  8FC2001C   LW V0, 28(S8)
9D001CA8  24420001   ADDIU V0, V0, 1
9D001CAC  AFC2001C   SW V0, 28(S8)
1785:                        }
9D001CB0  0B400714   J 0x9D001C50
9D001CB4  00000000   NOP
1786:                        if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
9D001CB8  93C30011   LBU V1, 17(S8)
9D001CBC  2402002F   ADDIU V0, ZERO, 47
9D001CC0  1062000C   BEQ V1, V0, 0x9D001CF4
9D001CC4  00000000   NOP
9D001CC8  93C30011   LBU V1, 17(S8)
9D001CCC  2402005C   ADDIU V0, ZERO, 92
9D001CD0  10620008   BEQ V1, V0, 0x9D001CF4
9D001CD4  00000000   NOP
9D001CD8  93C20011   LBU V0, 17(S8)
9D001CDC  2C420021   SLTIU V0, V0, 33
9D001CE0  14400004   BNE V0, ZERO, 0x9D001CF4
9D001CE4  00000000   NOP
9D001CE8  24020006   ADDIU V0, ZERO, 6
9D001CEC  0B4007F7   J 0x9D001FDC
9D001CF0  00000000   NOP
1787:                        *path = &p[si]; /* Return pointer to the next segment */
9D001CF4  8FC30020   LW V1, 32(S8)
9D001CF8  8FC20018   LW V0, 24(S8)
9D001CFC  00621821   ADDU V1, V1, V0
9D001D00  8FC20034   LW V0, 52(S8)
9D001D04  AC430000   SW V1, 0(V0)
1788:                        sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT; /* Set last segment flag if end of path */
9D001D08  8FC20024   LW V0, 36(S8)
9D001D0C  2443000B   ADDIU V1, V0, 11
9D001D10  93C20011   LBU V0, 17(S8)
9D001D14  2C420021   SLTIU V0, V0, 33
9D001D18  10400004   BEQ V0, ZERO, 0x9D001D2C
9D001D1C  00000000   NOP
9D001D20  24020024   ADDIU V0, ZERO, 36
9D001D24  0B40074C   J 0x9D001D30
9D001D28  00000000   NOP
9D001D2C  24020020   ADDIU V0, ZERO, 32
9D001D30  A0620000   SB V0, 0(V1)
1789:                        return FR_OK;
9D001D34  00001021   ADDU V0, ZERO, ZERO
9D001D38  0B4007F7   J 0x9D001FDC
9D001D3C  00000000   NOP
1790:                    }
1791:                #endif
1792:                    for (;;) {
1793:                        c = (BYTE) p[si++];
9D001D40  8FC30020   LW V1, 32(S8)
9D001D44  8FC20018   LW V0, 24(S8)
9D001D48  00621021   ADDU V0, V1, V0
9D001D4C  80420000   LB V0, 0(V0)
9D001D50  A3C20011   SB V0, 17(S8)
9D001D54  8FC20018   LW V0, 24(S8)
9D001D58  24420001   ADDIU V0, V0, 1
9D001D5C  AFC20018   SW V0, 24(S8)
1794:                        if (c <= ' ' || c == '/' || c == '\\') break; /* Break on end of segment */
9D001D60  93C20011   LBU V0, 17(S8)
9D001D64  2C420021   SLTIU V0, V0, 33
9D001D68  14400064   BNE V0, ZERO, 0x9D001EFC
9D001D6C  00000000   NOP
9D001D70  93C30011   LBU V1, 17(S8)
9D001D74  2402002F   ADDIU V0, ZERO, 47
9D001D78  10620060   BEQ V1, V0, 0x9D001EFC
9D001D7C  00000000   NOP
9D001D80  93C30011   LBU V1, 17(S8)
9D001D84  2402005C   ADDIU V0, ZERO, 92
9D001D88  1062005C   BEQ V1, V0, 0x9D001EFC
9D001D8C  00000000   NOP
1795:                        if (c == '.' || i >= ni) {
9D001D90  93C30011   LBU V1, 17(S8)
9D001D94  2402002E   ADDIU V0, ZERO, 46
9D001D98  10620006   BEQ V1, V0, 0x9D001DB4
9D001D9C  00000000   NOP
9D001DA0  8FC3001C   LW V1, 28(S8)
9D001DA4  8FC20014   LW V0, 20(S8)
9D001DA8  0062102B   SLTU V0, V1, V0
9D001DAC  14400016   BNE V0, ZERO, 0x9D001E08
9D001DB0  00000000   NOP
1796:                            if (ni != 8 || c != '.') return FR_INVALID_NAME;
9D001DB4  8FC30014   LW V1, 20(S8)
9D001DB8  24020008   ADDIU V0, ZERO, 8
9D001DBC  14620005   BNE V1, V0, 0x9D001DD4
9D001DC0  00000000   NOP
9D001DC4  93C30011   LBU V1, 17(S8)
9D001DC8  2402002E   ADDIU V0, ZERO, 46
9D001DCC  10620004   BEQ V1, V0, 0x9D001DE0
9D001DD0  00000000   NOP
9D001DD4  24020006   ADDIU V0, ZERO, 6
9D001DD8  0B4007F7   J 0x9D001FDC
9D001DDC  00000000   NOP
1797:                            i = 8;
9D001DE0  24020008   ADDIU V0, ZERO, 8
9D001DE4  AFC2001C   SW V0, 28(S8)
1798:                            ni = 11;
9D001DE8  2402000B   ADDIU V0, ZERO, 11
9D001DEC  AFC20014   SW V0, 20(S8)
1799:                            b <<= 2;
9D001DF0  93C20010   LBU V0, 16(S8)
9D001DF4  00021080   SLL V0, V0, 2
9D001DF8  A3C20010   SB V0, 16(S8)
1800:                            continue;
9D001DFC  00000000   NOP
1801:                        }
1802:                        if (c >= 0x80) { /* Extended char? */
9D001E08  83C20011   LB V0, 17(S8)
9D001E0C  0441000B   BGEZ V0, 0x9D001E3C
9D001E10  00000000   NOP
1803:                            b |= 3; /* Eliminate NT flag */
9D001E14  93C20010   LBU V0, 16(S8)
9D001E18  34420003   ORI V0, V0, 3
9D001E1C  A3C20010   SB V0, 16(S8)
1804:                #ifdef _EXCVT
1805:                            c = excvt[c - 0x80]; /* Upper conversion (SBCS) */
9D001E20  93C20011   LBU V0, 17(S8)
9D001E24  2443FF80   ADDIU V1, V0, -128
9D001E28  3C029D01   LUI V0, -25343
9D001E2C  2442CD74   ADDIU V0, V0, -12940
9D001E30  00621021   ADDU V0, V1, V0
9D001E34  90420000   LBU V0, 0(V0)
9D001E38  A3C20011   SB V0, 17(S8)
1806:                #else
1807:                #if !_DF1S	/* ASCII only cfg */
1808:                            return FR_INVALID_NAME;
1809:                #endif
1810:                #endif
1811:                        }
1812:                        if (IsDBCS1(c)) { /* Check if it is a DBC 1st byte (always false on SBCS cfg) */
1813:                            d = (BYTE) p[si++]; /* Get 2nd byte */
1814:                            if (!IsDBCS2(d) || i >= ni - 1) /* Reject invalid DBC */
1815:                                return FR_INVALID_NAME;
1816:                            sfn[i++] = c;
1817:                            sfn[i++] = d;
1818:                        } else { /* Single byte code */
1819:                            if (chk_chr("\"*+,:;<=>\?[]|\x7F", c)) /* Reject illegal chrs for SFN */
9D001E3C  93C20011   LBU V0, 17(S8)
9D001E40  3C039D01   LUI V1, -25343
9D001E44  2464CD00   ADDIU A0, V1, -13056
9D001E48  00402821   ADDU A1, V0, ZERO
9D001E4C  0F400075   JAL 0x9D0001D4
9D001E50  00000000   NOP
9D001E54  10400004   BEQ V0, ZERO, 0x9D001E68
9D001E58  00000000   NOP
1820:                                return FR_INVALID_NAME;
9D001E5C  24020006   ADDIU V0, ZERO, 6
9D001E60  0B4007F7   J 0x9D001FDC
9D001E64  00000000   NOP
1821:                            if (IsUpper(c)) { /* ASCII large capital? */
9D001E68  93C20011   LBU V0, 17(S8)
9D001E6C  2C420041   SLTIU V0, V0, 65
9D001E70  1440000A   BNE V0, ZERO, 0x9D001E9C
9D001E74  00000000   NOP
9D001E78  93C20011   LBU V0, 17(S8)
9D001E7C  2C42005B   SLTIU V0, V0, 91
9D001E80  10400006   BEQ V0, ZERO, 0x9D001E9C
9D001E84  00000000   NOP
1822:                                b |= 2;
9D001E88  93C20010   LBU V0, 16(S8)
9D001E8C  34420002   ORI V0, V0, 2
9D001E90  A3C20010   SB V0, 16(S8)
9D001E94  0B4007B5   J 0x9D001ED4
9D001E98  00000000   NOP
1823:                            } else {
1824:                                if (IsLower(c)) { /* ASCII small capital? */
9D001E9C  93C20011   LBU V0, 17(S8)
9D001EA0  2C420061   SLTIU V0, V0, 97
9D001EA4  1440000B   BNE V0, ZERO, 0x9D001ED4
9D001EA8  00000000   NOP
9D001EAC  93C20011   LBU V0, 17(S8)
9D001EB0  2C42007B   SLTIU V0, V0, 123
9D001EB4  10400007   BEQ V0, ZERO, 0x9D001ED4
9D001EB8  00000000   NOP
1825:                                    b |= 1;
9D001EBC  93C20010   LBU V0, 16(S8)
9D001EC0  34420001   ORI V0, V0, 1
9D001EC4  A3C20010   SB V0, 16(S8)
1826:                                    c -= 0x20;
9D001EC8  93C20011   LBU V0, 17(S8)
9D001ECC  2442FFE0   ADDIU V0, V0, -32
9D001ED0  A3C20011   SB V0, 17(S8)
1827:                                }
1828:                            }
1829:                            sfn[i++] = c;
9D001ED4  8FC30024   LW V1, 36(S8)
9D001ED8  8FC2001C   LW V0, 28(S8)
9D001EDC  00621021   ADDU V0, V1, V0
9D001EE0  93C30011   LBU V1, 17(S8)
9D001EE4  A0430000   SB V1, 0(V0)
9D001EE8  8FC2001C   LW V0, 28(S8)
9D001EEC  24420001   ADDIU V0, V0, 1
9D001EF0  AFC2001C   SW V0, 28(S8)
1830:                        }
1831:                    }
9D001E00  0B400750   J 0x9D001D40
9D001E04  00000000   NOP
9D001EF4  0B400750   J 0x9D001D40
9D001EF8  00000000   NOP
1832:                    *path = &p[si]; /* Return pointer to the next segment */
9D001EFC  8FC30020   LW V1, 32(S8)
9D001F00  8FC20018   LW V0, 24(S8)
9D001F04  00621821   ADDU V1, V1, V0
9D001F08  8FC20034   LW V0, 52(S8)
9D001F0C  AC430000   SW V1, 0(V0)
1833:                    c = (c <= ' ') ? NS_LAST : 0; /* Set last segment flag if end of path */
9D001F10  93C20011   LBU V0, 17(S8)
9D001F14  2C420021   SLTIU V0, V0, 33
9D001F18  10400004   BEQ V0, ZERO, 0x9D001F2C
9D001F1C  00000000   NOP
9D001F20  24020004   ADDIU V0, ZERO, 4
9D001F24  0B4007CC   J 0x9D001F30
9D001F28  00000000   NOP
9D001F2C  00001021   ADDU V0, ZERO, ZERO
9D001F30  A3C20011   SB V0, 17(S8)
1834:                
1835:                    if (!i) return FR_INVALID_NAME; /* Reject nul string */
9D001F34  8FC2001C   LW V0, 28(S8)
9D001F38  14400004   BNE V0, ZERO, 0x9D001F4C
9D001F3C  00000000   NOP
9D001F40  24020006   ADDIU V0, ZERO, 6
9D001F44  0B4007F7   J 0x9D001FDC
9D001F48  00000000   NOP
1836:                    if (sfn[0] == DDE) sfn[0] = NDDE; /* When first char collides with DDE, replace it with 0x05 */
9D001F4C  8FC20024   LW V0, 36(S8)
9D001F50  90430000   LBU V1, 0(V0)
9D001F54  240200E5   ADDIU V0, ZERO, 229
9D001F58  14620004   BNE V1, V0, 0x9D001F6C
9D001F5C  00000000   NOP
9D001F60  8FC20024   LW V0, 36(S8)
9D001F64  24030005   ADDIU V1, ZERO, 5
9D001F68  A0430000   SB V1, 0(V0)
1837:                
1838:                    if (ni == 8) b <<= 2;
9D001F6C  8FC30014   LW V1, 20(S8)
9D001F70  24020008   ADDIU V0, ZERO, 8
9D001F74  14620004   BNE V1, V0, 0x9D001F88
9D001F78  00000000   NOP
9D001F7C  93C20010   LBU V0, 16(S8)
9D001F80  00021080   SLL V0, V0, 2
9D001F84  A3C20010   SB V0, 16(S8)
1839:                    if ((b & 0x03) == 0x01) c |= NS_EXT; /* NT flag (Name extension has only small capital) */
9D001F88  93C20010   LBU V0, 16(S8)
9D001F8C  30430003   ANDI V1, V0, 3
9D001F90  24020001   ADDIU V0, ZERO, 1
9D001F94  14620004   BNE V1, V0, 0x9D001FA8
9D001F98  00000000   NOP
9D001F9C  93C20011   LBU V0, 17(S8)
9D001FA0  34420010   ORI V0, V0, 16
9D001FA4  A3C20011   SB V0, 17(S8)
1840:                    if ((b & 0x0C) == 0x04) c |= NS_BODY; /* NT flag (Name body has only small capital) */
9D001FA8  93C20010   LBU V0, 16(S8)
9D001FAC  3043000C   ANDI V1, V0, 12
9D001FB0  24020004   ADDIU V0, ZERO, 4
9D001FB4  14620004   BNE V1, V0, 0x9D001FC8
9D001FB8  00000000   NOP
9D001FBC  93C20011   LBU V0, 17(S8)
9D001FC0  34420008   ORI V0, V0, 8
9D001FC4  A3C20011   SB V0, 17(S8)
1841:                
1842:                    sfn[NS] = c; /* Store NT flag, File name is created */
9D001FC8  8FC20024   LW V0, 36(S8)
9D001FCC  2442000B   ADDIU V0, V0, 11
9D001FD0  93C30011   LBU V1, 17(S8)
9D001FD4  A0430000   SB V1, 0(V0)
1843:                
1844:                    return FR_OK;
9D001FD8  00001021   ADDU V0, ZERO, ZERO
1845:                #endif
1846:                }
9D001FDC  03C0E821   ADDU SP, S8, ZERO
9D001FE0  8FBF002C   LW RA, 44(SP)
9D001FE4  8FBE0028   LW S8, 40(SP)
9D001FE8  27BD0030   ADDIU SP, SP, 48
9D001FEC  03E00008   JR RA
9D001FF0  00000000   NOP
1847:                
1848:                
1849:                
1850:                
1851:                /*-----------------------------------------------------------------------*/
1852:                /* Get file information from directory entry                             */
1853:                /*-----------------------------------------------------------------------*/
1854:                #if _FS_MINIMIZE <= 1
1855:                
1856:                static
1857:                void get_fileinfo(/* No return code */
1858:                        DIR *dj, /* Pointer to the directory object */
1859:                        FILINFO *fno /* Pointer to the file information to be filled */
1860:                        ) {
9D001FF4  27BDFFE0   ADDIU SP, SP, -32
9D001FF8  AFBE001C   SW S8, 28(SP)
9D001FFC  03A0F021   ADDU S8, SP, ZERO
9D002000  AFC40020   SW A0, 32(S8)
9D002004  AFC50024   SW A1, 36(S8)
1861:                    UINT i;
1862:                    BYTE nt, *dir;
1863:                    TCHAR *p, c;
1864:                
1865:                
1866:                    p = fno->fname;
9D002008  8FC20024   LW V0, 36(S8)
9D00200C  24420009   ADDIU V0, V0, 9
9D002010  AFC20004   SW V0, 4(S8)
1867:                    if (dj->sect) {
9D002014  8FC20020   LW V0, 32(S8)
9D002018  8C420010   LW V0, 16(V0)
9D00201C  10400088   BEQ V0, ZERO, 0x9D002240
9D002020  00000000   NOP
1868:                        dir = dj->dir;
9D002024  8FC20020   LW V0, 32(S8)
9D002028  8C420014   LW V0, 20(V0)
9D00202C  AFC2000C   SW V0, 12(S8)
1869:                        nt = dir[DIR_NTres]; /* NT flag */
9D002030  8FC2000C   LW V0, 12(S8)
9D002034  2442000C   ADDIU V0, V0, 12
9D002038  90420000   LBU V0, 0(V0)
9D00203C  A3C20010   SB V0, 16(S8)
1870:                        for (i = 0; i < 8; i++) { /* Copy name body */
9D002040  AFC00000   SW ZERO, 0(S8)
9D002044  0B40082B   J 0x9D0020AC
9D002048  00000000   NOP
9D0020A0  8FC20000   LW V0, 0(S8)
9D0020A4  24420001   ADDIU V0, V0, 1
9D0020A8  AFC20000   SW V0, 0(S8)
9D0020AC  8FC20000   LW V0, 0(S8)
9D0020B0  2C420008   SLTIU V0, V0, 8
9D0020B4  1440FFE5   BNE V0, ZERO, 0x9D00204C
9D0020B8  00000000   NOP
9D0020BC  0B400832   J 0x9D0020C8
9D0020C0  00000000   NOP
1871:                            c = dir[i];
9D00204C  8FC3000C   LW V1, 12(S8)
9D002050  8FC20000   LW V0, 0(S8)
9D002054  00621021   ADDU V0, V1, V0
9D002058  90420000   LBU V0, 0(V0)
9D00205C  A3C20008   SB V0, 8(S8)
1872:                            if (c == ' ') break;
9D002060  83C30008   LB V1, 8(S8)
9D002064  24020020   ADDIU V0, ZERO, 32
9D002068  10620016   BEQ V1, V0, 0x9D0020C4
9D00206C  00000000   NOP
9D0020C4  00000000   NOP
1873:                            if (c == NDDE) c = (TCHAR) DDE;
9D002070  83C30008   LB V1, 8(S8)
9D002074  24020005   ADDIU V0, ZERO, 5
9D002078  14620003   BNE V1, V0, 0x9D002088
9D00207C  00000000   NOP
9D002080  2402FFE5   ADDIU V0, ZERO, -27
9D002084  A3C20008   SB V0, 8(S8)
1874:                            if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
1875:                #if _LFN_UNICODE
1876:                            if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i + 1]))
1877:                                c = (c << 8) | dir[++i];
1878:                            c = ff_convert(c, 1);
1879:                            if (!c) c = '?';
1880:                #endif
1881:                            *p++ = c;
9D002088  8FC20004   LW V0, 4(S8)
9D00208C  93C30008   LBU V1, 8(S8)
9D002090  A0430000   SB V1, 0(V0)
9D002094  8FC20004   LW V0, 4(S8)
9D002098  24420001   ADDIU V0, V0, 1
9D00209C  AFC20004   SW V0, 4(S8)
1882:                        }
1883:                        if (dir[8] != ' ') { /* Copy name extension */
9D0020C8  8FC2000C   LW V0, 12(S8)
9D0020CC  24420008   ADDIU V0, V0, 8
9D0020D0  90430000   LBU V1, 0(V0)
9D0020D4  24020020   ADDIU V0, ZERO, 32
9D0020D8  10620024   BEQ V1, V0, 0x9D00216C
9D0020DC  00000000   NOP
1884:                            *p++ = '.';
9D0020E0  8FC20004   LW V0, 4(S8)
9D0020E4  2403002E   ADDIU V1, ZERO, 46
9D0020E8  A0430000   SB V1, 0(V0)
9D0020EC  8FC20004   LW V0, 4(S8)
9D0020F0  24420001   ADDIU V0, V0, 1
9D0020F4  AFC20004   SW V0, 4(S8)
1885:                            for (i = 8; i < 11; i++) {
9D0020F8  24020008   ADDIU V0, ZERO, 8
9D0020FC  AFC20000   SW V0, 0(S8)
9D002100  0B400854   J 0x9D002150
9D002104  00000000   NOP
9D002144  8FC20000   LW V0, 0(S8)
9D002148  24420001   ADDIU V0, V0, 1
9D00214C  AFC20000   SW V0, 0(S8)
9D002150  8FC20000   LW V0, 0(S8)
9D002154  2C42000B   SLTIU V0, V0, 11
9D002158  1440FFEB   BNE V0, ZERO, 0x9D002108
9D00215C  00000000   NOP
9D002160  0B40085B   J 0x9D00216C
9D002164  00000000   NOP
1886:                                c = dir[i];
9D002108  8FC3000C   LW V1, 12(S8)
9D00210C  8FC20000   LW V0, 0(S8)
9D002110  00621021   ADDU V0, V1, V0
9D002114  90420000   LBU V0, 0(V0)
9D002118  A3C20008   SB V0, 8(S8)
1887:                                if (c == ' ') break;
9D00211C  83C30008   LB V1, 8(S8)
9D002120  24020020   ADDIU V0, ZERO, 32
9D002124  10620010   BEQ V1, V0, 0x9D002168
9D002128  00000000   NOP
9D002168  00000000   NOP
1888:                                if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
1889:                #if _LFN_UNICODE
1890:                                if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i + 1]))
1891:                                    c = (c << 8) | dir[++i];
1892:                                c = ff_convert(c, 1);
1893:                                if (!c) c = '?';
1894:                #endif
1895:                                *p++ = c;
9D00212C  8FC20004   LW V0, 4(S8)
9D002130  93C30008   LBU V1, 8(S8)
9D002134  A0430000   SB V1, 0(V0)
9D002138  8FC20004   LW V0, 4(S8)
9D00213C  24420001   ADDIU V0, V0, 1
9D002140  AFC20004   SW V0, 4(S8)
1896:                            }
1897:                        }
1898:                        fno->fattrib = dir[DIR_Attr]; /* Attribute */
9D00216C  8FC2000C   LW V0, 12(S8)
9D002170  2442000B   ADDIU V0, V0, 11
9D002174  90430000   LBU V1, 0(V0)
9D002178  8FC20024   LW V0, 36(S8)
9D00217C  A0430008   SB V1, 8(V0)
1899:                        fno->fsize = LD_DWORD(dir + DIR_FileSize); /* Size */
9D002180  8FC2000C   LW V0, 12(S8)
9D002184  2442001F   ADDIU V0, V0, 31
9D002188  90420000   LBU V0, 0(V0)
9D00218C  00021E00   SLL V1, V0, 24
9D002190  8FC2000C   LW V0, 12(S8)
9D002194  2442001E   ADDIU V0, V0, 30
9D002198  90420000   LBU V0, 0(V0)
9D00219C  00021400   SLL V0, V0, 16
9D0021A0  00621825   OR V1, V1, V0
9D0021A4  8FC2000C   LW V0, 12(S8)
9D0021A8  2442001D   ADDIU V0, V0, 29
9D0021AC  90420000   LBU V0, 0(V0)
9D0021B0  00021200   SLL V0, V0, 8
9D0021B4  00621825   OR V1, V1, V0
9D0021B8  8FC2000C   LW V0, 12(S8)
9D0021BC  2442001C   ADDIU V0, V0, 28
9D0021C0  90420000   LBU V0, 0(V0)
9D0021C4  00621825   OR V1, V1, V0
9D0021C8  8FC20024   LW V0, 36(S8)
9D0021CC  AC430000   SW V1, 0(V0)
1900:                        fno->fdate = LD_WORD(dir + DIR_WrtDate); /* Date */
9D0021D0  8FC2000C   LW V0, 12(S8)
9D0021D4  24420019   ADDIU V0, V0, 25
9D0021D8  90420000   LBU V0, 0(V0)
9D0021DC  00021200   SLL V0, V0, 8
9D0021E0  7C021E20   SEH V1, V0
9D0021E4  8FC2000C   LW V0, 12(S8)
9D0021E8  24420018   ADDIU V0, V0, 24
9D0021EC  90420000   LBU V0, 0(V0)
9D0021F0  7C021620   SEH V0, V0
9D0021F4  00621025   OR V0, V1, V0
9D0021F8  7C021620   SEH V0, V0
9D0021FC  3043FFFF   ANDI V1, V0, -1
9D002200  8FC20024   LW V0, 36(S8)
9D002204  A4430004   SH V1, 4(V0)
1901:                        fno->ftime = LD_WORD(dir + DIR_WrtTime); /* Time */
9D002208  8FC2000C   LW V0, 12(S8)
9D00220C  24420017   ADDIU V0, V0, 23
9D002210  90420000   LBU V0, 0(V0)
9D002214  00021200   SLL V0, V0, 8
9D002218  7C021E20   SEH V1, V0
9D00221C  8FC2000C   LW V0, 12(S8)
9D002220  24420016   ADDIU V0, V0, 22
9D002224  90420000   LBU V0, 0(V0)
9D002228  7C021620   SEH V0, V0
9D00222C  00621025   OR V0, V1, V0
9D002230  7C021620   SEH V0, V0
9D002234  3043FFFF   ANDI V1, V0, -1
9D002238  8FC20024   LW V0, 36(S8)
9D00223C  A4430006   SH V1, 6(V0)
1902:                    }
1903:                    *p = 0; /* Terminate SFN str by a \0 */
9D002240  8FC20004   LW V0, 4(S8)
9D002244  A0400000   SB ZERO, 0(V0)
1904:                
1905:                #if _USE_LFN
1906:                    if (fno->lfname && fno->lfsize) {
1907:                        TCHAR *tp = fno->lfname;
1908:                        WCHAR w, *lfn;
1909:                
1910:                        i = 0;
1911:                        if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
1912:                            lfn = dj->lfn;
1913:                            while ((w = *lfn++) != 0) { /* Get an LFN char */
1914:                #if !_LFN_UNICODE
1915:                                w = ff_convert(w, 0); /* Unicode -> OEM conversion */
1916:                                if (!w) {
1917:                                    i = 0;
1918:                                    break;
1919:                                } /* Could not convert, no LFN */
1920:                                if (_DF1S && w >= 0x100) /* Put 1st byte if it is a DBC (always false on SBCS cfg) */
1921:                                    tp[i++] = (TCHAR) (w >> 8);
1922:                #endif
1923:                                if (i >= fno->lfsize - 1) {
1924:                                    i = 0;
1925:                                    break;
1926:                                } /* Buffer overflow, no LFN */
1927:                                tp[i++] = (TCHAR) w;
1928:                            }
1929:                        }
1930:                        tp[i] = 0; /* Terminate the LFN str by a \0 */
1931:                    }
1932:                #endif
1933:                }
9D002248  03C0E821   ADDU SP, S8, ZERO
9D00224C  8FBE001C   LW S8, 28(SP)
9D002250  27BD0020   ADDIU SP, SP, 32
9D002254  03E00008   JR RA
9D002258  00000000   NOP
1934:                #endif /* _FS_MINIMIZE <= 1 */
1935:                
1936:                
1937:                
1938:                
1939:                /*-----------------------------------------------------------------------*/
1940:                /* Follow a file path                                                    */
1941:                
1942:                /*-----------------------------------------------------------------------*/
1943:                
1944:                static
1945:                FRESULT follow_path(/* FR_OK(0): successful, !=0: error code */
1946:                        DIR *dj, /* Directory object to return last directory and found object */
1947:                        const TCHAR *path /* Full-path string to find a file or directory */
1948:                        ) {
9D00225C  27BDFFD8   ADDIU SP, SP, -40
9D002260  AFBF0024   SW RA, 36(SP)
9D002264  AFBE0020   SW S8, 32(SP)
9D002268  03A0F021   ADDU S8, SP, ZERO
9D00226C  AFC40028   SW A0, 40(S8)
9D002270  AFC5002C   SW A1, 44(S8)
1949:                    FRESULT res;
1950:                    BYTE *dir, ns;
1951:                
1952:                
1953:                #if _FS_RPATH
1954:                    if (*path == '/' || *path == '\\') { /* There is a heading separator */
9D002274  8FC2002C   LW V0, 44(S8)
9D002278  80430000   LB V1, 0(V0)
9D00227C  2402002F   ADDIU V0, ZERO, 47
9D002280  10620006   BEQ V1, V0, 0x9D00229C
9D002284  00000000   NOP
9D002288  8FC2002C   LW V0, 44(S8)
9D00228C  80430000   LB V1, 0(V0)
9D002290  2402005C   ADDIU V0, ZERO, 92
9D002294  14620008   BNE V1, V0, 0x9D0022B8
9D002298  00000000   NOP
1955:                        path++;
9D00229C  8FC2002C   LW V0, 44(S8)
9D0022A0  24420001   ADDIU V0, V0, 1
9D0022A4  AFC2002C   SW V0, 44(S8)
1956:                        dj->sclust = 0; /* Strip it and start from the root dir */
9D0022A8  8FC20028   LW V0, 40(S8)
9D0022AC  AC400008   SW ZERO, 8(V0)
9D0022B0  0B4008B3   J 0x9D0022CC
9D0022B4  00000000   NOP
1957:                    } else { /* No heading separator */
1958:                        dj->sclust = dj->fs->cdir; /* Start from the current dir */
9D0022B8  8FC20028   LW V0, 40(S8)
9D0022BC  8C420000   LW V0, 0(V0)
9D0022C0  8C430018   LW V1, 24(V0)
9D0022C4  8FC20028   LW V0, 40(S8)
9D0022C8  AC430008   SW V1, 8(V0)
1959:                    }
1960:                #else
1961:                    if (*path == '/' || *path == '\\') /* Strip heading separator if exist */
1962:                        path++;
1963:                    dj->sclust = 0; /* Start from the root dir */
1964:                #endif
1965:                
1966:                    if ((UINT) * path < ' ') { /* Nul path means the start directory itself */
9D0022CC  8FC2002C   LW V0, 44(S8)
9D0022D0  80420000   LB V0, 0(V0)
9D0022D4  304200FF   ANDI V0, V0, 255
9D0022D8  2C420020   SLTIU V0, V0, 32
9D0022DC  1040000A   BEQ V0, ZERO, 0x9D002308
9D0022E0  00000000   NOP
1967:                        res = dir_sdi(dj, 0);
9D0022E4  8FC40028   LW A0, 40(S8)
9D0022E8  00002821   ADDU A1, ZERO, ZERO
9D0022EC  0F40045E   JAL 0x9D001178
9D0022F0  00000000   NOP
9D0022F4  AFC20010   SW V0, 16(S8)
1968:                        dj->dir = 0;
9D0022F8  8FC20028   LW V0, 40(S8)
9D0022FC  AC400014   SW ZERO, 20(V0)
9D002300  0B40092F   J 0x9D0024BC
9D002304  00000000   NOP
1969:                
1970:                    } else { /* Follow path */
1971:                        for (;;) {
1972:                            res = create_name(dj, &path); /* Get a segment */
9D002308  27C2002C   ADDIU V0, S8, 44
9D00230C  8FC40028   LW A0, 40(S8)
9D002310  00402821   ADDU A1, V0, ZERO
9D002314  0F4006E7   JAL 0x9D001B9C
9D002318  00000000   NOP
9D00231C  AFC20010   SW V0, 16(S8)
1973:                            if (res != FR_OK) break;
9D002320  8FC20010   LW V0, 16(S8)
9D002324  14400058   BNE V0, ZERO, 0x9D002488
9D002328  00000000   NOP
9D002488  00000000   NOP
9D00248C  0B40092F   J 0x9D0024BC
9D002490  00000000   NOP
1974:                            res = dir_find(dj); /* Find it */
9D00232C  8FC40028   LW A0, 40(S8)
9D002330  0F4005CB   JAL 0x9D00172C
9D002334  00000000   NOP
9D002338  AFC20010   SW V0, 16(S8)
1975:                            ns = *(dj->fn + NS);
9D00233C  8FC20028   LW V0, 40(S8)
9D002340  8C420018   LW V0, 24(V0)
9D002344  2442000B   ADDIU V0, V0, 11
9D002348  90420000   LBU V0, 0(V0)
9D00234C  A3C20014   SB V0, 20(S8)
1976:                            if (res != FR_OK) { /* Failed to find the object */
9D002350  8FC20010   LW V0, 16(S8)
9D002354  1040001D   BEQ V0, ZERO, 0x9D0023CC
9D002358  00000000   NOP
1977:                                if (res != FR_NO_FILE) break; /* Abort if any hard error occured */
9D00235C  8FC30010   LW V1, 16(S8)
9D002360  24020004   ADDIU V0, ZERO, 4
9D002364  1462004B   BNE V1, V0, 0x9D002494
9D002368  00000000   NOP
9D002494  00000000   NOP
9D002498  0B40092F   J 0x9D0024BC
9D00249C  00000000   NOP
1978:                                /* Object not found */
1979:                                if (_FS_RPATH && (ns & NS_DOT)) { /* If dot entry is not exit */
9D00236C  93C20014   LBU V0, 20(S8)
9D002370  30420020   ANDI V0, V0, 32
9D002374  1040000D   BEQ V0, ZERO, 0x9D0023AC
9D002378  00000000   NOP
1980:                                    dj->sclust = 0;
9D00237C  8FC20028   LW V0, 40(S8)
9D002380  AC400008   SW ZERO, 8(V0)
1981:                                    dj->dir = 0; /* It is the root dir */
9D002384  8FC20028   LW V0, 40(S8)
9D002388  AC400014   SW ZERO, 20(V0)
1982:                                    res = FR_OK;
9D00238C  AFC00010   SW ZERO, 16(S8)
1983:                                    if (!(ns & NS_LAST)) continue;
9D002390  93C20014   LBU V0, 20(S8)
9D002394  30420004   ANDI V0, V0, 4
9D002398  14400041   BNE V0, ZERO, 0x9D0024A0
9D00239C  00000000   NOP
9D0023A0  00000000   NOP
1984:                                } else { /* Could not find the object */
1985:                                    if (!(ns & NS_LAST)) res = FR_NO_PATH;
9D0023AC  93C20014   LBU V0, 20(S8)
9D0023B0  30420004   ANDI V0, V0, 4
9D0023B4  1440003D   BNE V0, ZERO, 0x9D0024AC
9D0023B8  00000000   NOP
9D0023BC  24020005   ADDIU V0, ZERO, 5
9D0023C0  AFC20010   SW V0, 16(S8)
1986:                                }
1987:                                break;
9D0023C4  0B40092F   J 0x9D0024BC
9D0023C8  00000000   NOP
9D0024A0  00000000   NOP
9D0024A4  0B40092F   J 0x9D0024BC
9D0024A8  00000000   NOP
9D0024AC  00000000   NOP
9D0024B0  0B40092F   J 0x9D0024BC
9D0024B4  00000000   NOP
1988:                            }
1989:                            if (ns & NS_LAST) break; /* Last segment match. Function completed. */
9D0023CC  93C20014   LBU V0, 20(S8)
9D0023D0  30420004   ANDI V0, V0, 4
9D0023D4  14400038   BNE V0, ZERO, 0x9D0024B8
9D0023D8  00000000   NOP
9D0024B8  00000000   NOP
1990:                            dir = dj->dir; /* There is next segment. Follow the sub directory */
9D0023DC  8FC20028   LW V0, 40(S8)
9D0023E0  8C420014   LW V0, 20(V0)
9D0023E4  AFC20018   SW V0, 24(S8)
1991:                            if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
9D0023E8  8FC20018   LW V0, 24(S8)
9D0023EC  2442000B   ADDIU V0, V0, 11
9D0023F0  90420000   LBU V0, 0(V0)
9D0023F4  30420010   ANDI V0, V0, 16
9D0023F8  14400005   BNE V0, ZERO, 0x9D002410
9D0023FC  00000000   NOP
1992:                                res = FR_NO_PATH;
9D002400  24020005   ADDIU V0, ZERO, 5
9D002404  AFC20010   SW V0, 16(S8)
1993:                                break;
9D002408  0B40092F   J 0x9D0024BC
9D00240C  00000000   NOP
1994:                            }
1995:                            dj->sclust = LD_CLUST(dir);
9D002410  8FC20018   LW V0, 24(S8)
9D002414  24420015   ADDIU V0, V0, 21
9D002418  90420000   LBU V0, 0(V0)
9D00241C  00021200   SLL V0, V0, 8
9D002420  7C021E20   SEH V1, V0
9D002424  8FC20018   LW V0, 24(S8)
9D002428  24420014   ADDIU V0, V0, 20
9D00242C  90420000   LBU V0, 0(V0)
9D002430  7C021620   SEH V0, V0
9D002434  00621025   OR V0, V1, V0
9D002438  7C021620   SEH V0, V0
9D00243C  3042FFFF   ANDI V0, V0, -1
9D002440  00021C00   SLL V1, V0, 16
9D002444  8FC20018   LW V0, 24(S8)
9D002448  2442001B   ADDIU V0, V0, 27
9D00244C  90420000   LBU V0, 0(V0)
9D002450  00021200   SLL V0, V0, 8
9D002454  7C022620   SEH A0, V0
9D002458  8FC20018   LW V0, 24(S8)
9D00245C  2442001A   ADDIU V0, V0, 26
9D002460  90420000   LBU V0, 0(V0)
9D002464  7C021620   SEH V0, V0
9D002468  00821025   OR V0, A0, V0
9D00246C  7C021620   SEH V0, V0
9D002470  3042FFFF   ANDI V0, V0, -1
9D002474  00621825   OR V1, V1, V0
9D002478  8FC20028   LW V0, 40(S8)
9D00247C  AC430008   SW V1, 8(V0)
1996:                        }
9D0023A4  0B4008C2   J 0x9D002308
9D0023A8  00000000   NOP
9D002480  0B4008C2   J 0x9D002308
9D002484  00000000   NOP
1997:                    }
1998:                
1999:                    return res;
9D0024BC  8FC20010   LW V0, 16(S8)
2000:                }
9D0024C0  03C0E821   ADDU SP, S8, ZERO
9D0024C4  8FBF0024   LW RA, 36(SP)
9D0024C8  8FBE0020   LW S8, 32(SP)
9D0024CC  27BD0028   ADDIU SP, SP, 40
9D0024D0  03E00008   JR RA
9D0024D4  00000000   NOP
2001:                
2002:                
2003:                
2004:                
2005:                /*-----------------------------------------------------------------------*/
2006:                /* Load a sector and check if it is an FAT Volume Boot Record            */
2007:                
2008:                /*-----------------------------------------------------------------------*/
2009:                
2010:                static
2011:                BYTE check_fs(/* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
2012:                        FATFS *fs, /* File system object */
2013:                        DWORD sect /* Sector# (lba) to check if it is an FAT boot record or not */
2014:                        ) {
9D0024D8  27BDFFE8   ADDIU SP, SP, -24
9D0024DC  AFBF0014   SW RA, 20(SP)
9D0024E0  AFBE0010   SW S8, 16(SP)
9D0024E4  03A0F021   ADDU S8, SP, ZERO
9D0024E8  AFC40018   SW A0, 24(S8)
9D0024EC  AFC5001C   SW A1, 28(S8)
2015:                    if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK) /* Load boot record */
9D0024F0  8FC20018   LW V0, 24(S8)
9D0024F4  90420001   LBU V0, 1(V0)
9D0024F8  00401821   ADDU V1, V0, ZERO
9D0024FC  8FC20018   LW V0, 24(S8)
9D002500  24420034   ADDIU V0, V0, 52
9D002504  00602021   ADDU A0, V1, ZERO
9D002508  00402821   ADDU A1, V0, ZERO
9D00250C  8FC6001C   LW A2, 28(S8)
9D002510  24070001   ADDIU A3, ZERO, 1
9D002514  0F402130   JAL disk_read
9D002518  00000000   NOP
9D00251C  10400004   BEQ V0, ZERO, 0x9D002530
9D002520  00000000   NOP
2016:                        return 3;
9D002524  24020003   ADDIU V0, ZERO, 3
9D002528  0B400992   J 0x9D002648
9D00252C  00000000   NOP
2017:                    if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55) /* Check record signature (always placed at offset 510 even if the sector size is >512) */
9D002530  8FC20018   LW V0, 24(S8)
9D002534  24420233   ADDIU V0, V0, 563
9D002538  90420000   LBU V0, 0(V0)
9D00253C  00021200   SLL V0, V0, 8
9D002540  7C021E20   SEH V1, V0
9D002544  8FC20018   LW V0, 24(S8)
9D002548  24420232   ADDIU V0, V0, 562
9D00254C  90420000   LBU V0, 0(V0)
9D002550  7C021620   SEH V0, V0
9D002554  00621025   OR V0, V1, V0
9D002558  7C021E20   SEH V1, V0
9D00255C  2402AA55   ADDIU V0, ZERO, -21931
9D002560  10620004   BEQ V1, V0, 0x9D002574
9D002564  00000000   NOP
2018:                        return 2;
9D002568  24020002   ADDIU V0, ZERO, 2
9D00256C  0B400992   J 0x9D002648
9D002570  00000000   NOP
2019:                
2020:                    if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146) /* Check "FAT" string */
9D002574  8FC20018   LW V0, 24(S8)
9D002578  2442006D   ADDIU V0, V0, 109
9D00257C  90420000   LBU V0, 0(V0)
9D002580  00021E00   SLL V1, V0, 24
9D002584  8FC20018   LW V0, 24(S8)
9D002588  2442006C   ADDIU V0, V0, 108
9D00258C  90420000   LBU V0, 0(V0)
9D002590  00021400   SLL V0, V0, 16
9D002594  00621825   OR V1, V1, V0
9D002598  8FC20018   LW V0, 24(S8)
9D00259C  2442006B   ADDIU V0, V0, 107
9D0025A0  90420000   LBU V0, 0(V0)
9D0025A4  00021200   SLL V0, V0, 8
9D0025A8  00621825   OR V1, V1, V0
9D0025AC  8FC20018   LW V0, 24(S8)
9D0025B0  2442006A   ADDIU V0, V0, 106
9D0025B4  90420000   LBU V0, 0(V0)
9D0025B8  00621025   OR V0, V1, V0
9D0025BC  7C43B800   EXT V1, V0, 0, 24
9D0025C0  3C020054   LUI V0, 84
9D0025C4  34424146   ORI V0, V0, 16710
9D0025C8  14620004   BNE V1, V0, 0x9D0025DC
9D0025CC  00000000   NOP
2021:                        return 0;
9D0025D0  00001021   ADDU V0, ZERO, ZERO
9D0025D4  0B400992   J 0x9D002648
9D0025D8  00000000   NOP
2022:                    if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
9D0025DC  8FC20018   LW V0, 24(S8)
9D0025E0  24420089   ADDIU V0, V0, 137
9D0025E4  90420000   LBU V0, 0(V0)
9D0025E8  00021E00   SLL V1, V0, 24
9D0025EC  8FC20018   LW V0, 24(S8)
9D0025F0  24420088   ADDIU V0, V0, 136
9D0025F4  90420000   LBU V0, 0(V0)
9D0025F8  00021400   SLL V0, V0, 16
9D0025FC  00621825   OR V1, V1, V0
9D002600  8FC20018   LW V0, 24(S8)
9D002604  24420087   ADDIU V0, V0, 135
9D002608  90420000   LBU V0, 0(V0)
9D00260C  00021200   SLL V0, V0, 8
9D002610  00621825   OR V1, V1, V0
9D002614  8FC20018   LW V0, 24(S8)
9D002618  24420086   ADDIU V0, V0, 134
9D00261C  90420000   LBU V0, 0(V0)
9D002620  00621025   OR V0, V1, V0
9D002624  7C43B800   EXT V1, V0, 0, 24
9D002628  3C020054   LUI V0, 84
9D00262C  34424146   ORI V0, V0, 16710
9D002630  14620004   BNE V1, V0, 0x9D002644
9D002634  00000000   NOP
2023:                        return 0;
9D002638  00001021   ADDU V0, ZERO, ZERO
9D00263C  0B400992   J 0x9D002648
9D002640  00000000   NOP
2024:                
2025:                    return 1;
9D002644  24020001   ADDIU V0, ZERO, 1
2026:                }
9D002648  03C0E821   ADDU SP, S8, ZERO
9D00264C  8FBF0014   LW RA, 20(SP)
9D002650  8FBE0010   LW S8, 16(SP)
9D002654  27BD0018   ADDIU SP, SP, 24
9D002658  03E00008   JR RA
9D00265C  00000000   NOP
2027:                
2028:                
2029:                
2030:                
2031:                /*-----------------------------------------------------------------------*/
2032:                /* Check if the file system object is valid or not                       */
2033:                
2034:                /*-----------------------------------------------------------------------*/
2035:                
2036:                static
2037:                FRESULT chk_mounted(/* FR_OK(0): successful, !=0: any error occurred */
2038:                        const TCHAR **path, /* Pointer to pointer to the path name (drive number) */
2039:                        FATFS **rfs, /* Pointer to pointer to the found file system object */
2040:                        BYTE chk_wp /* !=0: Check media write protection for write access */
2041:                        ) {
9D002660  27BDFFB0   ADDIU SP, SP, -80
9D002664  AFBF004C   SW RA, 76(SP)
9D002668  AFBE0048   SW S8, 72(SP)
9D00266C  03A0F021   ADDU S8, SP, ZERO
9D002670  AFC40050   SW A0, 80(S8)
9D002674  AFC50054   SW A1, 84(S8)
9D002678  00C01021   ADDU V0, A2, ZERO
9D00267C  A3C20058   SB V0, 88(S8)
2042:                    BYTE fmt, b, pi, *tbl;
2043:                    UINT vol;
2044:                    DSTATUS stat;
2045:                    DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
2046:                    WORD nrsv;
2047:                    const TCHAR *p = *path;
9D002680  8FC20050   LW V0, 80(S8)
9D002684  8C420000   LW V0, 0(V0)
9D002688  AFC20028   SW V0, 40(S8)
2048:                    FATFS *fs;
2049:                
2050:                    /* Get logical drive number from the path name */
2051:                    vol = p[0] - '0'; /* Is there a drive number? */
9D00268C  8FC20028   LW V0, 40(S8)
9D002690  80420000   LB V0, 0(V0)
9D002694  2442FFD0   ADDIU V0, V0, -48
9D002698  AFC20014   SW V0, 20(S8)
2052:                    if (vol <= 9 && p[1] == ':') { /* Found a drive number, get and strip it */
9D00269C  8FC20014   LW V0, 20(S8)
9D0026A0  2C42000A   SLTIU V0, V0, 10
9D0026A4  1040000F   BEQ V0, ZERO, 0x9D0026E4
9D0026A8  00000000   NOP
9D0026AC  8FC20028   LW V0, 40(S8)
9D0026B0  24420001   ADDIU V0, V0, 1
9D0026B4  80430000   LB V1, 0(V0)
9D0026B8  2402003A   ADDIU V0, ZERO, 58
9D0026BC  14620009   BNE V1, V0, 0x9D0026E4
9D0026C0  00000000   NOP
2053:                        p += 2;
9D0026C4  8FC20028   LW V0, 40(S8)
9D0026C8  24420002   ADDIU V0, V0, 2
9D0026CC  AFC20028   SW V0, 40(S8)
2054:                        *path = p; /* Return pointer to the path name */
9D0026D0  8FC20050   LW V0, 80(S8)
9D0026D4  8FC30028   LW V1, 40(S8)
9D0026D8  AC430000   SW V1, 0(V0)
9D0026DC  0B4009BB   J 0x9D0026EC
9D0026E0  00000000   NOP
2055:                    } else { /* No drive number is given */
2056:                #if _FS_RPATH
2057:                        vol = CurrVol; /* Use current drive */
9D0026E4  9382805E   LBU V0, -32674(GP)
9D0026E8  AFC20014   SW V0, 20(S8)
2058:                #else
2059:                        vol = 0; /* Use drive 0 */
2060:                #endif
2061:                    }
2062:                
2063:                    /* Check if the file system object is valid or not */
2064:                    if (vol >= _VOLUMES) /* Is the drive number valid? */
9D0026EC  8FC20014   LW V0, 20(S8)
9D0026F0  10400004   BEQ V0, ZERO, 0x9D002704
9D0026F4  00000000   NOP
2065:                        return FR_INVALID_DRIVE;
9D0026F8  2402000B   ADDIU V0, ZERO, 11
9D0026FC  0B400C1F   J 0x9D00307C
9D002700  00000000   NOP
2066:                    *rfs = fs = FatFs[vol]; /* Return pointer to the corresponding file system object */
9D002704  8FC20014   LW V0, 20(S8)
9D002708  00021880   SLL V1, V0, 2
9D00270C  27828058   ADDIU V0, GP, -32680
9D002710  00621021   ADDU V0, V1, V0
9D002714  8C420000   LW V0, 0(V0)
9D002718  AFC2002C   SW V0, 44(S8)
9D00271C  8FC20054   LW V0, 84(S8)
9D002720  8FC3002C   LW V1, 44(S8)
9D002724  AC430000   SW V1, 0(V0)
2067:                    if (!fs) return FR_NOT_ENABLED; /* Is the file system object available? */
9D002728  8FC2002C   LW V0, 44(S8)
9D00272C  14400004   BNE V0, ZERO, 0x9D002740
9D002730  00000000   NOP
9D002734  2402000C   ADDIU V0, ZERO, 12
9D002738  0B400C1F   J 0x9D00307C
9D00273C  00000000   NOP
2068:                
2069:                    ENTER_FF(fs); /* Lock file system */
2070:                
2071:                    if (fs->fs_type) { /* If the logical drive has been mounted */
9D002740  8FC2002C   LW V0, 44(S8)
9D002744  90420000   LBU V0, 0(V0)
9D002748  10400018   BEQ V0, ZERO, 0x9D0027AC
9D00274C  00000000   NOP
2072:                        stat = disk_status(fs->drv);
9D002750  8FC2002C   LW V0, 44(S8)
9D002754  90420001   LBU V0, 1(V0)
9D002758  00402021   ADDU A0, V0, ZERO
9D00275C  0F40211E   JAL disk_status
9D002760  00000000   NOP
9D002764  A3C20030   SB V0, 48(S8)
2073:                        if (!(stat & STA_NOINIT)) { /* and the physical drive is kept initialized (has not been changed), */
9D002768  93C20030   LBU V0, 48(S8)
9D00276C  30420001   ANDI V0, V0, 1
9D002770  1440000E   BNE V0, ZERO, 0x9D0027AC
9D002774  00000000   NOP
2074:                            if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT)) /* Check write protection if needed */
9D002778  93C20058   LBU V0, 88(S8)
9D00277C  10400008   BEQ V0, ZERO, 0x9D0027A0
9D002780  00000000   NOP
9D002784  93C20030   LBU V0, 48(S8)
9D002788  30420004   ANDI V0, V0, 4
9D00278C  10400004   BEQ V0, ZERO, 0x9D0027A0
9D002790  00000000   NOP
2075:                                return FR_WRITE_PROTECTED;
9D002794  2402000A   ADDIU V0, ZERO, 10
9D002798  0B400C1F   J 0x9D00307C
9D00279C  00000000   NOP
2076:                            return FR_OK; /* The file system object is valid */
9D0027A0  00001021   ADDU V0, ZERO, ZERO
9D0027A4  0B400C1F   J 0x9D00307C
9D0027A8  00000000   NOP
2077:                        }
2078:                    }
2079:                
2080:                    /* The file system object is not valid. */
2081:                    /* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
2082:                
2083:                    fs->fs_type = 0; /* Clear the file system object */
9D0027AC  8FC2002C   LW V0, 44(S8)
9D0027B0  A0400000   SB ZERO, 0(V0)
2084:                    fs->drv = LD2PD(vol); /* Bind the logical drive and a physical drive */
9D0027B4  8FC20014   LW V0, 20(S8)
9D0027B8  304300FF   ANDI V1, V0, 255
9D0027BC  8FC2002C   LW V0, 44(S8)
9D0027C0  A0430001   SB V1, 1(V0)
2085:                    stat = disk_initialize(fs->drv); /* Initialize low level disk I/O layer */
9D0027C4  8FC2002C   LW V0, 44(S8)
9D0027C8  90420001   LBU V0, 1(V0)
9D0027CC  00402021   ADDU A0, V0, ZERO
9D0027D0  0F402045   JAL disk_initialize
9D0027D4  00000000   NOP
9D0027D8  A3C20030   SB V0, 48(S8)
2086:                    if (stat & STA_NOINIT) /* Check if the initialization succeeded */
9D0027DC  93C20030   LBU V0, 48(S8)
9D0027E0  30420001   ANDI V0, V0, 1
9D0027E4  304200FF   ANDI V0, V0, 255
9D0027E8  10400004   BEQ V0, ZERO, 0x9D0027FC
9D0027EC  00000000   NOP
2087:                        return FR_NOT_READY; /* Failed to initialize due to no media or hard error */
9D0027F0  24020003   ADDIU V0, ZERO, 3
9D0027F4  0B400C1F   J 0x9D00307C
9D0027F8  00000000   NOP
2088:                    if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT)) /* Check disk write protection if needed */
9D0027FC  93C20058   LBU V0, 88(S8)
9D002800  10400008   BEQ V0, ZERO, 0x9D002824
9D002804  00000000   NOP
9D002808  93C20030   LBU V0, 48(S8)
9D00280C  30420004   ANDI V0, V0, 4
9D002810  10400004   BEQ V0, ZERO, 0x9D002824
9D002814  00000000   NOP
2089:                        return FR_WRITE_PROTECTED;
9D002818  2402000A   ADDIU V0, ZERO, 10
9D00281C  0B400C1F   J 0x9D00307C
9D002820  00000000   NOP
2090:                #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
2091:                    if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
2092:                        return FR_DISK_ERR;
2093:                #endif
2094:                    /* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
2095:                    fmt = check_fs(fs, bsect = 0); /* Load sector 0 and check if it is an FAT-VBR (in SFD) */
9D002824  AFC00018   SW ZERO, 24(S8)
9D002828  8FC4002C   LW A0, 44(S8)
9D00282C  8FC50018   LW A1, 24(S8)
9D002830  0F400936   JAL 0x9D0024D8
9D002834  00000000   NOP
9D002838  A3C20010   SB V0, 16(S8)
2096:                    if (LD2PT(vol) && !fmt) fmt = 1; /* Force non-SFD if the volume is forced partition */
2097:                    if (fmt == 1) { /* Not an FAT-VBR, the physical drive can be partitioned */
9D00283C  93C30010   LBU V1, 16(S8)
9D002840  24020001   ADDIU V0, ZERO, 1
9D002844  1462002C   BNE V1, V0, 0x9D0028F8
9D002848  00000000   NOP
2098:                        /* Check the partition listed in the partition table */
2099:                        pi = LD2PT(vol);
9D00284C  A3C00011   SB ZERO, 17(S8)
2100:                        if (pi) pi--;
9D002850  93C20011   LBU V0, 17(S8)
9D002854  10400004   BEQ V0, ZERO, 0x9D002868
9D002858  00000000   NOP
9D00285C  93C20011   LBU V0, 17(S8)
9D002860  2442FFFF   ADDIU V0, V0, -1
9D002864  A3C20011   SB V0, 17(S8)
2101:                        tbl = &fs->win[MBR_Table + pi * SZ_PTE]; /* Partition table */
9D002868  8FC2002C   LW V0, 44(S8)
9D00286C  24430034   ADDIU V1, V0, 52
9D002870  93C20011   LBU V0, 17(S8)
9D002874  00021100   SLL V0, V0, 4
9D002878  244201BE   ADDIU V0, V0, 446
9D00287C  00621021   ADDU V0, V1, V0
9D002880  AFC20034   SW V0, 52(S8)
2102:                        if (tbl[4]) { /* Is the partition existing? */
9D002884  8FC20034   LW V0, 52(S8)
9D002888  24420004   ADDIU V0, V0, 4
9D00288C  90420000   LBU V0, 0(V0)
9D002890  10400019   BEQ V0, ZERO, 0x9D0028F8
9D002894  00000000   NOP
2103:                            bsect = LD_DWORD(&tbl[8]); /* Partition offset in LBA */
9D002898  8FC20034   LW V0, 52(S8)
9D00289C  2442000B   ADDIU V0, V0, 11
9D0028A0  90420000   LBU V0, 0(V0)
9D0028A4  00021E00   SLL V1, V0, 24
9D0028A8  8FC20034   LW V0, 52(S8)
9D0028AC  2442000A   ADDIU V0, V0, 10
9D0028B0  90420000   LBU V0, 0(V0)
9D0028B4  00021400   SLL V0, V0, 16
9D0028B8  00621825   OR V1, V1, V0
9D0028BC  8FC20034   LW V0, 52(S8)
9D0028C0  24420009   ADDIU V0, V0, 9
9D0028C4  90420000   LBU V0, 0(V0)
9D0028C8  00021200   SLL V0, V0, 8
9D0028CC  00621825   OR V1, V1, V0
9D0028D0  8FC20034   LW V0, 52(S8)
9D0028D4  24420008   ADDIU V0, V0, 8
9D0028D8  90420000   LBU V0, 0(V0)
9D0028DC  00621025   OR V0, V1, V0
9D0028E0  AFC20018   SW V0, 24(S8)
2104:                            fmt = check_fs(fs, bsect); /* Check the partition */
9D0028E4  8FC4002C   LW A0, 44(S8)
9D0028E8  8FC50018   LW A1, 24(S8)
9D0028EC  0F400936   JAL 0x9D0024D8
9D0028F0  00000000   NOP
9D0028F4  A3C20010   SB V0, 16(S8)
2105:                        }
2106:                    }
2107:                    if (fmt == 3) return FR_DISK_ERR;
9D0028F8  93C30010   LBU V1, 16(S8)
9D0028FC  24020003   ADDIU V0, ZERO, 3
9D002900  14620004   BNE V1, V0, 0x9D002914
9D002904  00000000   NOP
9D002908  24020001   ADDIU V0, ZERO, 1
9D00290C  0B400C1F   J 0x9D00307C
9D002910  00000000   NOP
2108:                    if (fmt) return FR_NO_FILESYSTEM; /* No FAT volume is found */
9D002914  93C20010   LBU V0, 16(S8)
9D002918  10400004   BEQ V0, ZERO, 0x9D00292C
9D00291C  00000000   NOP
9D002920  2402000D   ADDIU V0, ZERO, 13
9D002924  0B400C1F   J 0x9D00307C
9D002928  00000000   NOP
2109:                
2110:                    /* An FAT volume is found. Following code initializes the file system object */
2111:                
2112:                    if (LD_WORD(fs->win + BPB_BytsPerSec) != SS(fs)) /* (BPB_BytsPerSec must be equal to the physical sector size) */
9D00292C  8FC2002C   LW V0, 44(S8)
9D002930  24420040   ADDIU V0, V0, 64
9D002934  90420000   LBU V0, 0(V0)
9D002938  00021200   SLL V0, V0, 8
9D00293C  7C021E20   SEH V1, V0
9D002940  8FC2002C   LW V0, 44(S8)
9D002944  2442003F   ADDIU V0, V0, 63
9D002948  90420000   LBU V0, 0(V0)
9D00294C  7C021620   SEH V0, V0
9D002950  00621025   OR V0, V1, V0
9D002954  7C021E20   SEH V1, V0
9D002958  24020200   ADDIU V0, ZERO, 512
9D00295C  10620004   BEQ V1, V0, 0x9D002970
9D002960  00000000   NOP
2113:                        return FR_NO_FILESYSTEM;
9D002964  2402000D   ADDIU V0, ZERO, 13
9D002968  0B400C1F   J 0x9D00307C
9D00296C  00000000   NOP
2114:                
2115:                    fasize = LD_WORD(fs->win + BPB_FATSz16); /* Number of sectors per FAT */
9D002970  8FC2002C   LW V0, 44(S8)
9D002974  2442004B   ADDIU V0, V0, 75
9D002978  90420000   LBU V0, 0(V0)
9D00297C  00021200   SLL V0, V0, 8
9D002980  7C021E20   SEH V1, V0
9D002984  8FC2002C   LW V0, 44(S8)
9D002988  2442004A   ADDIU V0, V0, 74
9D00298C  90420000   LBU V0, 0(V0)
9D002990  7C021620   SEH V0, V0
9D002994  00621025   OR V0, V1, V0
9D002998  7C021620   SEH V0, V0
9D00299C  3042FFFF   ANDI V0, V0, -1
9D0029A0  AFC2001C   SW V0, 28(S8)
2116:                    if (!fasize) fasize = LD_DWORD(fs->win + BPB_FATSz32);
9D0029A4  8FC2001C   LW V0, 28(S8)
9D0029A8  14400014   BNE V0, ZERO, 0x9D0029FC
9D0029AC  00000000   NOP
9D0029B0  8FC2002C   LW V0, 44(S8)
9D0029B4  2442005B   ADDIU V0, V0, 91
9D0029B8  90420000   LBU V0, 0(V0)
9D0029BC  00021E00   SLL V1, V0, 24
9D0029C0  8FC2002C   LW V0, 44(S8)
9D0029C4  2442005A   ADDIU V0, V0, 90
9D0029C8  90420000   LBU V0, 0(V0)
9D0029CC  00021400   SLL V0, V0, 16
9D0029D0  00621825   OR V1, V1, V0
9D0029D4  8FC2002C   LW V0, 44(S8)
9D0029D8  24420059   ADDIU V0, V0, 89
9D0029DC  90420000   LBU V0, 0(V0)
9D0029E0  00021200   SLL V0, V0, 8
9D0029E4  00621825   OR V1, V1, V0
9D0029E8  8FC2002C   LW V0, 44(S8)
9D0029EC  24420058   ADDIU V0, V0, 88
9D0029F0  90420000   LBU V0, 0(V0)
9D0029F4  00621025   OR V0, V1, V0
9D0029F8  AFC2001C   SW V0, 28(S8)
2117:                    fs->fsize = fasize;
9D0029FC  8FC2002C   LW V0, 44(S8)
9D002A00  8FC3001C   LW V1, 28(S8)
9D002A04  AC430020   SW V1, 32(V0)
2118:                
2119:                    fs->n_fats = b = fs->win[BPB_NumFATs]; /* Number of FAT copies */
9D002A08  8FC2002C   LW V0, 44(S8)
9D002A0C  90420044   LBU V0, 68(V0)
9D002A10  A3C20038   SB V0, 56(S8)
9D002A14  8FC2002C   LW V0, 44(S8)
9D002A18  93C30038   LBU V1, 56(S8)
9D002A1C  A0430003   SB V1, 3(V0)
2120:                    if (b != 1 && b != 2) return FR_NO_FILESYSTEM; /* (Must be 1 or 2) */
9D002A20  93C30038   LBU V1, 56(S8)
9D002A24  24020001   ADDIU V0, ZERO, 1
9D002A28  10620008   BEQ V1, V0, 0x9D002A4C
9D002A2C  00000000   NOP
9D002A30  93C30038   LBU V1, 56(S8)
9D002A34  24020002   ADDIU V0, ZERO, 2
9D002A38  10620004   BEQ V1, V0, 0x9D002A4C
9D002A3C  00000000   NOP
9D002A40  2402000D   ADDIU V0, ZERO, 13
9D002A44  0B400C1F   J 0x9D00307C
9D002A48  00000000   NOP
2121:                    fasize *= b; /* Number of sectors for FAT area */
9D002A4C  93C20038   LBU V0, 56(S8)
9D002A50  8FC3001C   LW V1, 28(S8)
9D002A54  70621002   MUL V0, V1, V0
9D002A58  AFC2001C   SW V0, 28(S8)
2122:                
2123:                    fs->csize = b = fs->win[BPB_SecPerClus]; /* Number of sectors per cluster */
9D002A5C  8FC2002C   LW V0, 44(S8)
9D002A60  90420041   LBU V0, 65(V0)
9D002A64  A3C20038   SB V0, 56(S8)
9D002A68  8FC2002C   LW V0, 44(S8)
9D002A6C  93C30038   LBU V1, 56(S8)
9D002A70  A0430002   SB V1, 2(V0)
2124:                    if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM; /* (Must be power of 2) */
9D002A74  93C20038   LBU V0, 56(S8)
9D002A78  10400007   BEQ V0, ZERO, 0x9D002A98
9D002A7C  00000000   NOP
9D002A80  93C30038   LBU V1, 56(S8)
9D002A84  93C20038   LBU V0, 56(S8)
9D002A88  2442FFFF   ADDIU V0, V0, -1
9D002A8C  00621024   AND V0, V1, V0
9D002A90  10400004   BEQ V0, ZERO, 0x9D002AA4
9D002A94  00000000   NOP
9D002A98  2402000D   ADDIU V0, ZERO, 13
9D002A9C  0B400C1F   J 0x9D00307C
9D002AA0  00000000   NOP
2125:                
2126:                    fs->n_rootdir = LD_WORD(fs->win + BPB_RootEntCnt); /* Number of root directory entries */
9D002AA4  8FC2002C   LW V0, 44(S8)
9D002AA8  24420046   ADDIU V0, V0, 70
9D002AAC  90420000   LBU V0, 0(V0)
9D002AB0  00021200   SLL V0, V0, 8
9D002AB4  7C021E20   SEH V1, V0
9D002AB8  8FC2002C   LW V0, 44(S8)
9D002ABC  24420045   ADDIU V0, V0, 69
9D002AC0  90420000   LBU V0, 0(V0)
9D002AC4  7C021620   SEH V0, V0
9D002AC8  00621025   OR V0, V1, V0
9D002ACC  7C021620   SEH V0, V0
9D002AD0  3043FFFF   ANDI V1, V0, -1
9D002AD4  8FC2002C   LW V0, 44(S8)
9D002AD8  A4430008   SH V1, 8(V0)
2127:                    if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM; /* (BPB_RootEntCnt must be sector aligned) */
9D002ADC  8FC2002C   LW V0, 44(S8)
9D002AE0  94420008   LHU V0, 8(V0)
9D002AE4  3042000F   ANDI V0, V0, 15
9D002AE8  3042FFFF   ANDI V0, V0, -1
9D002AEC  10400004   BEQ V0, ZERO, 0x9D002B00
9D002AF0  00000000   NOP
9D002AF4  2402000D   ADDIU V0, ZERO, 13
9D002AF8  0B400C1F   J 0x9D00307C
9D002AFC  00000000   NOP
2128:                
2129:                    tsect = LD_WORD(fs->win + BPB_TotSec16); /* Number of sectors on the volume */
9D002B00  8FC2002C   LW V0, 44(S8)
9D002B04  24420048   ADDIU V0, V0, 72
9D002B08  90420000   LBU V0, 0(V0)
9D002B0C  00021200   SLL V0, V0, 8
9D002B10  7C021E20   SEH V1, V0
9D002B14  8FC2002C   LW V0, 44(S8)
9D002B18  24420047   ADDIU V0, V0, 71
9D002B1C  90420000   LBU V0, 0(V0)
9D002B20  7C021620   SEH V0, V0
9D002B24  00621025   OR V0, V1, V0
9D002B28  7C021620   SEH V0, V0
9D002B2C  3042FFFF   ANDI V0, V0, -1
9D002B30  AFC20020   SW V0, 32(S8)
2130:                    if (!tsect) tsect = LD_DWORD(fs->win + BPB_TotSec32);
9D002B34  8FC20020   LW V0, 32(S8)
9D002B38  14400014   BNE V0, ZERO, 0x9D002B8C
9D002B3C  00000000   NOP
9D002B40  8FC2002C   LW V0, 44(S8)
9D002B44  24420057   ADDIU V0, V0, 87
9D002B48  90420000   LBU V0, 0(V0)
9D002B4C  00021E00   SLL V1, V0, 24
9D002B50  8FC2002C   LW V0, 44(S8)
9D002B54  24420056   ADDIU V0, V0, 86
9D002B58  90420000   LBU V0, 0(V0)
9D002B5C  00021400   SLL V0, V0, 16
9D002B60  00621825   OR V1, V1, V0
9D002B64  8FC2002C   LW V0, 44(S8)
9D002B68  24420055   ADDIU V0, V0, 85
9D002B6C  90420000   LBU V0, 0(V0)
9D002B70  00021200   SLL V0, V0, 8
9D002B74  00621825   OR V1, V1, V0
9D002B78  8FC2002C   LW V0, 44(S8)
9D002B7C  24420054   ADDIU V0, V0, 84
9D002B80  90420000   LBU V0, 0(V0)
9D002B84  00621025   OR V0, V1, V0
9D002B88  AFC20020   SW V0, 32(S8)
2131:                
2132:                    nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt); /* Number of reserved sectors */
9D002B8C  8FC2002C   LW V0, 44(S8)
9D002B90  24420043   ADDIU V0, V0, 67
9D002B94  90420000   LBU V0, 0(V0)
9D002B98  00021200   SLL V0, V0, 8
9D002B9C  7C021E20   SEH V1, V0
9D002BA0  8FC2002C   LW V0, 44(S8)
9D002BA4  24420042   ADDIU V0, V0, 66
9D002BA8  90420000   LBU V0, 0(V0)
9D002BAC  7C021620   SEH V0, V0
9D002BB0  00621025   OR V0, V1, V0
9D002BB4  7C021620   SEH V0, V0
9D002BB8  A7C2003A   SH V0, 58(S8)
2133:                    if (!nrsv) return FR_NO_FILESYSTEM; /* (BPB_RsvdSecCnt must not be 0) */
9D002BBC  97C2003A   LHU V0, 58(S8)
9D002BC0  14400004   BNE V0, ZERO, 0x9D002BD4
9D002BC4  00000000   NOP
9D002BC8  2402000D   ADDIU V0, ZERO, 13
9D002BCC  0B400C1F   J 0x9D00307C
9D002BD0  00000000   NOP
2134:                
2135:                    /* Determine the FAT sub type */
2136:                    sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR); /* RSV+FAT+DIR */
9D002BD4  97C3003A   LHU V1, 58(S8)
9D002BD8  8FC2001C   LW V0, 28(S8)
9D002BDC  00621821   ADDU V1, V1, V0
9D002BE0  8FC2002C   LW V0, 44(S8)
9D002BE4  94420008   LHU V0, 8(V0)
9D002BE8  00021102   SRL V0, V0, 4
9D002BEC  3042FFFF   ANDI V0, V0, -1
9D002BF0  00621021   ADDU V0, V1, V0
9D002BF4  AFC2003C   SW V0, 60(S8)
2137:                    if (tsect < sysect) return FR_NO_FILESYSTEM; /* (Invalid volume size) */
9D002BF8  8FC30020   LW V1, 32(S8)
9D002BFC  8FC2003C   LW V0, 60(S8)
9D002C00  0062102B   SLTU V0, V1, V0
9D002C04  10400004   BEQ V0, ZERO, 0x9D002C18
9D002C08  00000000   NOP
9D002C0C  2402000D   ADDIU V0, ZERO, 13
9D002C10  0B400C1F   J 0x9D00307C
9D002C14  00000000   NOP
2138:                    nclst = (tsect - sysect) / fs->csize; /* Number of clusters */
9D002C18  8FC30020   LW V1, 32(S8)
9D002C1C  8FC2003C   LW V0, 60(S8)
9D002C20  00621823   SUBU V1, V1, V0
9D002C24  8FC2002C   LW V0, 44(S8)
9D002C28  90420002   LBU V0, 2(V0)
9D002C2C  0062001B   DIVU V1, V0
9D002C30  004001F4   TEQ V0, ZERO
9D002C34  00001810   MFHI V1
9D002C38  00001012   MFLO V0
9D002C3C  AFC20040   SW V0, 64(S8)
2139:                    if (!nclst) return FR_NO_FILESYSTEM; /* (Invalid volume size) */
9D002C40  8FC20040   LW V0, 64(S8)
9D002C44  14400004   BNE V0, ZERO, 0x9D002C58
9D002C48  00000000   NOP
9D002C4C  2402000D   ADDIU V0, ZERO, 13
9D002C50  0B400C1F   J 0x9D00307C
9D002C54  00000000   NOP
2140:                    fmt = FS_FAT12;
9D002C58  24020001   ADDIU V0, ZERO, 1
9D002C5C  A3C20010   SB V0, 16(S8)
2141:                    if (nclst >= MIN_FAT16) fmt = FS_FAT16;
9D002C60  8FC20040   LW V0, 64(S8)
9D002C64  2C420FF6   SLTIU V0, V0, 4086
9D002C68  14400003   BNE V0, ZERO, 0x9D002C78
9D002C6C  00000000   NOP
9D002C70  24020002   ADDIU V0, ZERO, 2
9D002C74  A3C20010   SB V0, 16(S8)
2142:                    if (nclst >= MIN_FAT32) fmt = FS_FAT32;
9D002C78  8FC30040   LW V1, 64(S8)
9D002C7C  3402FFF6   ORI V0, ZERO, -10
9D002C80  0062102B   SLTU V0, V1, V0
9D002C84  14400003   BNE V0, ZERO, 0x9D002C94
9D002C88  00000000   NOP
9D002C8C  24020003   ADDIU V0, ZERO, 3
9D002C90  A3C20010   SB V0, 16(S8)
2143:                
2144:                    /* Boundaries and Limits */
2145:                    fs->n_fatent = nclst + 2; /* Number of FAT entries */
9D002C94  8FC20040   LW V0, 64(S8)
9D002C98  24430002   ADDIU V1, V0, 2
9D002C9C  8FC2002C   LW V0, 44(S8)
9D002CA0  AC43001C   SW V1, 28(V0)
2146:                    fs->database = bsect + sysect; /* Data start sector */
9D002CA4  8FC30018   LW V1, 24(S8)
9D002CA8  8FC2003C   LW V0, 60(S8)
9D002CAC  00621821   ADDU V1, V1, V0
9D002CB0  8FC2002C   LW V0, 44(S8)
9D002CB4  AC43002C   SW V1, 44(V0)
2147:                    fs->fatbase = bsect + nrsv; /* FAT start sector */
9D002CB8  97C3003A   LHU V1, 58(S8)
9D002CBC  8FC20018   LW V0, 24(S8)
9D002CC0  00621821   ADDU V1, V1, V0
9D002CC4  8FC2002C   LW V0, 44(S8)
9D002CC8  AC430024   SW V1, 36(V0)
2148:                    if (fmt == FS_FAT32) {
9D002CCC  93C30010   LBU V1, 16(S8)
9D002CD0  24020003   ADDIU V0, ZERO, 3
9D002CD4  14620022   BNE V1, V0, 0x9D002D60
9D002CD8  00000000   NOP
2149:                        if (fs->n_rootdir) return FR_NO_FILESYSTEM; /* (BPB_RootEntCnt must be 0) */
9D002CDC  8FC2002C   LW V0, 44(S8)
9D002CE0  94420008   LHU V0, 8(V0)
9D002CE4  10400004   BEQ V0, ZERO, 0x9D002CF8
9D002CE8  00000000   NOP
9D002CEC  2402000D   ADDIU V0, ZERO, 13
9D002CF0  0B400C1F   J 0x9D00307C
9D002CF4  00000000   NOP
2150:                        fs->dirbase = LD_DWORD(fs->win + BPB_RootClus); /* Root directory start cluster */
9D002CF8  8FC2002C   LW V0, 44(S8)
9D002CFC  24420063   ADDIU V0, V0, 99
9D002D00  90420000   LBU V0, 0(V0)
9D002D04  00021E00   SLL V1, V0, 24
9D002D08  8FC2002C   LW V0, 44(S8)
9D002D0C  24420062   ADDIU V0, V0, 98
9D002D10  90420000   LBU V0, 0(V0)
9D002D14  00021400   SLL V0, V0, 16
9D002D18  00621825   OR V1, V1, V0
9D002D1C  8FC2002C   LW V0, 44(S8)
9D002D20  24420061   ADDIU V0, V0, 97
9D002D24  90420000   LBU V0, 0(V0)
9D002D28  00021200   SLL V0, V0, 8
9D002D2C  00621825   OR V1, V1, V0
9D002D30  8FC2002C   LW V0, 44(S8)
9D002D34  24420060   ADDIU V0, V0, 96
9D002D38  90420000   LBU V0, 0(V0)
9D002D3C  00621825   OR V1, V1, V0
9D002D40  8FC2002C   LW V0, 44(S8)
9D002D44  AC430028   SW V1, 40(V0)
2151:                        szbfat = fs->n_fatent * 4; /* (Required FAT size) */
9D002D48  8FC2002C   LW V0, 44(S8)
9D002D4C  8C42001C   LW V0, 28(V0)
9D002D50  00021080   SLL V0, V0, 2
9D002D54  AFC20024   SW V0, 36(S8)
9D002D58  0B400B78   J 0x9D002DE0
9D002D5C  00000000   NOP
2152:                    } else {
2153:                        if (!fs->n_rootdir) return FR_NO_FILESYSTEM; /* (BPB_RootEntCnt must not be 0) */
9D002D60  8FC2002C   LW V0, 44(S8)
9D002D64  94420008   LHU V0, 8(V0)
9D002D68  14400004   BNE V0, ZERO, 0x9D002D7C
9D002D6C  00000000   NOP
9D002D70  2402000D   ADDIU V0, ZERO, 13
9D002D74  0B400C1F   J 0x9D00307C
9D002D78  00000000   NOP
2154:                        fs->dirbase = fs->fatbase + fasize; /* Root directory start sector */
9D002D7C  8FC2002C   LW V0, 44(S8)
9D002D80  8C430024   LW V1, 36(V0)
9D002D84  8FC2001C   LW V0, 28(S8)
9D002D88  00621821   ADDU V1, V1, V0
9D002D8C  8FC2002C   LW V0, 44(S8)
9D002D90  AC430028   SW V1, 40(V0)
2155:                        szbfat = (fmt == FS_FAT16) ? /* (Required FAT size) */
9D002DDC  AFC20024   SW V0, 36(S8)
2156:                                fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
9D002D94  93C30010   LBU V1, 16(S8)
9D002D98  24020002   ADDIU V0, ZERO, 2
9D002D9C  14620006   BNE V1, V0, 0x9D002DB8
9D002DA0  00000000   NOP
9D002DA4  8FC2002C   LW V0, 44(S8)
9D002DA8  8C42001C   LW V0, 28(V0)
9D002DAC  00021040   SLL V0, V0, 1
9D002DB0  0B400B77   J 0x9D002DDC
9D002DB4  00000000   NOP
9D002DB8  8FC2002C   LW V0, 44(S8)
9D002DBC  8C43001C   LW V1, 28(V0)
9D002DC0  24020003   ADDIU V0, ZERO, 3
9D002DC4  70621002   MUL V0, V1, V0
9D002DC8  00021842   SRL V1, V0, 1
9D002DCC  8FC2002C   LW V0, 44(S8)
9D002DD0  8C42001C   LW V0, 28(V0)
9D002DD4  30420001   ANDI V0, V0, 1
9D002DD8  00621021   ADDU V0, V1, V0
2157:                    }
2158:                    if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) /* (BPB_FATSz must not be less than required) */
9D002DE0  8FC2002C   LW V0, 44(S8)
9D002DE4  8C430020   LW V1, 32(V0)
9D002DE8  8FC20024   LW V0, 36(S8)
9D002DEC  244201FF   ADDIU V0, V0, 511
9D002DF0  00021242   SRL V0, V0, 9
9D002DF4  0062102B   SLTU V0, V1, V0
9D002DF8  10400004   BEQ V0, ZERO, 0x9D002E0C
9D002DFC  00000000   NOP
2159:                        return FR_NO_FILESYSTEM;
9D002E00  2402000D   ADDIU V0, ZERO, 13
9D002E04  0B400C1F   J 0x9D00307C
9D002E08  00000000   NOP
2160:                
2161:                #if !_FS_READONLY
2162:                    /* Initialize cluster allocation information */
2163:                    fs->free_clust = 0xFFFFFFFF;
9D002E0C  8FC2002C   LW V0, 44(S8)
9D002E10  2403FFFF   ADDIU V1, ZERO, -1
9D002E14  AC430010   SW V1, 16(V0)
2164:                    fs->last_clust = 0;
9D002E18  8FC2002C   LW V0, 44(S8)
9D002E1C  AC40000C   SW ZERO, 12(V0)
2165:                
2166:                    /* Get fsinfo if available */
2167:                    if (fmt == FS_FAT32) {
9D002E20  93C30010   LBU V1, 16(S8)
9D002E24  24020003   ADDIU V0, ZERO, 3
9D002E28  14620083   BNE V1, V0, 0x9D003038
9D002E2C  00000000   NOP
2168:                        fs->fsi_flag = 0;
9D002E30  8FC2002C   LW V0, 44(S8)
9D002E34  A0400005   SB ZERO, 5(V0)
2169:                        fs->fsi_sector = bsect + LD_WORD(fs->win + BPB_FSInfo);
9D002E38  8FC2002C   LW V0, 44(S8)
9D002E3C  24420065   ADDIU V0, V0, 101
9D002E40  90420000   LBU V0, 0(V0)
9D002E44  00021200   SLL V0, V0, 8
9D002E48  7C021E20   SEH V1, V0
9D002E4C  8FC2002C   LW V0, 44(S8)
9D002E50  24420064   ADDIU V0, V0, 100
9D002E54  90420000   LBU V0, 0(V0)
9D002E58  7C021620   SEH V0, V0
9D002E5C  00621025   OR V0, V1, V0
9D002E60  7C021620   SEH V0, V0
9D002E64  3042FFFF   ANDI V0, V0, -1
9D002E68  00401821   ADDU V1, V0, ZERO
9D002E6C  8FC20018   LW V0, 24(S8)
9D002E70  00621821   ADDU V1, V1, V0
9D002E74  8FC2002C   LW V0, 44(S8)
9D002E78  AC430014   SW V1, 20(V0)
2170:                        if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
9D002E7C  8FC2002C   LW V0, 44(S8)
9D002E80  90420001   LBU V0, 1(V0)
9D002E84  00402021   ADDU A0, V0, ZERO
9D002E88  8FC2002C   LW V0, 44(S8)
9D002E8C  24430034   ADDIU V1, V0, 52
9D002E90  8FC2002C   LW V0, 44(S8)
9D002E94  8C420014   LW V0, 20(V0)
9D002E98  00602821   ADDU A1, V1, ZERO
9D002E9C  00403021   ADDU A2, V0, ZERO
9D002EA0  24070001   ADDIU A3, ZERO, 1
9D002EA4  0F402130   JAL disk_read
9D002EA8  00000000   NOP
9D002EAC  14400062   BNE V0, ZERO, 0x9D003038
9D002EB0  00000000   NOP
9D002EE0  2402AA55   ADDIU V0, ZERO, -21931
9D002EE4  14620054   BNE V1, V0, 0x9D003038
9D002EE8  00000000   NOP
2171:                                LD_WORD(fs->win + BS_55AA) == 0xAA55 &&
9D002EB4  8FC2002C   LW V0, 44(S8)
9D002EB8  24420233   ADDIU V0, V0, 563
9D002EBC  90420000   LBU V0, 0(V0)
9D002EC0  00021200   SLL V0, V0, 8
9D002EC4  7C021E20   SEH V1, V0
9D002EC8  8FC2002C   LW V0, 44(S8)
9D002ECC  24420232   ADDIU V0, V0, 562
9D002ED0  90420000   LBU V0, 0(V0)
9D002ED4  7C021620   SEH V0, V0
9D002ED8  00621025   OR V0, V1, V0
9D002EDC  7C021E20   SEH V1, V0
9D002F30  3C024161   LUI V0, 16737
9D002F34  34425252   ORI V0, V0, 21074
9D002F38  1462003F   BNE V1, V0, 0x9D003038
9D002F3C  00000000   NOP
2172:                                LD_DWORD(fs->win + FSI_LeadSig) == 0x41615252 &&
9D002EEC  8FC2002C   LW V0, 44(S8)
9D002EF0  24420037   ADDIU V0, V0, 55
9D002EF4  90420000   LBU V0, 0(V0)
9D002EF8  00021E00   SLL V1, V0, 24
9D002EFC  8FC2002C   LW V0, 44(S8)
9D002F00  24420036   ADDIU V0, V0, 54
9D002F04  90420000   LBU V0, 0(V0)
9D002F08  00021400   SLL V0, V0, 16
9D002F0C  00621825   OR V1, V1, V0
9D002F10  8FC2002C   LW V0, 44(S8)
9D002F14  24420035   ADDIU V0, V0, 53
9D002F18  90420000   LBU V0, 0(V0)
9D002F1C  00021200   SLL V0, V0, 8
9D002F20  00621825   OR V1, V1, V0
9D002F24  8FC2002C   LW V0, 44(S8)
9D002F28  90420034   LBU V0, 52(V0)
9D002F2C  00621825   OR V1, V1, V0
9D002F88  3C026141   LUI V0, 24897
9D002F8C  34427272   ORI V0, V0, 29298
9D002F90  14620029   BNE V1, V0, 0x9D003038
9D002F94  00000000   NOP
2173:                                LD_DWORD(fs->win + FSI_StrucSig) == 0x61417272) {
9D002F40  8FC2002C   LW V0, 44(S8)
9D002F44  2442021B   ADDIU V0, V0, 539
9D002F48  90420000   LBU V0, 0(V0)
9D002F4C  00021E00   SLL V1, V0, 24
9D002F50  8FC2002C   LW V0, 44(S8)
9D002F54  2442021A   ADDIU V0, V0, 538
9D002F58  90420000   LBU V0, 0(V0)
9D002F5C  00021400   SLL V0, V0, 16
9D002F60  00621825   OR V1, V1, V0
9D002F64  8FC2002C   LW V0, 44(S8)
9D002F68  24420219   ADDIU V0, V0, 537
9D002F6C  90420000   LBU V0, 0(V0)
9D002F70  00021200   SLL V0, V0, 8
9D002F74  00621825   OR V1, V1, V0
9D002F78  8FC2002C   LW V0, 44(S8)
9D002F7C  24420218   ADDIU V0, V0, 536
9D002F80  90420000   LBU V0, 0(V0)
9D002F84  00621825   OR V1, V1, V0
2174:                            fs->last_clust = LD_DWORD(fs->win + FSI_Nxt_Free);
9D002F98  8FC2002C   LW V0, 44(S8)
9D002F9C  24420223   ADDIU V0, V0, 547
9D002FA0  90420000   LBU V0, 0(V0)
9D002FA4  00021E00   SLL V1, V0, 24
9D002FA8  8FC2002C   LW V0, 44(S8)
9D002FAC  24420222   ADDIU V0, V0, 546
9D002FB0  90420000   LBU V0, 0(V0)
9D002FB4  00021400   SLL V0, V0, 16
9D002FB8  00621825   OR V1, V1, V0
9D002FBC  8FC2002C   LW V0, 44(S8)
9D002FC0  24420221   ADDIU V0, V0, 545
9D002FC4  90420000   LBU V0, 0(V0)
9D002FC8  00021200   SLL V0, V0, 8
9D002FCC  00621825   OR V1, V1, V0
9D002FD0  8FC2002C   LW V0, 44(S8)
9D002FD4  24420220   ADDIU V0, V0, 544
9D002FD8  90420000   LBU V0, 0(V0)
9D002FDC  00621825   OR V1, V1, V0
9D002FE0  8FC2002C   LW V0, 44(S8)
9D002FE4  AC43000C   SW V1, 12(V0)
2175:                            fs->free_clust = LD_DWORD(fs->win + FSI_Free_Count);
9D002FE8  8FC2002C   LW V0, 44(S8)
9D002FEC  2442021F   ADDIU V0, V0, 543
9D002FF0  90420000   LBU V0, 0(V0)
9D002FF4  00021E00   SLL V1, V0, 24
9D002FF8  8FC2002C   LW V0, 44(S8)
9D002FFC  2442021E   ADDIU V0, V0, 542
9D003000  90420000   LBU V0, 0(V0)
9D003004  00021400   SLL V0, V0, 16
9D003008  00621825   OR V1, V1, V0
9D00300C  8FC2002C   LW V0, 44(S8)
9D003010  2442021D   ADDIU V0, V0, 541
9D003014  90420000   LBU V0, 0(V0)
9D003018  00021200   SLL V0, V0, 8
9D00301C  00621825   OR V1, V1, V0
9D003020  8FC2002C   LW V0, 44(S8)
9D003024  2442021C   ADDIU V0, V0, 540
9D003028  90420000   LBU V0, 0(V0)
9D00302C  00621825   OR V1, V1, V0
9D003030  8FC2002C   LW V0, 44(S8)
9D003034  AC430010   SW V1, 16(V0)
2176:                        }
2177:                    }
2178:                #endif
2179:                    fs->fs_type = fmt; /* FAT sub-type */
9D003038  8FC2002C   LW V0, 44(S8)
9D00303C  93C30010   LBU V1, 16(S8)
9D003040  A0430000   SB V1, 0(V0)
2180:                    fs->id = ++Fsid; /* File system mount ID */
9D003044  9782805C   LHU V0, -32676(GP)
9D003048  24420001   ADDIU V0, V0, 1
9D00304C  3042FFFF   ANDI V0, V0, -1
9D003050  A782805C   SH V0, -32676(GP)
9D003054  9783805C   LHU V1, -32676(GP)
9D003058  8FC2002C   LW V0, 44(S8)
9D00305C  A4430006   SH V1, 6(V0)
2181:                    fs->winsect = 0; /* Invalidate sector cache */
9D003060  8FC2002C   LW V0, 44(S8)
9D003064  AC400030   SW ZERO, 48(V0)
2182:                    fs->wflag = 0;
9D003068  8FC2002C   LW V0, 44(S8)
9D00306C  A0400004   SB ZERO, 4(V0)
2183:                #if _FS_RPATH
2184:                    fs->cdir = 0; /* Current directory (root dir) */
9D003070  8FC2002C   LW V0, 44(S8)
9D003074  AC400018   SW ZERO, 24(V0)
2185:                #endif
2186:                #if _FS_SHARE				/* Clear file lock semaphores */
2187:                    clear_lock(fs);
2188:                #endif
2189:                
2190:                    return FR_OK;
9D003078  00001021   ADDU V0, ZERO, ZERO
2191:                }
9D00307C  03C0E821   ADDU SP, S8, ZERO
9D003080  8FBF004C   LW RA, 76(SP)
9D003084  8FBE0048   LW S8, 72(SP)
9D003088  27BD0050   ADDIU SP, SP, 80
9D00308C  03E00008   JR RA
9D003090  00000000   NOP
2192:                
2193:                
2194:                
2195:                
2196:                /*-----------------------------------------------------------------------*/
2197:                /* Check if the file/dir object is valid or not                          */
2198:                
2199:                /*-----------------------------------------------------------------------*/
2200:                
2201:                static
2202:                FRESULT validate(/* FR_OK(0): The object is valid, !=0: Invalid */
2203:                        FATFS *fs, /* Pointer to the file system object */
2204:                        WORD id /* Member id of the target object to be checked */
2205:                        ) {
9D003094  27BDFFE8   ADDIU SP, SP, -24
9D003098  AFBF0014   SW RA, 20(SP)
9D00309C  AFBE0010   SW S8, 16(SP)
9D0030A0  03A0F021   ADDU S8, SP, ZERO
9D0030A4  AFC40018   SW A0, 24(S8)
9D0030A8  00A01021   ADDU V0, A1, ZERO
9D0030AC  A7C2001C   SH V0, 28(S8)
2206:                    if (!fs || !fs->fs_type || fs->id != id)
9D0030B0  8FC20018   LW V0, 24(S8)
9D0030B4  1040000A   BEQ V0, ZERO, 0x9D0030E0
9D0030B8  00000000   NOP
9D0030BC  8FC20018   LW V0, 24(S8)
9D0030C0  90420000   LBU V0, 0(V0)
9D0030C4  10400006   BEQ V0, ZERO, 0x9D0030E0
9D0030C8  00000000   NOP
9D0030CC  8FC20018   LW V0, 24(S8)
9D0030D0  94420006   LHU V0, 6(V0)
9D0030D4  97C3001C   LHU V1, 28(S8)
9D0030D8  10620004   BEQ V1, V0, 0x9D0030EC
9D0030DC  00000000   NOP
2207:                        return FR_INVALID_OBJECT;
9D0030E0  24020009   ADDIU V0, ZERO, 9
9D0030E4  0B400C48   J 0x9D003120
9D0030E8  00000000   NOP
2208:                
2209:                    ENTER_FF(fs); /* Lock file system */
2210:                
2211:                    if (disk_status(fs->drv) & STA_NOINIT)
9D0030EC  8FC20018   LW V0, 24(S8)
9D0030F0  90420001   LBU V0, 1(V0)
9D0030F4  00402021   ADDU A0, V0, ZERO
9D0030F8  0F40211E   JAL disk_status
9D0030FC  00000000   NOP
9D003100  30420001   ANDI V0, V0, 1
9D003104  304200FF   ANDI V0, V0, 255
9D003108  10400004   BEQ V0, ZERO, 0x9D00311C
9D00310C  00000000   NOP
2212:                        return FR_NOT_READY;
9D003110  24020003   ADDIU V0, ZERO, 3
9D003114  0B400C48   J 0x9D003120
9D003118  00000000   NOP
2213:                
2214:                    return FR_OK;
9D00311C  00001021   ADDU V0, ZERO, ZERO
2215:                }
9D003120  03C0E821   ADDU SP, S8, ZERO
9D003124  8FBF0014   LW RA, 20(SP)
9D003128  8FBE0010   LW S8, 16(SP)
9D00312C  27BD0018   ADDIU SP, SP, 24
9D003130  03E00008   JR RA
9D003134  00000000   NOP
2216:                
2217:                
2218:                
2219:                
2220:                /*--------------------------------------------------------------------------
2221:                
2222:                   Public Functions
2223:                
2224:                --------------------------------------------------------------------------*/
2225:                
2226:                
2227:                
2228:                /*-----------------------------------------------------------------------*/
2229:                /* Mount/Unmount a Logical Drive                                         */
2230:                
2231:                /*-----------------------------------------------------------------------*/
2232:                
2233:                FRESULT f_mount(
2234:                        BYTE vol, /* Logical drive number to be mounted/unmounted */
2235:                        FATFS *fs /* Pointer to new file system object (NULL for unmount)*/
2236:                        ) {
9D003138  27BDFFF0   ADDIU SP, SP, -16
9D00313C  AFBE000C   SW S8, 12(SP)
9D003140  03A0F021   ADDU S8, SP, ZERO
9D003144  00801021   ADDU V0, A0, ZERO
9D003148  AFC50014   SW A1, 20(S8)
9D00314C  A3C20010   SB V0, 16(S8)
2237:                    FATFS *rfs;
2238:                
2239:                
2240:                    if (vol >= _VOLUMES) /* Check if the drive number is valid */
9D003150  93C20010   LBU V0, 16(S8)
9D003154  10400004   BEQ V0, ZERO, 0x9D003168
9D003158  00000000   NOP
2241:                        return FR_INVALID_DRIVE;
9D00315C  2402000B   ADDIU V0, ZERO, 11
9D003160  0B400C71   J 0x9D0031C4
9D003164  00000000   NOP
2242:                    rfs = FatFs[vol]; /* Get current fs object */
9D003168  93C20010   LBU V0, 16(S8)
9D00316C  00021880   SLL V1, V0, 2
9D003170  27828058   ADDIU V0, GP, -32680
9D003174  00621021   ADDU V0, V1, V0
9D003178  8C420000   LW V0, 0(V0)
9D00317C  AFC20000   SW V0, 0(S8)
2243:                
2244:                    if (rfs) {
9D003180  8FC20000   LW V0, 0(S8)
9D003184  10400003   BEQ V0, ZERO, 0x9D003194
9D003188  00000000   NOP
2245:                #if _FS_SHARE
2246:                        clear_lock(rfs);
2247:                #endif
2248:                #if _FS_REENTRANT				/* Discard sync object of the current volume */
2249:                        if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
2250:                #endif
2251:                        rfs->fs_type = 0; /* Clear old fs object */
9D00318C  8FC20000   LW V0, 0(S8)
9D003190  A0400000   SB ZERO, 0(V0)
2252:                    }
2253:                
2254:                    if (fs) {
9D003194  8FC20014   LW V0, 20(S8)
9D003198  10400003   BEQ V0, ZERO, 0x9D0031A8
9D00319C  00000000   NOP
2255:                        fs->fs_type = 0; /* Clear new fs object */
9D0031A0  8FC20014   LW V0, 20(S8)
9D0031A4  A0400000   SB ZERO, 0(V0)
2256:                #if _FS_REENTRANT				/* Create sync object for the new volume */
2257:                        if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
2258:                #endif
2259:                    }
2260:                    FatFs[vol] = fs; /* Register new fs object */
9D0031A8  93C20010   LBU V0, 16(S8)
9D0031AC  00021880   SLL V1, V0, 2
9D0031B0  27828058   ADDIU V0, GP, -32680
9D0031B4  00621021   ADDU V0, V1, V0
9D0031B8  8FC30014   LW V1, 20(S8)
9D0031BC  AC430000   SW V1, 0(V0)
2261:                
2262:                    return FR_OK;
9D0031C0  00001021   ADDU V0, ZERO, ZERO
2263:                }
9D0031C4  03C0E821   ADDU SP, S8, ZERO
9D0031C8  8FBE000C   LW S8, 12(SP)
9D0031CC  27BD0010   ADDIU SP, SP, 16
9D0031D0  03E00008   JR RA
9D0031D4  00000000   NOP
2264:                
2265:                
2266:                
2267:                
2268:                /*-----------------------------------------------------------------------*/
2269:                /* Open or Create a File                                                 */
2270:                
2271:                /*-----------------------------------------------------------------------*/
2272:                
2273:                FRESULT f_open(
2274:                        FIL *fp, /* Pointer to the blank file object */
2275:                        const TCHAR *path, /* Pointer to the file name */
2276:                        BYTE mode /* Access mode and file open mode flags */
2277:                        ) {
9D0031D8  27BDFFB0   ADDIU SP, SP, -80
9D0031DC  AFBF004C   SW RA, 76(SP)
9D0031E0  AFBE0048   SW S8, 72(SP)
9D0031E4  03A0F021   ADDU S8, SP, ZERO
9D0031E8  AFC40050   SW A0, 80(S8)
9D0031EC  AFC50054   SW A1, 84(S8)
9D0031F0  00C01021   ADDU V0, A2, ZERO
9D0031F4  A3C20058   SB V0, 88(S8)
2278:                    FRESULT res;
2279:                    DIR dj;
2280:                    BYTE *dir;
2281:                    DEF_NAMEBUF;
2282:                
2283:                
2284:                    fp->fs = 0; /* Clear file object */
9D0031F8  8FC20050   LW V0, 80(S8)
9D0031FC  AC400000   SW ZERO, 0(V0)
2285:                
2286:                #if !_FS_READONLY
2287:                    mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
9D003200  93C20058   LBU V0, 88(S8)
9D003204  3042001F   ANDI V0, V0, 31
9D003208  A3C20058   SB V0, 88(S8)
2288:                    res = chk_mounted(&path, &dj.fs, (BYTE) (mode & ~FA_READ));
9D00320C  93C20058   LBU V0, 88(S8)
9D003210  304200FE   ANDI V0, V0, 254
9D003214  27C40054   ADDIU A0, S8, 84
9D003218  27C30020   ADDIU V1, S8, 32
9D00321C  00602821   ADDU A1, V1, ZERO
9D003220  00403021   ADDU A2, V0, ZERO
9D003224  0F400998   JAL 0x9D002660
9D003228  00000000   NOP
9D00322C  AFC20010   SW V0, 16(S8)
2289:                #else
2290:                    mode &= FA_READ;
2291:                    res = chk_mounted(&path, &dj.fs, 0);
2292:                #endif
2293:                    INIT_BUF(dj);
9D003230  27C2003C   ADDIU V0, S8, 60
9D003234  AFC20038   SW V0, 56(S8)
2294:                    if (res == FR_OK)
9D003238  8FC20010   LW V0, 16(S8)
9D00323C  14400008   BNE V0, ZERO, 0x9D003260
9D003240  00000000   NOP
2295:                        res = follow_path(&dj, path); /* Follow the file path */
9D003244  8FC20054   LW V0, 84(S8)
9D003248  27C30020   ADDIU V1, S8, 32
9D00324C  00602021   ADDU A0, V1, ZERO
9D003250  00402821   ADDU A1, V0, ZERO
9D003254  0F400897   JAL 0x9D00225C
9D003258  00000000   NOP
9D00325C  AFC20010   SW V0, 16(S8)
2296:                    dir = dj.dir;
9D003260  8FC20034   LW V0, 52(S8)
9D003264  AFC20014   SW V0, 20(S8)
2297:                
2298:                #if !_FS_READONLY	/* R/W configuration */
2299:                    if (res == FR_OK) {
9D003268  8FC20010   LW V0, 16(S8)
9D00326C  14400006   BNE V0, ZERO, 0x9D003288
9D003270  00000000   NOP
2300:                        if (!dir) /* Current dir itself */
9D003274  8FC20014   LW V0, 20(S8)
9D003278  14400003   BNE V0, ZERO, 0x9D003288
9D00327C  00000000   NOP
2301:                            res = FR_INVALID_NAME;
9D003280  24020006   ADDIU V0, ZERO, 6
9D003284  AFC20010   SW V0, 16(S8)
2302:                #if _FS_SHARE
2303:                        else
2304:                            res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
2305:                #endif
2306:                    }
2307:                    /* Create or Open a file */
2308:                    if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
9D003288  93C20058   LBU V0, 88(S8)
9D00328C  3042001C   ANDI V0, V0, 28
9D003290  1040009B   BEQ V0, ZERO, 0x9D003500
9D003294  00000000   NOP
2309:                        DWORD dw, cl;
2310:                
2311:                        if (res != FR_OK) { /* No file, create new */
9D003298  8FC20010   LW V0, 16(S8)
9D00329C  10400011   BEQ V0, ZERO, 0x9D0032E4
9D0032A0  00000000   NOP
2312:                            if (res == FR_NO_FILE) /* There is no file to open, create a new entry */
9D0032A4  8FC30010   LW V1, 16(S8)
9D0032A8  24020004   ADDIU V0, ZERO, 4
9D0032AC  14620006   BNE V1, V0, 0x9D0032C8
9D0032B0  00000000   NOP
2313:                #if _FS_SHARE
2314:                                res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
2315:                #else
2316:                                res = dir_register(&dj);
9D0032B4  27C20020   ADDIU V0, S8, 32
9D0032B8  00402021   ADDU A0, V0, ZERO
9D0032BC  0F400665   JAL 0x9D001994
9D0032C0  00000000   NOP
9D0032C4  AFC20010   SW V0, 16(S8)
2317:                #endif
2318:                            mode |= FA_CREATE_ALWAYS; /* File is created */
9D0032C8  93C20058   LBU V0, 88(S8)
9D0032CC  34420008   ORI V0, V0, 8
9D0032D0  A3C20058   SB V0, 88(S8)
2319:                            dir = dj.dir; /* New entry */
9D0032D4  8FC20034   LW V0, 52(S8)
9D0032D8  AFC20014   SW V0, 20(S8)
9D0032DC  0B400CC9   J 0x9D003324
9D0032E0  00000000   NOP
2320:                        } else { /* Any object is already existing */
2321:                            if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) { /* Cannot overwrite it (R/O or DIR) */
9D0032E4  8FC20014   LW V0, 20(S8)
9D0032E8  2442000B   ADDIU V0, V0, 11
9D0032EC  90420000   LBU V0, 0(V0)
9D0032F0  30420011   ANDI V0, V0, 17
9D0032F4  10400005   BEQ V0, ZERO, 0x9D00330C
9D0032F8  00000000   NOP
2322:                                res = FR_DENIED;
9D0032FC  24020007   ADDIU V0, ZERO, 7
9D003300  AFC20010   SW V0, 16(S8)
9D003304  0B400CC9   J 0x9D003324
9D003308  00000000   NOP
2323:                            } else {
2324:                                if (mode & FA_CREATE_NEW) /* Cannot create as new file */
9D00330C  93C20058   LBU V0, 88(S8)
9D003310  30420004   ANDI V0, V0, 4
9D003314  10400003   BEQ V0, ZERO, 0x9D003324
9D003318  00000000   NOP
2325:                                    res = FR_EXIST;
9D00331C  24020008   ADDIU V0, ZERO, 8
9D003320  AFC20010   SW V0, 16(S8)
2326:                            }
2327:                        }
2328:                        if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) { /* Truncate it if overwrite mode */
9D003324  8FC20010   LW V0, 16(S8)
9D003328  1440008F   BNE V0, ZERO, 0x9D003568
9D00332C  00000000   NOP
9D003330  93C20058   LBU V0, 88(S8)
9D003334  30420008   ANDI V0, V0, 8
9D003338  1040008B   BEQ V0, ZERO, 0x9D003568
9D00333C  00000000   NOP
2329:                            dw = get_fattime(); /* Created time */
9D003340  0F402C66   JAL get_fattime
9D003344  00000000   NOP
9D003348  AFC20018   SW V0, 24(S8)
2330:                            ST_DWORD(dir + DIR_CrtTime, dw);
9D00334C  8FC20014   LW V0, 20(S8)
9D003350  2442000E   ADDIU V0, V0, 14
9D003354  8FC30018   LW V1, 24(S8)
9D003358  306300FF   ANDI V1, V1, 255
9D00335C  A0430000   SB V1, 0(V0)
9D003360  8FC20014   LW V0, 20(S8)
9D003364  2442000F   ADDIU V0, V0, 15
9D003368  8FC30018   LW V1, 24(S8)
9D00336C  3063FFFF   ANDI V1, V1, -1
9D003370  00031A02   SRL V1, V1, 8
9D003374  3063FFFF   ANDI V1, V1, -1
9D003378  306300FF   ANDI V1, V1, 255
9D00337C  A0430000   SB V1, 0(V0)
9D003380  8FC20014   LW V0, 20(S8)
9D003384  24420010   ADDIU V0, V0, 16
9D003388  8FC30018   LW V1, 24(S8)
9D00338C  00031C02   SRL V1, V1, 16
9D003390  306300FF   ANDI V1, V1, 255
9D003394  A0430000   SB V1, 0(V0)
9D003398  8FC20014   LW V0, 20(S8)
9D00339C  24420011   ADDIU V0, V0, 17
9D0033A0  8FC30018   LW V1, 24(S8)
9D0033A4  00031E02   SRL V1, V1, 24
9D0033A8  306300FF   ANDI V1, V1, 255
9D0033AC  A0430000   SB V1, 0(V0)
2331:                            dir[DIR_Attr] = 0; /* Reset attribute */
9D0033B0  8FC20014   LW V0, 20(S8)
9D0033B4  2442000B   ADDIU V0, V0, 11
9D0033B8  A0400000   SB ZERO, 0(V0)
2332:                            ST_DWORD(dir + DIR_FileSize, 0); /* size = 0 */
9D0033BC  8FC20014   LW V0, 20(S8)
9D0033C0  2442001C   ADDIU V0, V0, 28
9D0033C4  A0400000   SB ZERO, 0(V0)
9D0033C8  8FC20014   LW V0, 20(S8)
9D0033CC  2442001D   ADDIU V0, V0, 29
9D0033D0  A0400000   SB ZERO, 0(V0)
9D0033D4  8FC20014   LW V0, 20(S8)
9D0033D8  2442001E   ADDIU V0, V0, 30
9D0033DC  A0400000   SB ZERO, 0(V0)
9D0033E0  8FC20014   LW V0, 20(S8)
9D0033E4  2442001F   ADDIU V0, V0, 31
9D0033E8  A0400000   SB ZERO, 0(V0)
2333:                            cl = LD_CLUST(dir); /* Get start cluster */
9D0033EC  8FC20014   LW V0, 20(S8)
9D0033F0  24420015   ADDIU V0, V0, 21
9D0033F4  90420000   LBU V0, 0(V0)
9D0033F8  00021200   SLL V0, V0, 8
9D0033FC  7C021E20   SEH V1, V0
9D003400  8FC20014   LW V0, 20(S8)
9D003404  24420014   ADDIU V0, V0, 20
9D003408  90420000   LBU V0, 0(V0)
9D00340C  7C021620   SEH V0, V0
9D003410  00621025   OR V0, V1, V0
9D003414  7C021620   SEH V0, V0
9D003418  3042FFFF   ANDI V0, V0, -1
9D00341C  00021C00   SLL V1, V0, 16
9D003420  8FC20014   LW V0, 20(S8)
9D003424  2442001B   ADDIU V0, V0, 27
9D003428  90420000   LBU V0, 0(V0)
9D00342C  00021200   SLL V0, V0, 8
9D003430  7C022620   SEH A0, V0
9D003434  8FC20014   LW V0, 20(S8)
9D003438  2442001A   ADDIU V0, V0, 26
9D00343C  90420000   LBU V0, 0(V0)
9D003440  7C021620   SEH V0, V0
9D003444  00821025   OR V0, A0, V0
9D003448  7C021620   SEH V0, V0
9D00344C  3042FFFF   ANDI V0, V0, -1
9D003450  00621025   OR V0, V1, V0
9D003454  AFC2001C   SW V0, 28(S8)
2334:                            ST_CLUST(dir, 0); /* cluster = 0 */
9D003458  8FC20014   LW V0, 20(S8)
9D00345C  2442001A   ADDIU V0, V0, 26
9D003460  A0400000   SB ZERO, 0(V0)
9D003464  8FC20014   LW V0, 20(S8)
9D003468  2442001B   ADDIU V0, V0, 27
9D00346C  A0400000   SB ZERO, 0(V0)
9D003470  8FC20014   LW V0, 20(S8)
9D003474  24420014   ADDIU V0, V0, 20
9D003478  A0400000   SB ZERO, 0(V0)
9D00347C  8FC20014   LW V0, 20(S8)
9D003480  24420015   ADDIU V0, V0, 21
9D003484  A0400000   SB ZERO, 0(V0)
2335:                            dj.fs->wflag = 1;
9D003488  8FC20020   LW V0, 32(S8)
9D00348C  24030001   ADDIU V1, ZERO, 1
9D003490  A0430004   SB V1, 4(V0)
2336:                            if (cl) { /* Remove the cluster chain if exist */
9D003494  8FC2001C   LW V0, 28(S8)
9D003498  10400033   BEQ V0, ZERO, 0x9D003568
9D00349C  00000000   NOP
2337:                                dw = dj.fs->winsect;
9D0034A0  8FC20020   LW V0, 32(S8)
9D0034A4  8C420030   LW V0, 48(V0)
9D0034A8  AFC20018   SW V0, 24(S8)
2338:                                res = remove_chain(dj.fs, cl);
9D0034AC  8FC20020   LW V0, 32(S8)
9D0034B0  00402021   ADDU A0, V0, ZERO
9D0034B4  8FC5001C   LW A1, 28(S8)
9D0034B8  0F400368   JAL 0x9D000DA0
9D0034BC  00000000   NOP
9D0034C0  AFC20010   SW V0, 16(S8)
2339:                                if (res == FR_OK) {
9D0034C4  8FC20010   LW V0, 16(S8)
9D0034C8  14400027   BNE V0, ZERO, 0x9D003568
9D0034CC  00000000   NOP
2340:                                    dj.fs->last_clust = cl - 1; /* Reuse the cluster hole */
9D0034D0  8FC20020   LW V0, 32(S8)
9D0034D4  8FC3001C   LW V1, 28(S8)
9D0034D8  2463FFFF   ADDIU V1, V1, -1
9D0034DC  AC43000C   SW V1, 12(V0)
2341:                                    res = move_window(dj.fs, dw);
9D0034E0  8FC20020   LW V0, 32(S8)
9D0034E4  00402021   ADDU A0, V0, ZERO
9D0034E8  8FC50018   LW A1, 24(S8)
9D0034EC  0F400090   JAL 0x9D000240
9D0034F0  00000000   NOP
9D0034F4  AFC20010   SW V0, 16(S8)
9D0034F8  0B400D5A   J 0x9D003568
9D0034FC  00000000   NOP
2342:                                }
2343:                            }
2344:                        }
2345:                    } else { /* Open an existing file */
2346:                        if (res == FR_OK) { /* Follow succeeded */
9D003500  8FC20010   LW V0, 16(S8)
9D003504  14400018   BNE V0, ZERO, 0x9D003568
9D003508  00000000   NOP
2347:                            if (dir[DIR_Attr] & AM_DIR) { /* It is a directory */
9D00350C  8FC20014   LW V0, 20(S8)
9D003510  2442000B   ADDIU V0, V0, 11
9D003514  90420000   LBU V0, 0(V0)
9D003518  30420010   ANDI V0, V0, 16
9D00351C  10400005   BEQ V0, ZERO, 0x9D003534
9D003520  00000000   NOP
2348:                                res = FR_NO_FILE;
9D003524  24020004   ADDIU V0, ZERO, 4
9D003528  AFC20010   SW V0, 16(S8)
9D00352C  0B400D5A   J 0x9D003568
9D003530  00000000   NOP
2349:                            } else {
2350:                                if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
9D003534  93C20058   LBU V0, 88(S8)
9D003538  30420002   ANDI V0, V0, 2
9D00353C  1040000A   BEQ V0, ZERO, 0x9D003568
9D003540  00000000   NOP
9D003544  8FC20014   LW V0, 20(S8)
9D003548  2442000B   ADDIU V0, V0, 11
9D00354C  90420000   LBU V0, 0(V0)
9D003550  30420001   ANDI V0, V0, 1
9D003554  304200FF   ANDI V0, V0, 255
9D003558  10400003   BEQ V0, ZERO, 0x9D003568
9D00355C  00000000   NOP
2351:                                    res = FR_DENIED;
9D003560  24020007   ADDIU V0, ZERO, 7
9D003564  AFC20010   SW V0, 16(S8)
2352:                            }
2353:                        }
2354:                    }
2355:                    if (res == FR_OK) {
9D003568  8FC20010   LW V0, 16(S8)
9D00356C  1440000F   BNE V0, ZERO, 0x9D0035AC
9D003570  00000000   NOP
2356:                        if (mode & FA_CREATE_ALWAYS) /* Set file change flag if created or overwritten */
9D003574  93C20058   LBU V0, 88(S8)
9D003578  30420008   ANDI V0, V0, 8
9D00357C  10400004   BEQ V0, ZERO, 0x9D003590
9D003580  00000000   NOP
2357:                            mode |= FA__WRITTEN;
9D003584  93C20058   LBU V0, 88(S8)
9D003588  34420020   ORI V0, V0, 32
9D00358C  A3C20058   SB V0, 88(S8)
2358:                        fp->dir_sect = dj.fs->winsect; /* Pointer to the directory entry */
9D003590  8FC20020   LW V0, 32(S8)
9D003594  8C430030   LW V1, 48(V0)
9D003598  8FC20050   LW V0, 80(S8)
9D00359C  AC43001C   SW V1, 28(V0)
2359:                        fp->dir_ptr = dir;
9D0035A0  8FC20050   LW V0, 80(S8)
9D0035A4  8FC30014   LW V1, 20(S8)
9D0035A8  AC430020   SW V1, 32(V0)
2360:                #if _FS_SHARE
2361:                        fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
2362:                        if (!fp->lockid) res = FR_INT_ERR;
2363:                #endif
2364:                    }
2365:                
2366:                #else				/* R/O configuration */
2367:                    if (res == FR_OK) { /* Follow succeeded */
2368:                        if (!dir) { /* Current dir itself */
2369:                            res = FR_INVALID_NAME;
2370:                        } else {
2371:                            if (dir[DIR_Attr] & AM_DIR) /* It is a directory */
2372:                                res = FR_NO_FILE;
2373:                        }
2374:                    }
2375:                #endif
2376:                    FREE_BUF();
2377:                
2378:                    if (res == FR_OK) {
9D0035AC  8FC20010   LW V0, 16(S8)
9D0035B0  1440003F   BNE V0, ZERO, 0x9D0036B0
9D0035B4  00000000   NOP
2379:                        fp->flag = mode; /* File access mode */
9D0035B8  8FC20050   LW V0, 80(S8)
9D0035BC  93C30058   LBU V1, 88(S8)
9D0035C0  A0430006   SB V1, 6(V0)
2380:                        fp->sclust = LD_CLUST(dir); /* File start cluster */
9D0035C4  8FC20014   LW V0, 20(S8)
9D0035C8  24420015   ADDIU V0, V0, 21
9D0035CC  90420000   LBU V0, 0(V0)
9D0035D0  00021200   SLL V0, V0, 8
9D0035D4  7C021E20   SEH V1, V0
9D0035D8  8FC20014   LW V0, 20(S8)
9D0035DC  24420014   ADDIU V0, V0, 20
9D0035E0  90420000   LBU V0, 0(V0)
9D0035E4  7C021620   SEH V0, V0
9D0035E8  00621025   OR V0, V1, V0
9D0035EC  7C021620   SEH V0, V0
9D0035F0  3042FFFF   ANDI V0, V0, -1
9D0035F4  00021C00   SLL V1, V0, 16
9D0035F8  8FC20014   LW V0, 20(S8)
9D0035FC  2442001B   ADDIU V0, V0, 27
9D003600  90420000   LBU V0, 0(V0)
9D003604  00021200   SLL V0, V0, 8
9D003608  7C022620   SEH A0, V0
9D00360C  8FC20014   LW V0, 20(S8)
9D003610  2442001A   ADDIU V0, V0, 26
9D003614  90420000   LBU V0, 0(V0)
9D003618  7C021620   SEH V0, V0
9D00361C  00821025   OR V0, A0, V0
9D003620  7C021620   SEH V0, V0
9D003624  3042FFFF   ANDI V0, V0, -1
9D003628  00621825   OR V1, V1, V0
9D00362C  8FC20050   LW V0, 80(S8)
9D003630  AC430010   SW V1, 16(V0)
2381:                        fp->fsize = LD_DWORD(dir + DIR_FileSize); /* File size */
9D003634  8FC20014   LW V0, 20(S8)
9D003638  2442001F   ADDIU V0, V0, 31
9D00363C  90420000   LBU V0, 0(V0)
9D003640  00021E00   SLL V1, V0, 24
9D003644  8FC20014   LW V0, 20(S8)
9D003648  2442001E   ADDIU V0, V0, 30
9D00364C  90420000   LBU V0, 0(V0)
9D003650  00021400   SLL V0, V0, 16
9D003654  00621825   OR V1, V1, V0
9D003658  8FC20014   LW V0, 20(S8)
9D00365C  2442001D   ADDIU V0, V0, 29
9D003660  90420000   LBU V0, 0(V0)
9D003664  00021200   SLL V0, V0, 8
9D003668  00621825   OR V1, V1, V0
9D00366C  8FC20014   LW V0, 20(S8)
9D003670  2442001C   ADDIU V0, V0, 28
9D003674  90420000   LBU V0, 0(V0)
9D003678  00621825   OR V1, V1, V0
9D00367C  8FC20050   LW V0, 80(S8)
9D003680  AC43000C   SW V1, 12(V0)
2382:                        fp->fptr = 0; /* File pointer */
9D003684  8FC20050   LW V0, 80(S8)
9D003688  AC400008   SW ZERO, 8(V0)
2383:                        fp->dsect = 0;
9D00368C  8FC20050   LW V0, 80(S8)
9D003690  AC400018   SW ZERO, 24(V0)
2384:                #if _USE_FASTSEEK
2385:                        fp->cltbl = 0; /* Normal seek mode */
2386:                #endif
2387:                        fp->fs = dj.fs;
9D003694  8FC30020   LW V1, 32(S8)
9D003698  8FC20050   LW V0, 80(S8)
9D00369C  AC430000   SW V1, 0(V0)
2388:                        fp->id = dj.fs->id; /* Validate file object */
9D0036A0  8FC20020   LW V0, 32(S8)
9D0036A4  94430006   LHU V1, 6(V0)
9D0036A8  8FC20050   LW V0, 80(S8)
9D0036AC  A4430004   SH V1, 4(V0)
2389:                    }
2390:                
2391:                    LEAVE_FF(dj.fs, res);
9D0036B0  8FC20010   LW V0, 16(S8)
2392:                }
9D0036B4  03C0E821   ADDU SP, S8, ZERO
9D0036B8  8FBF004C   LW RA, 76(SP)
9D0036BC  8FBE0048   LW S8, 72(SP)
9D0036C0  27BD0050   ADDIU SP, SP, 80
9D0036C4  03E00008   JR RA
9D0036C8  00000000   NOP
2393:                
2394:                
2395:                
2396:                
2397:                /*-----------------------------------------------------------------------*/
2398:                /* Read File                                                             */
2399:                
2400:                /*-----------------------------------------------------------------------*/
2401:                
2402:                FRESULT f_read(
2403:                        FIL *fp, /* Pointer to the file object */
2404:                        void *buff, /* Pointer to data buffer */
2405:                        UINT btr, /* Number of bytes to read */
2406:                        UINT *br /* Pointer to number of bytes read */
2407:                        ) {
9D0036CC  27BDFFC8   ADDIU SP, SP, -56
9D0036D0  AFBF0034   SW RA, 52(SP)
9D0036D4  AFBE0030   SW S8, 48(SP)
9D0036D8  03A0F021   ADDU S8, SP, ZERO
9D0036DC  AFC40038   SW A0, 56(S8)
9D0036E0  AFC5003C   SW A1, 60(S8)
9D0036E4  AFC60040   SW A2, 64(S8)
9D0036E8  AFC70044   SW A3, 68(S8)
2408:                    FRESULT res;
2409:                    DWORD clst, sect, remain;
2410:                    UINT rcnt, cc;
2411:                    BYTE csect, *rbuff = buff;
9D0036EC  8FC2003C   LW V0, 60(S8)
9D0036F0  AFC2001C   SW V0, 28(S8)
2412:                
2413:                
2414:                    *br = 0; /* Initialize byte counter */
9D0036F4  8FC20044   LW V0, 68(S8)
9D0036F8  AC400000   SW ZERO, 0(V0)
2415:                
2416:                    res = validate(fp->fs, fp->id); /* Check validity */
9D0036FC  8FC20038   LW V0, 56(S8)
9D003700  8C430000   LW V1, 0(V0)
9D003704  8FC20038   LW V0, 56(S8)
9D003708  94420004   LHU V0, 4(V0)
9D00370C  00602021   ADDU A0, V1, ZERO
9D003710  00402821   ADDU A1, V0, ZERO
9D003714  0F400C25   JAL 0x9D003094
9D003718  00000000   NOP
9D00371C  AFC20020   SW V0, 32(S8)
2417:                    if (res != FR_OK) LEAVE_FF(fp->fs, res);
9D003720  8FC20020   LW V0, 32(S8)
9D003724  10400004   BEQ V0, ZERO, 0x9D003738
9D003728  00000000   NOP
9D00372C  8FC20020   LW V0, 32(S8)
9D003730  0B400F0E   J 0x9D003C38
9D003734  00000000   NOP
2418:                    if (fp->flag & FA__ERROR) /* Aborted file? */
9D003738  8FC20038   LW V0, 56(S8)
9D00373C  90420006   LBU V0, 6(V0)
9D003740  7C021420   SEB V0, V0
9D003744  04410004   BGEZ V0, 0x9D003758
9D003748  00000000   NOP
2419:                        LEAVE_FF(fp->fs, FR_INT_ERR);
9D00374C  24020002   ADDIU V0, ZERO, 2
9D003750  0B400F0E   J 0x9D003C38
9D003754  00000000   NOP
2420:                    if (!(fp->flag & FA_READ)) /* Check access mode */
9D003758  8FC20038   LW V0, 56(S8)
9D00375C  90420006   LBU V0, 6(V0)
9D003760  30420001   ANDI V0, V0, 1
9D003764  14400004   BNE V0, ZERO, 0x9D003778
9D003768  00000000   NOP
2421:                        LEAVE_FF(fp->fs, FR_DENIED);
9D00376C  24020007   ADDIU V0, ZERO, 7
9D003770  0B400F0E   J 0x9D003C38
9D003774  00000000   NOP
2422:                    remain = fp->fsize - fp->fptr;
9D003778  8FC20038   LW V0, 56(S8)
9D00377C  8C43000C   LW V1, 12(V0)
9D003780  8FC20038   LW V0, 56(S8)
9D003784  8C420008   LW V0, 8(V0)
9D003788  00621023   SUBU V0, V1, V0
9D00378C  AFC20024   SW V0, 36(S8)
2423:                    if (btr > remain) btr = (UINT) remain; /* Truncate btr by remaining bytes */
9D003790  8FC30040   LW V1, 64(S8)
9D003794  8FC20024   LW V0, 36(S8)
9D003798  0043102B   SLTU V0, V0, V1
9D00379C  10400122   BEQ V0, ZERO, 0x9D003C28
9D0037A0  00000000   NOP
9D0037A4  8FC20024   LW V0, 36(S8)
9D0037A8  AFC20040   SW V0, 64(S8)
2424:                
2425:                    for (; btr; /* Repeat until all data read */
9D0037AC  0B400F0A   J 0x9D003C28
9D0037B0  00000000   NOP
9D003C28  8FC20040   LW V0, 64(S8)
9D003C2C  1440FEE1   BNE V0, ZERO, 0x9D0037B4
9D003C30  00000000   NOP
2426:                            rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
9D003BD8  8FC3001C   LW V1, 28(S8)
9D003BDC  8FC20014   LW V0, 20(S8)
9D003BE0  00621021   ADDU V0, V1, V0
9D003BE4  AFC2001C   SW V0, 28(S8)
9D003BE8  8FC20038   LW V0, 56(S8)
9D003BEC  8C430008   LW V1, 8(V0)
9D003BF0  8FC20014   LW V0, 20(S8)
9D003BF4  00621821   ADDU V1, V1, V0
9D003BF8  8FC20038   LW V0, 56(S8)
9D003BFC  AC430008   SW V1, 8(V0)
9D003C00  8FC20044   LW V0, 68(S8)
9D003C04  8C430000   LW V1, 0(V0)
9D003C08  8FC20014   LW V0, 20(S8)
9D003C0C  00621821   ADDU V1, V1, V0
9D003C10  8FC20044   LW V0, 68(S8)
9D003C14  AC430000   SW V1, 0(V0)
9D003C18  8FC30040   LW V1, 64(S8)
9D003C1C  8FC20014   LW V0, 20(S8)
9D003C20  00621023   SUBU V0, V1, V0
9D003C24  AFC20040   SW V0, 64(S8)
2427:                        if ((fp->fptr % SS(fp->fs)) == 0) { /* On the sector boundary? */
9D0037B4  8FC20038   LW V0, 56(S8)
9D0037B8  8C420008   LW V0, 8(V0)
9D0037BC  304201FF   ANDI V0, V0, 511
9D0037C0  144000ED   BNE V0, ZERO, 0x9D003B78
9D0037C4  00000000   NOP
2428:                            csect = (BYTE) (fp->fptr / SS(fp->fs) & (fp->fs->csize - 1)); /* Sector offset in the cluster */
9D0037C8  8FC20038   LW V0, 56(S8)
9D0037CC  8C420008   LW V0, 8(V0)
9D0037D0  00021242   SRL V0, V0, 9
9D0037D4  304300FF   ANDI V1, V0, 255
9D0037D8  8FC20038   LW V0, 56(S8)
9D0037DC  8C420000   LW V0, 0(V0)
9D0037E0  90420002   LBU V0, 2(V0)
9D0037E4  2442FFFF   ADDIU V0, V0, -1
9D0037E8  304200FF   ANDI V0, V0, 255
9D0037EC  00621024   AND V0, V1, V0
9D0037F0  A3C20028   SB V0, 40(S8)
2429:                            if (!csect) { /* On the cluster boundary? */
9D0037F4  93C20028   LBU V0, 40(S8)
9D0037F8  14400032   BNE V0, ZERO, 0x9D0038C4
9D0037FC  00000000   NOP
2430:                                if (fp->fptr == 0) { /* On the top of the file? */
9D003800  8FC20038   LW V0, 56(S8)
9D003804  8C420008   LW V0, 8(V0)
9D003808  14400006   BNE V0, ZERO, 0x9D003824
9D00380C  00000000   NOP
2431:                                    clst = fp->sclust; /* Follow from the origin */
9D003810  8FC20038   LW V0, 56(S8)
9D003814  8C420010   LW V0, 16(V0)
9D003818  AFC20010   SW V0, 16(S8)
9D00381C  0B400E12   J 0x9D003848
9D003820  00000000   NOP
2432:                                } else { /* Middle or end of the file */
2433:                #if _USE_FASTSEEK
2434:                                    if (fp->cltbl)
2435:                                        clst = clmt_clust(fp, fp->fptr); /* Get cluster# from the CLMT */
2436:                                    else
2437:                #endif
2438:                                        clst = get_fat(fp->fs, fp->clust); /* Follow cluster chain on the FAT */
9D003824  8FC20038   LW V0, 56(S8)
9D003828  8C430000   LW V1, 0(V0)
9D00382C  8FC20038   LW V0, 56(S8)
9D003830  8C420014   LW V0, 20(V0)
9D003834  00602021   ADDU A0, V1, ZERO
9D003838  00402821   ADDU A1, V0, ZERO
9D00383C  0F4001B4   JAL get_fat
9D003840  00000000   NOP
9D003844  AFC20010   SW V0, 16(S8)
2439:                                }
2440:                                if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
9D003848  8FC20010   LW V0, 16(S8)
9D00384C  2C420002   SLTIU V0, V0, 2
9D003850  1040000B   BEQ V0, ZERO, 0x9D003880
9D003854  00000000   NOP
9D003858  8FC20038   LW V0, 56(S8)
9D00385C  90430006   LBU V1, 6(V0)
9D003860  2402FF80   ADDIU V0, ZERO, -128
9D003864  00621025   OR V0, V1, V0
9D003868  304300FF   ANDI V1, V0, 255
9D00386C  8FC20038   LW V0, 56(S8)
9D003870  A0430006   SB V1, 6(V0)
9D003874  24020002   ADDIU V0, ZERO, 2
9D003878  0B400F0E   J 0x9D003C38
9D00387C  00000000   NOP
2441:                                if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
9D003880  8FC30010   LW V1, 16(S8)
9D003884  2402FFFF   ADDIU V0, ZERO, -1
9D003888  1462000B   BNE V1, V0, 0x9D0038B8
9D00388C  00000000   NOP
9D003890  8FC20038   LW V0, 56(S8)
9D003894  90430006   LBU V1, 6(V0)
9D003898  2402FF80   ADDIU V0, ZERO, -128
9D00389C  00621025   OR V0, V1, V0
9D0038A0  304300FF   ANDI V1, V0, 255
9D0038A4  8FC20038   LW V0, 56(S8)
9D0038A8  A0430006   SB V1, 6(V0)
9D0038AC  24020001   ADDIU V0, ZERO, 1
9D0038B0  0B400F0E   J 0x9D003C38
9D0038B4  00000000   NOP
2442:                                fp->clust = clst; /* Update current cluster */
9D0038B8  8FC20038   LW V0, 56(S8)
9D0038BC  8FC30010   LW V1, 16(S8)
9D0038C0  AC430014   SW V1, 20(V0)
2443:                            }
2444:                            sect = clust2sect(fp->fs, fp->clust); /* Get current sector */
9D0038C4  8FC20038   LW V0, 56(S8)
9D0038C8  8C430000   LW V1, 0(V0)
9D0038CC  8FC20038   LW V0, 56(S8)
9D0038D0  8C420014   LW V0, 20(V0)
9D0038D4  00602021   ADDU A0, V1, ZERO
9D0038D8  00402821   ADDU A1, V0, ZERO
9D0038DC  0F400195   JAL clust2sect
9D0038E0  00000000   NOP
9D0038E4  AFC2002C   SW V0, 44(S8)
2445:                            if (!sect) ABORT(fp->fs, FR_INT_ERR);
9D0038E8  8FC2002C   LW V0, 44(S8)
9D0038EC  1440000B   BNE V0, ZERO, 0x9D00391C
9D0038F0  00000000   NOP
9D0038F4  8FC20038   LW V0, 56(S8)
9D0038F8  90430006   LBU V1, 6(V0)
9D0038FC  2402FF80   ADDIU V0, ZERO, -128
9D003900  00621025   OR V0, V1, V0
9D003904  304300FF   ANDI V1, V0, 255
9D003908  8FC20038   LW V0, 56(S8)
9D00390C  A0430006   SB V1, 6(V0)
9D003910  24020002   ADDIU V0, ZERO, 2
9D003914  0B400F0E   J 0x9D003C38
9D003918  00000000   NOP
2446:                            sect += csect;
9D00391C  93C20028   LBU V0, 40(S8)
9D003920  8FC3002C   LW V1, 44(S8)
9D003924  00621021   ADDU V0, V1, V0
9D003928  AFC2002C   SW V0, 44(S8)
2447:                            cc = btr / SS(fp->fs); /* When remaining bytes >= sector size, */
9D00392C  8FC20040   LW V0, 64(S8)
9D003930  00021242   SRL V0, V0, 9
9D003934  AFC20018   SW V0, 24(S8)
2448:                            if (cc) { /* Read maximum contiguous sectors directly */
9D003938  8FC20018   LW V0, 24(S8)
9D00393C  10400049   BEQ V0, ZERO, 0x9D003A64
9D003940  00000000   NOP
2449:                                if (csect + cc > fp->fs->csize) /* Clip at cluster boundary */
9D003944  93C30028   LBU V1, 40(S8)
9D003948  8FC20018   LW V0, 24(S8)
9D00394C  00621821   ADDU V1, V1, V0
9D003950  8FC20038   LW V0, 56(S8)
9D003954  8C420000   LW V0, 0(V0)
9D003958  90420002   LBU V0, 2(V0)
9D00395C  0043102B   SLTU V0, V0, V1
9D003960  10400008   BEQ V0, ZERO, 0x9D003984
9D003964  00000000   NOP
2450:                                    cc = fp->fs->csize - csect;
9D003968  8FC20038   LW V0, 56(S8)
9D00396C  8C420000   LW V0, 0(V0)
9D003970  90420002   LBU V0, 2(V0)
9D003974  00401821   ADDU V1, V0, ZERO
9D003978  93C20028   LBU V0, 40(S8)
9D00397C  00621023   SUBU V0, V1, V0
9D003980  AFC20018   SW V0, 24(S8)
2451:                                if (disk_read(fp->fs->drv, rbuff, sect, (BYTE) cc) != RES_OK)
9D003984  8FC20038   LW V0, 56(S8)
9D003988  8C420000   LW V0, 0(V0)
9D00398C  90420001   LBU V0, 1(V0)
9D003990  00401821   ADDU V1, V0, ZERO
9D003994  8FC20018   LW V0, 24(S8)
9D003998  304200FF   ANDI V0, V0, 255
9D00399C  00602021   ADDU A0, V1, ZERO
9D0039A0  8FC5001C   LW A1, 28(S8)
9D0039A4  8FC6002C   LW A2, 44(S8)
9D0039A8  00403821   ADDU A3, V0, ZERO
9D0039AC  0F402130   JAL disk_read
9D0039B0  00000000   NOP
9D0039B4  1040000B   BEQ V0, ZERO, 0x9D0039E4
9D0039B8  00000000   NOP
2452:                                    ABORT(fp->fs, FR_DISK_ERR);
9D0039BC  8FC20038   LW V0, 56(S8)
9D0039C0  90430006   LBU V1, 6(V0)
9D0039C4  2402FF80   ADDIU V0, ZERO, -128
9D0039C8  00621025   OR V0, V1, V0
9D0039CC  304300FF   ANDI V1, V0, 255
9D0039D0  8FC20038   LW V0, 56(S8)
9D0039D4  A0430006   SB V1, 6(V0)
9D0039D8  24020001   ADDIU V0, ZERO, 1
9D0039DC  0B400F0E   J 0x9D003C38
9D0039E0  00000000   NOP
2453:                #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
2454:                #if _FS_TINY
2455:                                if (fp->fs->wflag && fp->fs->winsect - sect < cc)
2456:                                    mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
2457:                #else
2458:                                if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
9D0039E4  8FC20038   LW V0, 56(S8)
9D0039E8  90420006   LBU V0, 6(V0)
9D0039EC  30420040   ANDI V0, V0, 64
9D0039F0  10400017   BEQ V0, ZERO, 0x9D003A50
9D0039F4  00000000   NOP
9D0039F8  8FC20038   LW V0, 56(S8)
9D0039FC  8C430018   LW V1, 24(V0)
9D003A00  8FC2002C   LW V0, 44(S8)
9D003A04  00621823   SUBU V1, V1, V0
9D003A08  8FC20018   LW V0, 24(S8)
9D003A0C  0062102B   SLTU V0, V1, V0
9D003A10  1040000F   BEQ V0, ZERO, 0x9D003A50
9D003A14  00000000   NOP
2459:                                    mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
9D003A18  8FC20038   LW V0, 56(S8)
9D003A1C  8C430018   LW V1, 24(V0)
9D003A20  8FC2002C   LW V0, 44(S8)
9D003A24  00621023   SUBU V0, V1, V0
9D003A28  00021240   SLL V0, V0, 9
9D003A2C  8FC3001C   LW V1, 28(S8)
9D003A30  00621821   ADDU V1, V1, V0
9D003A34  8FC20038   LW V0, 56(S8)
9D003A38  24420024   ADDIU V0, V0, 36
9D003A3C  00602021   ADDU A0, V1, ZERO
9D003A40  00402821   ADDU A1, V0, ZERO
9D003A44  24060200   ADDIU A2, ZERO, 512
9D003A48  0F400008   JAL 0x9D000020
9D003A4C  00000000   NOP
2460:                #endif
2461:                #endif
2462:                                rcnt = SS(fp->fs) * cc; /* Number of bytes transferred */
9D003A50  8FC20018   LW V0, 24(S8)
9D003A54  00021240   SLL V0, V0, 9
9D003A58  AFC20014   SW V0, 20(S8)
2463:                                continue;
9D003A5C  0B400EF6   J 0x9D003BD8
9D003A60  00000000   NOP
2464:                            }
2465:                #if !_FS_TINY
2466:                            if (fp->dsect != sect) { /* Load data sector if not in cache */
9D003A64  8FC20038   LW V0, 56(S8)
9D003A68  8C430018   LW V1, 24(V0)
9D003A6C  8FC2002C   LW V0, 44(S8)
9D003A70  1062003E   BEQ V1, V0, 0x9D003B6C
9D003A74  00000000   NOP
2467:                #if !_FS_READONLY
2468:                                if (fp->flag & FA__DIRTY) { /* Write-back dirty sector cache */
9D003A78  8FC20038   LW V0, 56(S8)
9D003A7C  90420006   LBU V0, 6(V0)
9D003A80  30420040   ANDI V0, V0, 64
9D003A84  10400021   BEQ V0, ZERO, 0x9D003B0C
9D003A88  00000000   NOP
2469:                                    if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
9D003A8C  8FC20038   LW V0, 56(S8)
9D003A90  8C420000   LW V0, 0(V0)
9D003A94  90420001   LBU V0, 1(V0)
9D003A98  00402021   ADDU A0, V0, ZERO
9D003A9C  8FC20038   LW V0, 56(S8)
9D003AA0  24430024   ADDIU V1, V0, 36
9D003AA4  8FC20038   LW V0, 56(S8)
9D003AA8  8C420018   LW V0, 24(V0)
9D003AAC  00602821   ADDU A1, V1, ZERO
9D003AB0  00403021   ADDU A2, V0, ZERO
9D003AB4  24070001   ADDIU A3, ZERO, 1
9D003AB8  0F40218C   JAL disk_write
9D003ABC  00000000   NOP
9D003AC0  1040000B   BEQ V0, ZERO, 0x9D003AF0
9D003AC4  00000000   NOP
2470:                                        ABORT(fp->fs, FR_DISK_ERR);
9D003AC8  8FC20038   LW V0, 56(S8)
9D003ACC  90430006   LBU V1, 6(V0)
9D003AD0  2402FF80   ADDIU V0, ZERO, -128
9D003AD4  00621025   OR V0, V1, V0
9D003AD8  304300FF   ANDI V1, V0, 255
9D003ADC  8FC20038   LW V0, 56(S8)
9D003AE0  A0430006   SB V1, 6(V0)
9D003AE4  24020001   ADDIU V0, ZERO, 1
9D003AE8  0B400F0E   J 0x9D003C38
9D003AEC  00000000   NOP
2471:                                    fp->flag &= ~FA__DIRTY;
9D003AF0  8FC20038   LW V0, 56(S8)
9D003AF4  90430006   LBU V1, 6(V0)
9D003AF8  2402FFBF   ADDIU V0, ZERO, -65
9D003AFC  00621024   AND V0, V1, V0
9D003B00  304300FF   ANDI V1, V0, 255
9D003B04  8FC20038   LW V0, 56(S8)
9D003B08  A0430006   SB V1, 6(V0)
2472:                                }
2473:                #endif
2474:                                if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK) /* Fill sector cache */
9D003B0C  8FC20038   LW V0, 56(S8)
9D003B10  8C420000   LW V0, 0(V0)
9D003B14  90420001   LBU V0, 1(V0)
9D003B18  00401821   ADDU V1, V0, ZERO
9D003B1C  8FC20038   LW V0, 56(S8)
9D003B20  24420024   ADDIU V0, V0, 36
9D003B24  00602021   ADDU A0, V1, ZERO
9D003B28  00402821   ADDU A1, V0, ZERO
9D003B2C  8FC6002C   LW A2, 44(S8)
9D003B30  24070001   ADDIU A3, ZERO, 1
9D003B34  0F402130   JAL disk_read
9D003B38  00000000   NOP
9D003B3C  1040000B   BEQ V0, ZERO, 0x9D003B6C
9D003B40  00000000   NOP
2475:                                    ABORT(fp->fs, FR_DISK_ERR);
9D003B44  8FC20038   LW V0, 56(S8)
9D003B48  90430006   LBU V1, 6(V0)
9D003B4C  2402FF80   ADDIU V0, ZERO, -128
9D003B50  00621025   OR V0, V1, V0
9D003B54  304300FF   ANDI V1, V0, 255
9D003B58  8FC20038   LW V0, 56(S8)
9D003B5C  A0430006   SB V1, 6(V0)
9D003B60  24020001   ADDIU V0, ZERO, 1
9D003B64  0B400F0E   J 0x9D003C38
9D003B68  00000000   NOP
2476:                            }
2477:                #endif
2478:                            fp->dsect = sect;
9D003B6C  8FC20038   LW V0, 56(S8)
9D003B70  8FC3002C   LW V1, 44(S8)
9D003B74  AC430018   SW V1, 24(V0)
2479:                        }
2480:                        rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs)); /* Get partial sector data from sector buffer */
9D003B78  8FC20038   LW V0, 56(S8)
9D003B7C  8C420008   LW V0, 8(V0)
9D003B80  304201FF   ANDI V0, V0, 511
9D003B84  24030200   ADDIU V1, ZERO, 512
9D003B88  00621023   SUBU V0, V1, V0
9D003B8C  AFC20014   SW V0, 20(S8)
2481:                        if (rcnt > btr) rcnt = btr;
9D003B90  8FC30014   LW V1, 20(S8)
9D003B94  8FC20040   LW V0, 64(S8)
9D003B98  0043102B   SLTU V0, V0, V1
9D003B9C  10400003   BEQ V0, ZERO, 0x9D003BAC
9D003BA0  00000000   NOP
9D003BA4  8FC20040   LW V0, 64(S8)
9D003BA8  AFC20014   SW V0, 20(S8)
2482:                #if _FS_TINY
2483:                        if (move_window(fp->fs, fp->dsect)) /* Move sector window */
2484:                            ABORT(fp->fs, FR_DISK_ERR);
2485:                        mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt); /* Pick partial sector */
2486:                #else
2487:                        mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt); /* Pick partial sector */
9D003BAC  8FC20038   LW V0, 56(S8)
9D003BB0  24430024   ADDIU V1, V0, 36
9D003BB4  8FC20038   LW V0, 56(S8)
9D003BB8  8C420008   LW V0, 8(V0)
9D003BBC  304201FF   ANDI V0, V0, 511
9D003BC0  00621021   ADDU V0, V1, V0
9D003BC4  8FC4001C   LW A0, 28(S8)
9D003BC8  00402821   ADDU A1, V0, ZERO
9D003BCC  8FC60014   LW A2, 20(S8)
9D003BD0  0F400008   JAL 0x9D000020
9D003BD4  00000000   NOP
2488:                #endif
2489:                    }
2490:                
2491:                    LEAVE_FF(fp->fs, FR_OK);
9D003C34  00001021   ADDU V0, ZERO, ZERO
2492:                }
9D003C38  03C0E821   ADDU SP, S8, ZERO
9D003C3C  8FBF0034   LW RA, 52(SP)
9D003C40  8FBE0030   LW S8, 48(SP)
9D003C44  27BD0038   ADDIU SP, SP, 56
9D003C48  03E00008   JR RA
9D003C4C  00000000   NOP
2493:                
2494:                
2495:                
2496:                
2497:                #if !_FS_READONLY
2498:                /*-----------------------------------------------------------------------*/
2499:                /* Write File                                                            */
2500:                
2501:                /*-----------------------------------------------------------------------*/
2502:                
2503:                FRESULT f_write(
2504:                        FIL *fp, /* Pointer to the file object */
2505:                        const void *buff, /* Pointer to the data to be written */
2506:                        UINT btw, /* Number of bytes to write */
2507:                        UINT *bw /* Pointer to number of bytes written */
2508:                        ) {
9D003C50  27BDFFC8   ADDIU SP, SP, -56
9D003C54  AFBF0034   SW RA, 52(SP)
9D003C58  AFBE0030   SW S8, 48(SP)
9D003C5C  03A0F021   ADDU S8, SP, ZERO
9D003C60  AFC40038   SW A0, 56(S8)
9D003C64  AFC5003C   SW A1, 60(S8)
9D003C68  AFC60040   SW A2, 64(S8)
9D003C6C  AFC70044   SW A3, 68(S8)
2509:                    FRESULT res;
2510:                    DWORD clst, sect;
2511:                    UINT wcnt, cc;
2512:                    const BYTE *wbuff = buff;
9D003C70  8FC2003C   LW V0, 60(S8)
9D003C74  AFC2001C   SW V0, 28(S8)
2513:                    BYTE csect;
2514:                
2515:                
2516:                    *bw = 0; /* Initialize byte counter */
9D003C78  8FC20044   LW V0, 68(S8)
9D003C7C  AC400000   SW ZERO, 0(V0)
2517:                
2518:                    res = validate(fp->fs, fp->id); /* Check validity */
9D003C80  8FC20038   LW V0, 56(S8)
9D003C84  8C430000   LW V1, 0(V0)
9D003C88  8FC20038   LW V0, 56(S8)
9D003C8C  94420004   LHU V0, 4(V0)
9D003C90  00602021   ADDU A0, V1, ZERO
9D003C94  00402821   ADDU A1, V0, ZERO
9D003C98  0F400C25   JAL 0x9D003094
9D003C9C  00000000   NOP
9D003CA0  AFC20020   SW V0, 32(S8)
2519:                    if (res != FR_OK) LEAVE_FF(fp->fs, res);
9D003CA4  8FC20020   LW V0, 32(S8)
9D003CA8  10400004   BEQ V0, ZERO, 0x9D003CBC
9D003CAC  00000000   NOP
9D003CB0  8FC20020   LW V0, 32(S8)
9D003CB4  0B40109F   J 0x9D00427C
9D003CB8  00000000   NOP
2520:                    if (fp->flag & FA__ERROR) /* Aborted file? */
9D003CBC  8FC20038   LW V0, 56(S8)
9D003CC0  90420006   LBU V0, 6(V0)
9D003CC4  7C021420   SEB V0, V0
9D003CC8  04410004   BGEZ V0, 0x9D003CDC
9D003CCC  00000000   NOP
2521:                        LEAVE_FF(fp->fs, FR_INT_ERR);
9D003CD0  24020002   ADDIU V0, ZERO, 2
9D003CD4  0B40109F   J 0x9D00427C
9D003CD8  00000000   NOP
2522:                    if (!(fp->flag & FA_WRITE)) /* Check access mode */
9D003CDC  8FC20038   LW V0, 56(S8)
9D003CE0  90420006   LBU V0, 6(V0)
9D003CE4  30420002   ANDI V0, V0, 2
9D003CE8  14400004   BNE V0, ZERO, 0x9D003CFC
9D003CEC  00000000   NOP
2523:                        LEAVE_FF(fp->fs, FR_DENIED);
9D003CF0  24020007   ADDIU V0, ZERO, 7
9D003CF4  0B40109F   J 0x9D00427C
9D003CF8  00000000   NOP
2524:                    if ((DWORD) (fp->fsize + btw) < fp->fsize) btw = 0; /* File size cannot reach 4GB */
9D003CFC  8FC20038   LW V0, 56(S8)
9D003D00  8C43000C   LW V1, 12(V0)
9D003D04  8FC20040   LW V0, 64(S8)
9D003D08  00621821   ADDU V1, V1, V0
9D003D0C  8FC20038   LW V0, 56(S8)
9D003D10  8C42000C   LW V0, 12(V0)
9D003D14  0062102B   SLTU V0, V1, V0
9D003D18  10400140   BEQ V0, ZERO, 0x9D00421C
9D003D1C  00000000   NOP
9D003D20  AFC00040   SW ZERO, 64(S8)
2525:                
2526:                    for (; btw; /* Repeat until all data written */
9D003D24  0B401087   J 0x9D00421C
9D003D28  00000000   NOP
9D00421C  8FC20040   LW V0, 64(S8)
9D004220  1440FEC2   BNE V0, ZERO, 0x9D003D2C
9D004224  00000000   NOP
9D004228  0B40108D   J 0x9D004234
9D00422C  00000000   NOP
2527:                            wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
9D0041CC  8FC3001C   LW V1, 28(S8)
9D0041D0  8FC20014   LW V0, 20(S8)
9D0041D4  00621021   ADDU V0, V1, V0
9D0041D8  AFC2001C   SW V0, 28(S8)
9D0041DC  8FC20038   LW V0, 56(S8)
9D0041E0  8C430008   LW V1, 8(V0)
9D0041E4  8FC20014   LW V0, 20(S8)
9D0041E8  00621821   ADDU V1, V1, V0
9D0041EC  8FC20038   LW V0, 56(S8)
9D0041F0  AC430008   SW V1, 8(V0)
9D0041F4  8FC20044   LW V0, 68(S8)
9D0041F8  8C430000   LW V1, 0(V0)
9D0041FC  8FC20014   LW V0, 20(S8)
9D004200  00621821   ADDU V1, V1, V0
9D004204  8FC20044   LW V0, 68(S8)
9D004208  AC430000   SW V1, 0(V0)
9D00420C  8FC30040   LW V1, 64(S8)
9D004210  8FC20014   LW V0, 20(S8)
9D004214  00621023   SUBU V0, V1, V0
9D004218  AFC20040   SW V0, 64(S8)
2528:                        if ((fp->fptr % SS(fp->fs)) == 0) { /* On the sector boundary? */
9D003D2C  8FC20038   LW V0, 56(S8)
9D003D30  8C420008   LW V0, 8(V0)
9D003D34  304201FF   ANDI V0, V0, 511
9D003D38  14400106   BNE V0, ZERO, 0x9D004154
9D003D3C  00000000   NOP
2529:                            csect = (BYTE) (fp->fptr / SS(fp->fs) & (fp->fs->csize - 1)); /* Sector offset in the cluster */
9D003D40  8FC20038   LW V0, 56(S8)
9D003D44  8C420008   LW V0, 8(V0)
9D003D48  00021242   SRL V0, V0, 9
9D003D4C  304300FF   ANDI V1, V0, 255
9D003D50  8FC20038   LW V0, 56(S8)
9D003D54  8C420000   LW V0, 0(V0)
9D003D58  90420002   LBU V0, 2(V0)
9D003D5C  2442FFFF   ADDIU V0, V0, -1
9D003D60  304200FF   ANDI V0, V0, 255
9D003D64  00621024   AND V0, V1, V0
9D003D68  A3C20024   SB V0, 36(S8)
2530:                            if (!csect) { /* On the cluster boundary? */
9D003D6C  93C20024   LBU V0, 36(S8)
9D003D70  14400042   BNE V0, ZERO, 0x9D003E7C
9D003D74  00000000   NOP
2531:                                if (fp->fptr == 0) { /* On the top of the file? */
9D003D78  8FC20038   LW V0, 56(S8)
9D003D7C  8C420008   LW V0, 8(V0)
9D003D80  14400013   BNE V0, ZERO, 0x9D003DD0
9D003D84  00000000   NOP
2532:                                    clst = fp->sclust; /* Follow from the origin */
9D003D88  8FC20038   LW V0, 56(S8)
9D003D8C  8C420010   LW V0, 16(V0)
9D003D90  AFC20010   SW V0, 16(S8)
2533:                                    if (clst == 0) /* When no cluster is allocated, */
9D003D94  8FC20010   LW V0, 16(S8)
9D003D98  14400016   BNE V0, ZERO, 0x9D003DF4
9D003D9C  00000000   NOP
2534:                                        fp->sclust = clst = create_chain(fp->fs, 0); /* Create a new cluster chain */
9D003DA0  8FC20038   LW V0, 56(S8)
9D003DA4  8C420000   LW V0, 0(V0)
9D003DA8  00402021   ADDU A0, V0, ZERO
9D003DAC  00002821   ADDU A1, ZERO, ZERO
9D003DB0  0F4003C2   JAL 0x9D000F08
9D003DB4  00000000   NOP
9D003DB8  AFC20010   SW V0, 16(S8)
9D003DBC  8FC20038   LW V0, 56(S8)
9D003DC0  8FC30010   LW V1, 16(S8)
9D003DC4  AC430010   SW V1, 16(V0)
9D003DC8  0B400F7D   J 0x9D003DF4
9D003DCC  00000000   NOP
2535:                                } else { /* Middle or end of the file */
2536:                #if _USE_FASTSEEK
2537:                                    if (fp->cltbl)
2538:                                        clst = clmt_clust(fp, fp->fptr); /* Get cluster# from the CLMT */
2539:                                    else
2540:                #endif
2541:                                        clst = create_chain(fp->fs, fp->clust); /* Follow or stretch cluster chain on the FAT */
9D003DD0  8FC20038   LW V0, 56(S8)
9D003DD4  8C430000   LW V1, 0(V0)
9D003DD8  8FC20038   LW V0, 56(S8)
9D003DDC  8C420014   LW V0, 20(V0)
9D003DE0  00602021   ADDU A0, V1, ZERO
9D003DE4  00402821   ADDU A1, V0, ZERO
9D003DE8  0F4003C2   JAL 0x9D000F08
9D003DEC  00000000   NOP
9D003DF0  AFC20010   SW V0, 16(S8)
2542:                                }
2543:                                if (clst == 0) break; /* Could not allocate a new cluster (disk full) */
9D003DF4  8FC20010   LW V0, 16(S8)
9D003DF8  1040010D   BEQ V0, ZERO, 0x9D004230
9D003DFC  00000000   NOP
9D004230  00000000   NOP
2544:                                if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
9D003E00  8FC30010   LW V1, 16(S8)
9D003E04  24020001   ADDIU V0, ZERO, 1
9D003E08  1462000B   BNE V1, V0, 0x9D003E38
9D003E0C  00000000   NOP
9D003E10  8FC20038   LW V0, 56(S8)
9D003E14  90430006   LBU V1, 6(V0)
9D003E18  2402FF80   ADDIU V0, ZERO, -128
9D003E1C  00621025   OR V0, V1, V0
9D003E20  304300FF   ANDI V1, V0, 255
9D003E24  8FC20038   LW V0, 56(S8)
9D003E28  A0430006   SB V1, 6(V0)
9D003E2C  24020002   ADDIU V0, ZERO, 2
9D003E30  0B40109F   J 0x9D00427C
9D003E34  00000000   NOP
2545:                                if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
9D003E38  8FC30010   LW V1, 16(S8)
9D003E3C  2402FFFF   ADDIU V0, ZERO, -1
9D003E40  1462000B   BNE V1, V0, 0x9D003E70
9D003E44  00000000   NOP
9D003E48  8FC20038   LW V0, 56(S8)
9D003E4C  90430006   LBU V1, 6(V0)
9D003E50  2402FF80   ADDIU V0, ZERO, -128
9D003E54  00621025   OR V0, V1, V0
9D003E58  304300FF   ANDI V1, V0, 255
9D003E5C  8FC20038   LW V0, 56(S8)
9D003E60  A0430006   SB V1, 6(V0)
9D003E64  24020001   ADDIU V0, ZERO, 1
9D003E68  0B40109F   J 0x9D00427C
9D003E6C  00000000   NOP
2546:                                fp->clust = clst; /* Update current cluster */
9D003E70  8FC20038   LW V0, 56(S8)
9D003E74  8FC30010   LW V1, 16(S8)
9D003E78  AC430014   SW V1, 20(V0)
2547:                            }
2548:                #if _FS_TINY
2549:                            if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0)) /* Write-back sector cache */
2550:                                ABORT(fp->fs, FR_DISK_ERR);
2551:                #else
2552:                            if (fp->flag & FA__DIRTY) { /* Write-back sector cache */
9D003E7C  8FC20038   LW V0, 56(S8)
9D003E80  90420006   LBU V0, 6(V0)
9D003E84  30420040   ANDI V0, V0, 64
9D003E88  10400021   BEQ V0, ZERO, 0x9D003F10
9D003E8C  00000000   NOP
2553:                                if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
9D003E90  8FC20038   LW V0, 56(S8)
9D003E94  8C420000   LW V0, 0(V0)
9D003E98  90420001   LBU V0, 1(V0)
9D003E9C  00402021   ADDU A0, V0, ZERO
9D003EA0  8FC20038   LW V0, 56(S8)
9D003EA4  24430024   ADDIU V1, V0, 36
9D003EA8  8FC20038   LW V0, 56(S8)
9D003EAC  8C420018   LW V0, 24(V0)
9D003EB0  00602821   ADDU A1, V1, ZERO
9D003EB4  00403021   ADDU A2, V0, ZERO
9D003EB8  24070001   ADDIU A3, ZERO, 1
9D003EBC  0F40218C   JAL disk_write
9D003EC0  00000000   NOP
9D003EC4  1040000B   BEQ V0, ZERO, 0x9D003EF4
9D003EC8  00000000   NOP
2554:                                    ABORT(fp->fs, FR_DISK_ERR);
9D003ECC  8FC20038   LW V0, 56(S8)
9D003ED0  90430006   LBU V1, 6(V0)
9D003ED4  2402FF80   ADDIU V0, ZERO, -128
9D003ED8  00621025   OR V0, V1, V0
9D003EDC  304300FF   ANDI V1, V0, 255
9D003EE0  8FC20038   LW V0, 56(S8)
9D003EE4  A0430006   SB V1, 6(V0)
9D003EE8  24020001   ADDIU V0, ZERO, 1
9D003EEC  0B40109F   J 0x9D00427C
9D003EF0  00000000   NOP
2555:                                fp->flag &= ~FA__DIRTY;
9D003EF4  8FC20038   LW V0, 56(S8)
9D003EF8  90430006   LBU V1, 6(V0)
9D003EFC  2402FFBF   ADDIU V0, ZERO, -65
9D003F00  00621024   AND V0, V1, V0
9D003F04  304300FF   ANDI V1, V0, 255
9D003F08  8FC20038   LW V0, 56(S8)
9D003F0C  A0430006   SB V1, 6(V0)
2556:                            }
2557:                #endif
2558:                            sect = clust2sect(fp->fs, fp->clust); /* Get current sector */
9D003F10  8FC20038   LW V0, 56(S8)
9D003F14  8C430000   LW V1, 0(V0)
9D003F18  8FC20038   LW V0, 56(S8)
9D003F1C  8C420014   LW V0, 20(V0)
9D003F20  00602021   ADDU A0, V1, ZERO
9D003F24  00402821   ADDU A1, V0, ZERO
9D003F28  0F400195   JAL clust2sect
9D003F2C  00000000   NOP
9D003F30  AFC20028   SW V0, 40(S8)
2559:                            if (!sect) ABORT(fp->fs, FR_INT_ERR);
9D003F34  8FC20028   LW V0, 40(S8)
9D003F38  1440000B   BNE V0, ZERO, 0x9D003F68
9D003F3C  00000000   NOP
9D003F40  8FC20038   LW V0, 56(S8)
9D003F44  90430006   LBU V1, 6(V0)
9D003F48  2402FF80   ADDIU V0, ZERO, -128
9D003F4C  00621025   OR V0, V1, V0
9D003F50  304300FF   ANDI V1, V0, 255
9D003F54  8FC20038   LW V0, 56(S8)
9D003F58  A0430006   SB V1, 6(V0)
9D003F5C  24020002   ADDIU V0, ZERO, 2
9D003F60  0B40109F   J 0x9D00427C
9D003F64  00000000   NOP
2560:                            sect += csect;
9D003F68  93C20024   LBU V0, 36(S8)
9D003F6C  8FC30028   LW V1, 40(S8)
9D003F70  00621021   ADDU V0, V1, V0
9D003F74  AFC20028   SW V0, 40(S8)
2561:                            cc = btw / SS(fp->fs); /* When remaining bytes >= sector size, */
9D003F78  8FC20040   LW V0, 64(S8)
9D003F7C  00021242   SRL V0, V0, 9
9D003F80  AFC20018   SW V0, 24(S8)
2562:                            if (cc) { /* Write maximum contiguous sectors directly */
9D003F84  8FC20018   LW V0, 24(S8)
9D003F88  1040004B   BEQ V0, ZERO, 0x9D0040B8
9D003F8C  00000000   NOP
2563:                                if (csect + cc > fp->fs->csize) /* Clip at cluster boundary */
9D003F90  93C30024   LBU V1, 36(S8)
9D003F94  8FC20018   LW V0, 24(S8)
9D003F98  00621821   ADDU V1, V1, V0
9D003F9C  8FC20038   LW V0, 56(S8)
9D003FA0  8C420000   LW V0, 0(V0)
9D003FA4  90420002   LBU V0, 2(V0)
9D003FA8  0043102B   SLTU V0, V0, V1
9D003FAC  10400008   BEQ V0, ZERO, 0x9D003FD0
9D003FB0  00000000   NOP
2564:                                    cc = fp->fs->csize - csect;
9D003FB4  8FC20038   LW V0, 56(S8)
9D003FB8  8C420000   LW V0, 0(V0)
9D003FBC  90420002   LBU V0, 2(V0)
9D003FC0  00401821   ADDU V1, V0, ZERO
9D003FC4  93C20024   LBU V0, 36(S8)
9D003FC8  00621023   SUBU V0, V1, V0
9D003FCC  AFC20018   SW V0, 24(S8)
2565:                                if (disk_write(fp->fs->drv, wbuff, sect, (BYTE) cc) != RES_OK)
9D003FD0  8FC20038   LW V0, 56(S8)
9D003FD4  8C420000   LW V0, 0(V0)
9D003FD8  90420001   LBU V0, 1(V0)
9D003FDC  00401821   ADDU V1, V0, ZERO
9D003FE0  8FC20018   LW V0, 24(S8)
9D003FE4  304200FF   ANDI V0, V0, 255
9D003FE8  00602021   ADDU A0, V1, ZERO
9D003FEC  8FC5001C   LW A1, 28(S8)
9D003FF0  8FC60028   LW A2, 40(S8)
9D003FF4  00403821   ADDU A3, V0, ZERO
9D003FF8  0F40218C   JAL disk_write
9D003FFC  00000000   NOP
9D004000  1040000B   BEQ V0, ZERO, 0x9D004030
9D004004  00000000   NOP
2566:                                    ABORT(fp->fs, FR_DISK_ERR);
9D004008  8FC20038   LW V0, 56(S8)
9D00400C  90430006   LBU V1, 6(V0)
9D004010  2402FF80   ADDIU V0, ZERO, -128
9D004014  00621025   OR V0, V1, V0
9D004018  304300FF   ANDI V1, V0, 255
9D00401C  8FC20038   LW V0, 56(S8)
9D004020  A0430006   SB V1, 6(V0)
9D004024  24020001   ADDIU V0, ZERO, 1
9D004028  0B40109F   J 0x9D00427C
9D00402C  00000000   NOP
2567:                #if _FS_TINY
2568:                                if (fp->fs->winsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
2569:                                    mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
2570:                                    fp->fs->wflag = 0;
2571:                                }
2572:                #else
2573:                                if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
9D004030  8FC20038   LW V0, 56(S8)
9D004034  8C430018   LW V1, 24(V0)
9D004038  8FC20028   LW V0, 40(S8)
9D00403C  00621823   SUBU V1, V1, V0
9D004040  8FC20018   LW V0, 24(S8)
9D004044  0062102B   SLTU V0, V1, V0
9D004048  10400016   BEQ V0, ZERO, 0x9D0040A4
9D00404C  00000000   NOP
2574:                                    mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
9D004050  8FC20038   LW V0, 56(S8)
9D004054  24430024   ADDIU V1, V0, 36
9D004058  8FC20038   LW V0, 56(S8)
9D00405C  8C440018   LW A0, 24(V0)
9D004060  8FC20028   LW V0, 40(S8)
9D004064  00821023   SUBU V0, A0, V0
9D004068  00021240   SLL V0, V0, 9
9D00406C  8FC4001C   LW A0, 28(S8)
9D004070  00821021   ADDU V0, A0, V0
9D004074  00602021   ADDU A0, V1, ZERO
9D004078  00402821   ADDU A1, V0, ZERO
9D00407C  24060200   ADDIU A2, ZERO, 512
9D004080  0F400008   JAL 0x9D000020
9D004084  00000000   NOP
2575:                                    fp->flag &= ~FA__DIRTY;
9D004088  8FC20038   LW V0, 56(S8)
9D00408C  90430006   LBU V1, 6(V0)
9D004090  2402FFBF   ADDIU V0, ZERO, -65
9D004094  00621024   AND V0, V1, V0
9D004098  304300FF   ANDI V1, V0, 255
9D00409C  8FC20038   LW V0, 56(S8)
9D0040A0  A0430006   SB V1, 6(V0)
2576:                                }
2577:                #endif
2578:                                wcnt = SS(fp->fs) * cc; /* Number of bytes transferred */
9D0040A4  8FC20018   LW V0, 24(S8)
9D0040A8  00021240   SLL V0, V0, 9
9D0040AC  AFC20014   SW V0, 20(S8)
2579:                                continue;
9D0040B0  0B401073   J 0x9D0041CC
9D0040B4  00000000   NOP
2580:                            }
2581:                #if _FS_TINY
2582:                            if (fp->fptr >= fp->fsize) { /* Avoid silly cache filling at growing edge */
2583:                                if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
2584:                                fp->fs->winsect = sect;
2585:                            }
2586:                #else
2587:                            if (fp->dsect != sect) { /* Fill sector cache with file data */
9D0040B8  8FC20038   LW V0, 56(S8)
9D0040BC  8C430018   LW V1, 24(V0)
9D0040C0  8FC20028   LW V0, 40(S8)
9D0040C4  10620020   BEQ V1, V0, 0x9D004148
9D0040C8  00000000   NOP
2588:                                if (fp->fptr < fp->fsize &&
9D0040CC  8FC20038   LW V0, 56(S8)
9D0040D0  8C430008   LW V1, 8(V0)
9D0040D4  8FC20038   LW V0, 56(S8)
9D0040D8  8C42000C   LW V0, 12(V0)
9D0040DC  0062102B   SLTU V0, V1, V0
9D0040E0  10400019   BEQ V0, ZERO, 0x9D004148
9D0040E4  00000000   NOP
9D004118  1040000B   BEQ V0, ZERO, 0x9D004148
9D00411C  00000000   NOP
2589:                                        disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
9D0040E8  8FC20038   LW V0, 56(S8)
9D0040EC  8C420000   LW V0, 0(V0)
9D0040F0  90420001   LBU V0, 1(V0)
9D0040F4  00401821   ADDU V1, V0, ZERO
9D0040F8  8FC20038   LW V0, 56(S8)
9D0040FC  24420024   ADDIU V0, V0, 36
9D004100  00602021   ADDU A0, V1, ZERO
9D004104  00402821   ADDU A1, V0, ZERO
9D004108  8FC60028   LW A2, 40(S8)
9D00410C  24070001   ADDIU A3, ZERO, 1
9D004110  0F402130   JAL disk_read
9D004114  00000000   NOP
2590:                                    ABORT(fp->fs, FR_DISK_ERR);
9D004120  8FC20038   LW V0, 56(S8)
9D004124  90430006   LBU V1, 6(V0)
9D004128  2402FF80   ADDIU V0, ZERO, -128
9D00412C  00621025   OR V0, V1, V0
9D004130  304300FF   ANDI V1, V0, 255
9D004134  8FC20038   LW V0, 56(S8)
9D004138  A0430006   SB V1, 6(V0)
9D00413C  24020001   ADDIU V0, ZERO, 1
9D004140  0B40109F   J 0x9D00427C
9D004144  00000000   NOP
2591:                            }
2592:                #endif
2593:                            fp->dsect = sect;
9D004148  8FC20038   LW V0, 56(S8)
9D00414C  8FC30028   LW V1, 40(S8)
9D004150  AC430018   SW V1, 24(V0)
2594:                        }
2595:                        wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs)); /* Put partial sector into file I/O buffer */
9D004154  8FC20038   LW V0, 56(S8)
9D004158  8C420008   LW V0, 8(V0)
9D00415C  304201FF   ANDI V0, V0, 511
9D004160  24030200   ADDIU V1, ZERO, 512
9D004164  00621023   SUBU V0, V1, V0
9D004168  AFC20014   SW V0, 20(S8)
2596:                        if (wcnt > btw) wcnt = btw;
9D00416C  8FC30014   LW V1, 20(S8)
9D004170  8FC20040   LW V0, 64(S8)
9D004174  0043102B   SLTU V0, V0, V1
9D004178  10400003   BEQ V0, ZERO, 0x9D004188
9D00417C  00000000   NOP
9D004180  8FC20040   LW V0, 64(S8)
9D004184  AFC20014   SW V0, 20(S8)
2597:                #if _FS_TINY
2598:                        if (move_window(fp->fs, fp->dsect)) /* Move sector window */
2599:                            ABORT(fp->fs, FR_DISK_ERR);
2600:                        mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt); /* Fit partial sector */
2601:                        fp->fs->wflag = 1;
2602:                #else
2603:                        mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt); /* Fit partial sector */
9D004188  8FC20038   LW V0, 56(S8)
9D00418C  24430024   ADDIU V1, V0, 36
9D004190  8FC20038   LW V0, 56(S8)
9D004194  8C420008   LW V0, 8(V0)
9D004198  304201FF   ANDI V0, V0, 511
9D00419C  00621021   ADDU V0, V1, V0
9D0041A0  00402021   ADDU A0, V0, ZERO
9D0041A4  8FC5001C   LW A1, 28(S8)
9D0041A8  8FC60014   LW A2, 20(S8)
9D0041AC  0F400008   JAL 0x9D000020
9D0041B0  00000000   NOP
2604:                        fp->flag |= FA__DIRTY;
9D0041B4  8FC20038   LW V0, 56(S8)
9D0041B8  90420006   LBU V0, 6(V0)
9D0041BC  34420040   ORI V0, V0, 64
9D0041C0  304300FF   ANDI V1, V0, 255
9D0041C4  8FC20038   LW V0, 56(S8)
9D0041C8  A0430006   SB V1, 6(V0)
2605:                #endif
2606:                    }
2607:                
2608:                    if (fp->fptr > fp->fsize) fp->fsize = fp->fptr; /* Update file size if needed */
9D004234  8FC20038   LW V0, 56(S8)
9D004238  8C430008   LW V1, 8(V0)
9D00423C  8FC20038   LW V0, 56(S8)
9D004240  8C42000C   LW V0, 12(V0)
9D004244  0043102B   SLTU V0, V0, V1
9D004248  10400005   BEQ V0, ZERO, 0x9D004260
9D00424C  00000000   NOP
9D004250  8FC20038   LW V0, 56(S8)
9D004254  8C430008   LW V1, 8(V0)
9D004258  8FC20038   LW V0, 56(S8)
9D00425C  AC43000C   SW V1, 12(V0)
2609:                    fp->flag |= FA__WRITTEN; /* Set file change flag */
9D004260  8FC20038   LW V0, 56(S8)
9D004264  90420006   LBU V0, 6(V0)
9D004268  34420020   ORI V0, V0, 32
9D00426C  304300FF   ANDI V1, V0, 255
9D004270  8FC20038   LW V0, 56(S8)
9D004274  A0430006   SB V1, 6(V0)
2610:                
2611:                    LEAVE_FF(fp->fs, FR_OK);
9D004278  00001021   ADDU V0, ZERO, ZERO
2612:                }
9D00427C  03C0E821   ADDU SP, S8, ZERO
9D004280  8FBF0034   LW RA, 52(SP)
9D004284  8FBE0030   LW S8, 48(SP)
9D004288  27BD0038   ADDIU SP, SP, 56
9D00428C  03E00008   JR RA
9D004290  00000000   NOP
2613:                
2614:                
2615:                
2616:                
2617:                /*-----------------------------------------------------------------------*/
2618:                /* Synchronize the File Object                                           */
2619:                
2620:                /*-----------------------------------------------------------------------*/
2621:                
2622:                FRESULT f_sync(
2623:                        FIL *fp /* Pointer to the file object */
2624:                        ) {
9D004294  27BDFFD8   ADDIU SP, SP, -40
9D004298  AFBF0024   SW RA, 36(SP)
9D00429C  AFBE0020   SW S8, 32(SP)
9D0042A0  03A0F021   ADDU S8, SP, ZERO
9D0042A4  AFC40028   SW A0, 40(S8)
2625:                    FRESULT res;
2626:                    DWORD tim;
2627:                    BYTE *dir;
2628:                
2629:                
2630:                    res = validate(fp->fs, fp->id); /* Check validity of the object */
9D0042A8  8FC20028   LW V0, 40(S8)
9D0042AC  8C430000   LW V1, 0(V0)
9D0042B0  8FC20028   LW V0, 40(S8)
9D0042B4  94420004   LHU V0, 4(V0)
9D0042B8  00602021   ADDU A0, V1, ZERO
9D0042BC  00402821   ADDU A1, V0, ZERO
9D0042C0  0F400C25   JAL 0x9D003094
9D0042C4  00000000   NOP
9D0042C8  AFC20010   SW V0, 16(S8)
2631:                    if (res == FR_OK) {
9D0042CC  8FC20010   LW V0, 16(S8)
9D0042D0  144000A5   BNE V0, ZERO, 0x9D004568
9D0042D4  00000000   NOP
2632:                        if (fp->flag & FA__WRITTEN) { /* Has the file been written? */
9D0042D8  8FC20028   LW V0, 40(S8)
9D0042DC  90420006   LBU V0, 6(V0)
9D0042E0  30420020   ANDI V0, V0, 32
9D0042E4  104000A0   BEQ V0, ZERO, 0x9D004568
9D0042E8  00000000   NOP
2633:                #if !_FS_TINY	/* Write-back dirty buffer */
2634:                            if (fp->flag & FA__DIRTY) {
9D0042EC  8FC20028   LW V0, 40(S8)
9D0042F0  90420006   LBU V0, 6(V0)
9D0042F4  30420040   ANDI V0, V0, 64
9D0042F8  1040001A   BEQ V0, ZERO, 0x9D004364
9D0042FC  00000000   NOP
2635:                                if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
9D004300  8FC20028   LW V0, 40(S8)
9D004304  8C420000   LW V0, 0(V0)
9D004308  90420001   LBU V0, 1(V0)
9D00430C  00402021   ADDU A0, V0, ZERO
9D004310  8FC20028   LW V0, 40(S8)
9D004314  24430024   ADDIU V1, V0, 36
9D004318  8FC20028   LW V0, 40(S8)
9D00431C  8C420018   LW V0, 24(V0)
9D004320  00602821   ADDU A1, V1, ZERO
9D004324  00403021   ADDU A2, V0, ZERO
9D004328  24070001   ADDIU A3, ZERO, 1
9D00432C  0F40218C   JAL disk_write
9D004330  00000000   NOP
9D004334  10400004   BEQ V0, ZERO, 0x9D004348
9D004338  00000000   NOP
2636:                                    LEAVE_FF(fp->fs, FR_DISK_ERR);
9D00433C  24020001   ADDIU V0, ZERO, 1
9D004340  0B40115B   J 0x9D00456C
9D004344  00000000   NOP
2637:                                fp->flag &= ~FA__DIRTY;
9D004348  8FC20028   LW V0, 40(S8)
9D00434C  90430006   LBU V1, 6(V0)
9D004350  2402FFBF   ADDIU V0, ZERO, -65
9D004354  00621024   AND V0, V1, V0
9D004358  304300FF   ANDI V1, V0, 255
9D00435C  8FC20028   LW V0, 40(S8)
9D004360  A0430006   SB V1, 6(V0)
2638:                            }
2639:                #endif
2640:                            /* Update the directory entry */
2641:                            res = move_window(fp->fs, fp->dir_sect);
9D004364  8FC20028   LW V0, 40(S8)
9D004368  8C430000   LW V1, 0(V0)
9D00436C  8FC20028   LW V0, 40(S8)
9D004370  8C42001C   LW V0, 28(V0)
9D004374  00602021   ADDU A0, V1, ZERO
9D004378  00402821   ADDU A1, V0, ZERO
9D00437C  0F400090   JAL 0x9D000240
9D004380  00000000   NOP
9D004384  AFC20010   SW V0, 16(S8)
2642:                            if (res == FR_OK) {
9D004388  8FC20010   LW V0, 16(S8)
9D00438C  14400076   BNE V0, ZERO, 0x9D004568
9D004390  00000000   NOP
2643:                                dir = fp->dir_ptr;
9D004394  8FC20028   LW V0, 40(S8)
9D004398  8C420020   LW V0, 32(V0)
9D00439C  AFC20014   SW V0, 20(S8)
2644:                                dir[DIR_Attr] |= AM_ARC; /* Set archive bit */
9D0043A0  8FC20014   LW V0, 20(S8)
9D0043A4  2442000B   ADDIU V0, V0, 11
9D0043A8  8FC30014   LW V1, 20(S8)
9D0043AC  2463000B   ADDIU V1, V1, 11
9D0043B0  90630000   LBU V1, 0(V1)
9D0043B4  34630020   ORI V1, V1, 32
9D0043B8  306300FF   ANDI V1, V1, 255
9D0043BC  A0430000   SB V1, 0(V0)
2645:                                ST_DWORD(dir + DIR_FileSize, fp->fsize); /* Update file size */
9D0043C0  8FC20014   LW V0, 20(S8)
9D0043C4  2442001C   ADDIU V0, V0, 28
9D0043C8  8FC30028   LW V1, 40(S8)
9D0043CC  8C63000C   LW V1, 12(V1)
9D0043D0  306300FF   ANDI V1, V1, 255
9D0043D4  A0430000   SB V1, 0(V0)
9D0043D8  8FC20014   LW V0, 20(S8)
9D0043DC  2442001D   ADDIU V0, V0, 29
9D0043E0  8FC30028   LW V1, 40(S8)
9D0043E4  8C63000C   LW V1, 12(V1)
9D0043E8  3063FFFF   ANDI V1, V1, -1
9D0043EC  00031A02   SRL V1, V1, 8
9D0043F0  3063FFFF   ANDI V1, V1, -1
9D0043F4  306300FF   ANDI V1, V1, 255
9D0043F8  A0430000   SB V1, 0(V0)
9D0043FC  8FC20014   LW V0, 20(S8)
9D004400  2442001E   ADDIU V0, V0, 30
9D004404  8FC30028   LW V1, 40(S8)
9D004408  8C63000C   LW V1, 12(V1)
9D00440C  00031C02   SRL V1, V1, 16
9D004410  306300FF   ANDI V1, V1, 255
9D004414  A0430000   SB V1, 0(V0)
9D004418  8FC20014   LW V0, 20(S8)
9D00441C  2442001F   ADDIU V0, V0, 31
9D004420  8FC30028   LW V1, 40(S8)
9D004424  8C63000C   LW V1, 12(V1)
9D004428  00031E02   SRL V1, V1, 24
9D00442C  306300FF   ANDI V1, V1, 255
9D004430  A0430000   SB V1, 0(V0)
2646:                                ST_CLUST(dir, fp->sclust); /* Update start cluster */
9D004434  8FC20014   LW V0, 20(S8)
9D004438  2442001A   ADDIU V0, V0, 26
9D00443C  8FC30028   LW V1, 40(S8)
9D004440  8C630010   LW V1, 16(V1)
9D004444  306300FF   ANDI V1, V1, 255
9D004448  A0430000   SB V1, 0(V0)
9D00444C  8FC20014   LW V0, 20(S8)
9D004450  2442001B   ADDIU V0, V0, 27
9D004454  8FC30028   LW V1, 40(S8)
9D004458  8C630010   LW V1, 16(V1)
9D00445C  3063FFFF   ANDI V1, V1, -1
9D004460  00031A02   SRL V1, V1, 8
9D004464  3063FFFF   ANDI V1, V1, -1
9D004468  306300FF   ANDI V1, V1, 255
9D00446C  A0430000   SB V1, 0(V0)
9D004470  8FC20014   LW V0, 20(S8)
9D004474  24420014   ADDIU V0, V0, 20
9D004478  8FC30028   LW V1, 40(S8)
9D00447C  8C630010   LW V1, 16(V1)
9D004480  00031C02   SRL V1, V1, 16
9D004484  306300FF   ANDI V1, V1, 255
9D004488  A0430000   SB V1, 0(V0)
9D00448C  8FC20014   LW V0, 20(S8)
9D004490  24420015   ADDIU V0, V0, 21
9D004494  8FC30028   LW V1, 40(S8)
9D004498  8C630010   LW V1, 16(V1)
9D00449C  00031C02   SRL V1, V1, 16
9D0044A0  3063FFFF   ANDI V1, V1, -1
9D0044A4  00031A02   SRL V1, V1, 8
9D0044A8  3063FFFF   ANDI V1, V1, -1
9D0044AC  306300FF   ANDI V1, V1, 255
9D0044B0  A0430000   SB V1, 0(V0)
2647:                                tim = get_fattime(); /* Update updated time */
9D0044B4  0F402C66   JAL get_fattime
9D0044B8  00000000   NOP
9D0044BC  AFC20018   SW V0, 24(S8)
2648:                                ST_DWORD(dir + DIR_WrtTime, tim);
9D0044C0  8FC20014   LW V0, 20(S8)
9D0044C4  24420016   ADDIU V0, V0, 22
9D0044C8  8FC30018   LW V1, 24(S8)
9D0044CC  306300FF   ANDI V1, V1, 255
9D0044D0  A0430000   SB V1, 0(V0)
9D0044D4  8FC20014   LW V0, 20(S8)
9D0044D8  24420017   ADDIU V0, V0, 23
9D0044DC  8FC30018   LW V1, 24(S8)
9D0044E0  3063FFFF   ANDI V1, V1, -1
9D0044E4  00031A02   SRL V1, V1, 8
9D0044E8  3063FFFF   ANDI V1, V1, -1
9D0044EC  306300FF   ANDI V1, V1, 255
9D0044F0  A0430000   SB V1, 0(V0)
9D0044F4  8FC20014   LW V0, 20(S8)
9D0044F8  24420018   ADDIU V0, V0, 24
9D0044FC  8FC30018   LW V1, 24(S8)
9D004500  00031C02   SRL V1, V1, 16
9D004504  306300FF   ANDI V1, V1, 255
9D004508  A0430000   SB V1, 0(V0)
9D00450C  8FC20014   LW V0, 20(S8)
9D004510  24420019   ADDIU V0, V0, 25
9D004514  8FC30018   LW V1, 24(S8)
9D004518  00031E02   SRL V1, V1, 24
9D00451C  306300FF   ANDI V1, V1, 255
9D004520  A0430000   SB V1, 0(V0)
2649:                                fp->flag &= ~FA__WRITTEN;
9D004524  8FC20028   LW V0, 40(S8)
9D004528  90430006   LBU V1, 6(V0)
9D00452C  2402FFDF   ADDIU V0, ZERO, -33
9D004530  00621024   AND V0, V1, V0
9D004534  304300FF   ANDI V1, V0, 255
9D004538  8FC20028   LW V0, 40(S8)
9D00453C  A0430006   SB V1, 6(V0)
2650:                                fp->fs->wflag = 1;
9D004540  8FC20028   LW V0, 40(S8)
9D004544  8C420000   LW V0, 0(V0)
9D004548  24030001   ADDIU V1, ZERO, 1
9D00454C  A0430004   SB V1, 4(V0)
2651:                                res = sync(fp->fs);
9D004550  8FC20028   LW V0, 40(S8)
9D004554  8C420000   LW V0, 0(V0)
9D004558  00402021   ADDU A0, V0, ZERO
9D00455C  0F4000F5   JAL 0x9D0003D4
9D004560  00000000   NOP
9D004564  AFC20010   SW V0, 16(S8)
2652:                            }
2653:                        }
2654:                    }
2655:                
2656:                    LEAVE_FF(fp->fs, res);
9D004568  8FC20010   LW V0, 16(S8)
2657:                }
9D00456C  03C0E821   ADDU SP, S8, ZERO
9D004570  8FBF0024   LW RA, 36(SP)
9D004574  8FBE0020   LW S8, 32(SP)
9D004578  27BD0028   ADDIU SP, SP, 40
9D00457C  03E00008   JR RA
9D004580  00000000   NOP
2658:                
2659:                #endif /* !_FS_READONLY */
2660:                
2661:                
2662:                
2663:                
2664:                /*-----------------------------------------------------------------------*/
2665:                /* Close File                                                            */
2666:                
2667:                /*-----------------------------------------------------------------------*/
2668:                
2669:                FRESULT f_close(
2670:                        FIL *fp /* Pointer to the file object to be closed */
2671:                        ) {
9D004584  27BDFFE0   ADDIU SP, SP, -32
9D004588  AFBF001C   SW RA, 28(SP)
9D00458C  AFBE0018   SW S8, 24(SP)
9D004590  03A0F021   ADDU S8, SP, ZERO
9D004594  AFC40020   SW A0, 32(S8)
2672:                    FRESULT res;
2673:                
2674:                #if _FS_READONLY
2675:                    FATFS *fs = fp->fs;
2676:                    res = validate(fs, fp->id);
2677:                    if (res == FR_OK) fp->fs = 0; /* Discard file object */
2678:                    LEAVE_FF(fs, res);
2679:                
2680:                #else
2681:                    res = f_sync(fp); /* Flush cached data */
9D004598  8FC40020   LW A0, 32(S8)
9D00459C  0F4010A5   JAL f_sync
9D0045A0  00000000   NOP
9D0045A4  AFC20010   SW V0, 16(S8)
2682:                #if _FS_SHARE
2683:                    if (res == FR_OK) { /* Decrement open counter */
2684:                #if _FS_REENTRANT
2685:                        res = validate(fp->fs, fp->id);
2686:                        if (res == FR_OK) {
2687:                            res = dec_lock(fp->lockid);
2688:                            unlock_fs(fp->fs, FR_OK);
2689:                        }
2690:                #else
2691:                        res = dec_lock(fp->lockid);
2692:                #endif
2693:                    }
2694:                #endif
2695:                    if (res == FR_OK) fp->fs = 0; /* Discard file object */
9D0045A8  8FC20010   LW V0, 16(S8)
9D0045AC  14400003   BNE V0, ZERO, 0x9D0045BC
9D0045B0  00000000   NOP
9D0045B4  8FC20020   LW V0, 32(S8)
9D0045B8  AC400000   SW ZERO, 0(V0)
2696:                    return res;
9D0045BC  8FC20010   LW V0, 16(S8)
2697:                #endif
2698:                }
9D0045C0  03C0E821   ADDU SP, S8, ZERO
9D0045C4  8FBF001C   LW RA, 28(SP)
9D0045C8  8FBE0018   LW S8, 24(SP)
9D0045CC  27BD0020   ADDIU SP, SP, 32
9D0045D0  03E00008   JR RA
9D0045D4  00000000   NOP
2699:                
2700:                
2701:                
2702:                
2703:                /*-----------------------------------------------------------------------*/
2704:                /* Current Drive/Directory Handlings                                     */
2705:                /*-----------------------------------------------------------------------*/
2706:                
2707:                #if _FS_RPATH >= 1
2708:                
2709:                FRESULT f_chdrive(
2710:                        BYTE drv /* Drive number */
2711:                        ) {
9D0045D8  27BDFFF8   ADDIU SP, SP, -8
9D0045DC  AFBE0004   SW S8, 4(SP)
9D0045E0  03A0F021   ADDU S8, SP, ZERO
9D0045E4  00801021   ADDU V0, A0, ZERO
9D0045E8  A3C20008   SB V0, 8(S8)
2712:                    if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
9D0045EC  93C20008   LBU V0, 8(S8)
9D0045F0  10400004   BEQ V0, ZERO, 0x9D004604
9D0045F4  00000000   NOP
9D0045F8  2402000B   ADDIU V0, ZERO, 11
9D0045FC  0B401184   J 0x9D004610
9D004600  00000000   NOP
2713:                
2714:                    CurrVol = drv;
9D004604  93C20008   LBU V0, 8(S8)
9D004608  A382805E   SB V0, -32674(GP)
2715:                
2716:                    return FR_OK;
9D00460C  00001021   ADDU V0, ZERO, ZERO
2717:                }
9D004610  03C0E821   ADDU SP, S8, ZERO
9D004614  8FBE0004   LW S8, 4(SP)
9D004618  27BD0008   ADDIU SP, SP, 8
9D00461C  03E00008   JR RA
9D004620  00000000   NOP
2718:                
2719:                FRESULT f_chdir(
2720:                        const TCHAR *path /* Pointer to the directory path */
2721:                        ) {
9D004624  27BDFFB8   ADDIU SP, SP, -72
9D004628  AFBF0044   SW RA, 68(SP)
9D00462C  AFBE0040   SW S8, 64(SP)
9D004630  03A0F021   ADDU S8, SP, ZERO
9D004634  AFC40048   SW A0, 72(S8)
2722:                    FRESULT res;
2723:                    DIR dj;
2724:                    DEF_NAMEBUF;
2725:                
2726:                
2727:                    res = chk_mounted(&path, &dj.fs, 0);
9D004638  27C20014   ADDIU V0, S8, 20
9D00463C  27C40048   ADDIU A0, S8, 72
9D004640  00402821   ADDU A1, V0, ZERO
9D004644  00003021   ADDU A2, ZERO, ZERO
9D004648  0F400998   JAL 0x9D002660
9D00464C  00000000   NOP
9D004650  AFC20010   SW V0, 16(S8)
2728:                    if (res == FR_OK) {
9D004654  8FC20010   LW V0, 16(S8)
9D004658  14400041   BNE V0, ZERO, 0x9D004760
9D00465C  00000000   NOP
2729:                        INIT_BUF(dj);
9D004660  27C20030   ADDIU V0, S8, 48
9D004664  AFC2002C   SW V0, 44(S8)
2730:                        res = follow_path(&dj, path); /* Follow the path */
9D004668  8FC20048   LW V0, 72(S8)
9D00466C  27C30014   ADDIU V1, S8, 20
9D004670  00602021   ADDU A0, V1, ZERO
9D004674  00402821   ADDU A1, V0, ZERO
9D004678  0F400897   JAL 0x9D00225C
9D00467C  00000000   NOP
9D004680  AFC20010   SW V0, 16(S8)
2731:                        FREE_BUF();
2732:                        if (res == FR_OK) { /* Follow completed */
9D004684  8FC20010   LW V0, 16(S8)
9D004688  1440002F   BNE V0, ZERO, 0x9D004748
9D00468C  00000000   NOP
2733:                            if (!dj.dir) {
9D004690  8FC20028   LW V0, 40(S8)
9D004694  14400006   BNE V0, ZERO, 0x9D0046B0
9D004698  00000000   NOP
2734:                                dj.fs->cdir = dj.sclust; /* Start directory itself */
9D00469C  8FC20014   LW V0, 20(S8)
9D0046A0  8FC3001C   LW V1, 28(S8)
9D0046A4  AC430018   SW V1, 24(V0)
9D0046A8  0B4011D2   J 0x9D004748
9D0046AC  00000000   NOP
2735:                            } else {
2736:                                if (dj.dir[DIR_Attr] & AM_DIR) /* Reached to the directory */
9D0046B0  8FC20028   LW V0, 40(S8)
9D0046B4  2442000B   ADDIU V0, V0, 11
9D0046B8  90420000   LBU V0, 0(V0)
9D0046BC  30420010   ANDI V0, V0, 16
9D0046C0  1040001F   BEQ V0, ZERO, 0x9D004740
9D0046C4  00000000   NOP
2737:                                    dj.fs->cdir = LD_CLUST(dj.dir);
9D0046C8  8FC20014   LW V0, 20(S8)
9D0046CC  8FC30028   LW V1, 40(S8)
9D0046D0  24630015   ADDIU V1, V1, 21
9D0046D4  90630000   LBU V1, 0(V1)
9D0046D8  00031A00   SLL V1, V1, 8
9D0046DC  7C032620   SEH A0, V1
9D0046E0  8FC30028   LW V1, 40(S8)
9D0046E4  24630014   ADDIU V1, V1, 20
9D0046E8  90630000   LBU V1, 0(V1)
9D0046EC  7C031E20   SEH V1, V1
9D0046F0  00831825   OR V1, A0, V1
9D0046F4  7C031E20   SEH V1, V1
9D0046F8  3063FFFF   ANDI V1, V1, -1
9D0046FC  00032400   SLL A0, V1, 16
9D004700  8FC30028   LW V1, 40(S8)
9D004704  2463001B   ADDIU V1, V1, 27
9D004708  90630000   LBU V1, 0(V1)
9D00470C  00031A00   SLL V1, V1, 8
9D004710  7C032E20   SEH A1, V1
9D004714  8FC30028   LW V1, 40(S8)
9D004718  2463001A   ADDIU V1, V1, 26
9D00471C  90630000   LBU V1, 0(V1)
9D004720  7C031E20   SEH V1, V1
9D004724  00A31825   OR V1, A1, V1
9D004728  7C031E20   SEH V1, V1
9D00472C  3063FFFF   ANDI V1, V1, -1
9D004730  00831825   OR V1, A0, V1
9D004734  AC430018   SW V1, 24(V0)
9D004738  0B4011D2   J 0x9D004748
9D00473C  00000000   NOP
2738:                                else
2739:                                    res = FR_NO_PATH; /* Reached but a file */
9D004740  24020005   ADDIU V0, ZERO, 5
9D004744  AFC20010   SW V0, 16(S8)
2740:                            }
2741:                        }
2742:                        if (res == FR_NO_FILE) res = FR_NO_PATH;
9D004748  8FC30010   LW V1, 16(S8)
9D00474C  24020004   ADDIU V0, ZERO, 4
9D004750  14620003   BNE V1, V0, 0x9D004760
9D004754  00000000   NOP
9D004758  24020005   ADDIU V0, ZERO, 5
9D00475C  AFC20010   SW V0, 16(S8)
2743:                    }
2744:                
2745:                    LEAVE_FF(dj.fs, res);
9D004760  8FC20010   LW V0, 16(S8)
2746:                }
9D004764  03C0E821   ADDU SP, S8, ZERO
9D004768  8FBF0044   LW RA, 68(SP)
9D00476C  8FBE0040   LW S8, 64(SP)
9D004770  27BD0048   ADDIU SP, SP, 72
9D004774  03E00008   JR RA
9D004778  00000000   NOP
2747:                
2748:                
2749:                #if _FS_RPATH >= 2
2750:                
2751:                FRESULT f_getcwd(
2752:                        TCHAR *path, /* Pointer to the directory path */
2753:                        UINT sz_path /* Size of path */
2754:                        ) {
9D00477C  27BDFF90   ADDIU SP, SP, -112
9D004780  AFBF006C   SW RA, 108(SP)
9D004784  AFBE0068   SW S8, 104(SP)
9D004788  03A0F021   ADDU S8, SP, ZERO
9D00478C  AFC40070   SW A0, 112(S8)
9D004790  AFC50074   SW A1, 116(S8)
2755:                    FRESULT res;
2756:                    DIR dj;
2757:                    UINT i, n;
2758:                    DWORD ccl;
2759:                    TCHAR *tp;
2760:                    FILINFO fno;
2761:                    DEF_NAMEBUF;
2762:                
2763:                
2764:                    *path = 0;
9D004794  8FC20070   LW V0, 112(S8)
9D004798  A0400000   SB ZERO, 0(V0)
2765:                    res = chk_mounted((const TCHAR**) &path, &dj.fs, 0); /* Get current volume */
9D00479C  27C20024   ADDIU V0, S8, 36
9D0047A0  27C40070   ADDIU A0, S8, 112
9D0047A4  00402821   ADDU A1, V0, ZERO
9D0047A8  00003021   ADDU A2, ZERO, ZERO
9D0047AC  0F400998   JAL 0x9D002660
9D0047B0  00000000   NOP
9D0047B4  AFC20010   SW V0, 16(S8)
2766:                    if (res == FR_OK) {
9D0047B8  8FC20010   LW V0, 16(S8)
9D0047BC  144000F8   BNE V0, ZERO, 0x9D004BA0
9D0047C0  00000000   NOP
2767:                        INIT_BUF(dj);
9D0047C4  27C20058   ADDIU V0, S8, 88
9D0047C8  AFC2003C   SW V0, 60(S8)
2768:                        i = sz_path; /* Bottom of buffer (dir stack base) */
9D0047CC  8FC20074   LW V0, 116(S8)
9D0047D0  AFC20014   SW V0, 20(S8)
2769:                        dj.sclust = dj.fs->cdir; /* Start to follow upper dir from current dir */
9D0047D4  8FC20024   LW V0, 36(S8)
9D0047D8  8C420018   LW V0, 24(V0)
9D0047DC  AFC2002C   SW V0, 44(S8)
2770:                        while ((ccl = dj.sclust) != 0) { /* Repeat while current dir is a sub-dir */
9D0047E0  0B4012A4   J 0x9D004A90
9D0047E4  00000000   NOP
9D004A90  8FC2002C   LW V0, 44(S8)
9D004A94  AFC20020   SW V0, 32(S8)
9D004A98  8FC20020   LW V0, 32(S8)
9D004A9C  1440FF52   BNE V0, ZERO, 0x9D0047E8
9D004AA0  00000000   NOP
9D004AA4  0B4012B5   J 0x9D004AD4
9D004AA8  00000000   NOP
2771:                            res = dir_sdi(&dj, 1); /* Get parent dir */
9D0047E8  27C20024   ADDIU V0, S8, 36
9D0047EC  00402021   ADDU A0, V0, ZERO
9D0047F0  24050001   ADDIU A1, ZERO, 1
9D0047F4  0F40045E   JAL 0x9D001178
9D0047F8  00000000   NOP
9D0047FC  AFC20010   SW V0, 16(S8)
2772:                            if (res != FR_OK) break;
9D004800  8FC20010   LW V0, 16(S8)
9D004804  144000A9   BNE V0, ZERO, 0x9D004AAC
9D004808  00000000   NOP
9D004AAC  00000000   NOP
9D004AB0  0B4012B5   J 0x9D004AD4
9D004AB4  00000000   NOP
2773:                            res = dir_read(&dj);
9D00480C  27C20024   ADDIU V0, S8, 36
9D004810  00402021   ADDU A0, V0, ZERO
9D004814  0F400618   JAL 0x9D001860
9D004818  00000000   NOP
9D00481C  AFC20010   SW V0, 16(S8)
2774:                            if (res != FR_OK) break;
9D004820  8FC20010   LW V0, 16(S8)
9D004824  144000A4   BNE V0, ZERO, 0x9D004AB8
9D004828  00000000   NOP
9D004AB8  00000000   NOP
9D004ABC  0B4012B5   J 0x9D004AD4
9D004AC0  00000000   NOP
2775:                            dj.sclust = LD_CLUST(dj.dir); /* Goto parent dir */
9D00482C  8FC20038   LW V0, 56(S8)
9D004830  24420015   ADDIU V0, V0, 21
9D004834  90420000   LBU V0, 0(V0)
9D004838  00021200   SLL V0, V0, 8
9D00483C  7C021E20   SEH V1, V0
9D004840  8FC20038   LW V0, 56(S8)
9D004844  24420014   ADDIU V0, V0, 20
9D004848  90420000   LBU V0, 0(V0)
9D00484C  7C021620   SEH V0, V0
9D004850  00621025   OR V0, V1, V0
9D004854  7C021620   SEH V0, V0
9D004858  3042FFFF   ANDI V0, V0, -1
9D00485C  00021C00   SLL V1, V0, 16
9D004860  8FC20038   LW V0, 56(S8)
9D004864  2442001B   ADDIU V0, V0, 27
9D004868  90420000   LBU V0, 0(V0)
9D00486C  00021200   SLL V0, V0, 8
9D004870  7C022620   SEH A0, V0
9D004874  8FC20038   LW V0, 56(S8)
9D004878  2442001A   ADDIU V0, V0, 26
9D00487C  90420000   LBU V0, 0(V0)
9D004880  7C021620   SEH V0, V0
9D004884  00821025   OR V0, A0, V0
9D004888  7C021620   SEH V0, V0
9D00488C  3042FFFF   ANDI V0, V0, -1
9D004890  00621025   OR V0, V1, V0
9D004894  AFC2002C   SW V0, 44(S8)
2776:                            res = dir_sdi(&dj, 0);
9D004898  27C20024   ADDIU V0, S8, 36
9D00489C  00402021   ADDU A0, V0, ZERO
9D0048A0  00002821   ADDU A1, ZERO, ZERO
9D0048A4  0F40045E   JAL 0x9D001178
9D0048A8  00000000   NOP
9D0048AC  AFC20010   SW V0, 16(S8)
2777:                            if (res != FR_OK) break;
9D0048B0  8FC20010   LW V0, 16(S8)
9D0048B4  14400083   BNE V0, ZERO, 0x9D004AC4
9D0048B8  00000000   NOP
9D004AC4  00000000   NOP
9D004AC8  0B4012B5   J 0x9D004AD4
9D004ACC  00000000   NOP
2778:                            do { /* Find the entry links to the child dir */
2779:                                res = dir_read(&dj);
9D0048BC  27C20024   ADDIU V0, S8, 36
9D0048C0  00402021   ADDU A0, V0, ZERO
9D0048C4  0F400618   JAL 0x9D001860
9D0048C8  00000000   NOP
9D0048CC  AFC20010   SW V0, 16(S8)
2780:                                if (res != FR_OK) break;
9D0048D0  8FC20010   LW V0, 16(S8)
9D0048D4  14400029   BNE V0, ZERO, 0x9D00497C
9D0048D8  00000000   NOP
9D00497C  00000000   NOP
9D004980  0B401263   J 0x9D00498C
9D004984  00000000   NOP
2781:                                if (ccl == LD_CLUST(dj.dir)) break; /* Found the entry */
9D0048DC  8FC20038   LW V0, 56(S8)
9D0048E0  24420015   ADDIU V0, V0, 21
9D0048E4  90420000   LBU V0, 0(V0)
9D0048E8  00021200   SLL V0, V0, 8
9D0048EC  7C021E20   SEH V1, V0
9D0048F0  8FC20038   LW V0, 56(S8)
9D0048F4  24420014   ADDIU V0, V0, 20
9D0048F8  90420000   LBU V0, 0(V0)
9D0048FC  7C021620   SEH V0, V0
9D004900  00621025   OR V0, V1, V0
9D004904  7C021620   SEH V0, V0
9D004908  3042FFFF   ANDI V0, V0, -1
9D00490C  00021C00   SLL V1, V0, 16
9D004910  8FC20038   LW V0, 56(S8)
9D004914  2442001B   ADDIU V0, V0, 27
9D004918  90420000   LBU V0, 0(V0)
9D00491C  00021200   SLL V0, V0, 8
9D004920  7C022620   SEH A0, V0
9D004924  8FC20038   LW V0, 56(S8)
9D004928  2442001A   ADDIU V0, V0, 26
9D00492C  90420000   LBU V0, 0(V0)
9D004930  7C021620   SEH V0, V0
9D004934  00821025   OR V0, A0, V0
9D004938  7C021620   SEH V0, V0
9D00493C  3042FFFF   ANDI V0, V0, -1
9D004940  00621825   OR V1, V1, V0
9D004944  8FC20020   LW V0, 32(S8)
9D004948  1062000F   BEQ V1, V0, 0x9D004988
9D00494C  00000000   NOP
9D004988  00000000   NOP
2782:                                res = dir_next(&dj, 0);
9D004950  27C20024   ADDIU V0, S8, 36
9D004954  00402021   ADDU A0, V0, ZERO
9D004958  00002821   ADDU A1, ZERO, ZERO
9D00495C  0F4004ED   JAL 0x9D0013B4
9D004960  00000000   NOP
9D004964  AFC20010   SW V0, 16(S8)
2783:                            } while (res == FR_OK);
9D004968  8FC20010   LW V0, 16(S8)
9D00496C  1040FFD3   BEQ V0, ZERO, 0x9D0048BC
9D004970  00000000   NOP
9D004974  0B401263   J 0x9D00498C
9D004978  00000000   NOP
2784:                            if (res == FR_NO_FILE) res = FR_INT_ERR; /* It cannot be 'not found'. */
9D00498C  8FC30010   LW V1, 16(S8)
9D004990  24020004   ADDIU V0, ZERO, 4
9D004994  14620003   BNE V1, V0, 0x9D0049A4
9D004998  00000000   NOP
9D00499C  24020002   ADDIU V0, ZERO, 2
9D0049A0  AFC20010   SW V0, 16(S8)
2785:                            if (res != FR_OK) break;
9D0049A4  8FC20010   LW V0, 16(S8)
9D0049A8  14400049   BNE V0, ZERO, 0x9D004AD0
9D0049AC  00000000   NOP
9D004AD0  00000000   NOP
2786:                #if _USE_LFN
2787:                            fno.lfname = path;
2788:                            fno.lfsize = i;
2789:                #endif
2790:                            get_fileinfo(&dj, &fno); /* Get the dir name and push it to the buffer */
9D0049B0  27C30024   ADDIU V1, S8, 36
9D0049B4  27C20040   ADDIU V0, S8, 64
9D0049B8  00602021   ADDU A0, V1, ZERO
9D0049BC  00402821   ADDU A1, V0, ZERO
9D0049C0  0F4007FD   JAL 0x9D001FF4
9D0049C4  00000000   NOP
2791:                            tp = fno.fname;
9D0049C8  27C20040   ADDIU V0, S8, 64
9D0049CC  24420009   ADDIU V0, V0, 9
9D0049D0  AFC2001C   SW V0, 28(S8)
2792:                            if (_USE_LFN && *path) tp = path;
2793:                            for (n = 0; tp[n]; n++);
9D0049D4  AFC00018   SW ZERO, 24(S8)
9D0049D8  0B40127B   J 0x9D0049EC
9D0049DC  00000000   NOP
9D0049E0  8FC20018   LW V0, 24(S8)
9D0049E4  24420001   ADDIU V0, V0, 1
9D0049E8  AFC20018   SW V0, 24(S8)
9D0049EC  8FC3001C   LW V1, 28(S8)
9D0049F0  8FC20018   LW V0, 24(S8)
9D0049F4  00621021   ADDU V0, V1, V0
9D0049F8  80420000   LB V0, 0(V0)
9D0049FC  1440FFF8   BNE V0, ZERO, 0x9D0049E0
9D004A00  00000000   NOP
2794:                            if (i < n + 3) {
9D004A04  8FC20018   LW V0, 24(S8)
9D004A08  24430003   ADDIU V1, V0, 3
9D004A0C  8FC20014   LW V0, 20(S8)
9D004A10  0043102B   SLTU V0, V0, V1
9D004A14  10400013   BEQ V0, ZERO, 0x9D004A64
9D004A18  00000000   NOP
2795:                                res = FR_NOT_ENOUGH_CORE;
9D004A1C  24020011   ADDIU V0, ZERO, 17
9D004A20  AFC20010   SW V0, 16(S8)
2796:                                break;
9D004A24  0B4012B5   J 0x9D004AD4
9D004A28  00000000   NOP
2797:                            }
2798:                            while (n) path[--i] = tp[--n];
9D004A2C  8FC30070   LW V1, 112(S8)
9D004A30  8FC20014   LW V0, 20(S8)
9D004A34  2442FFFF   ADDIU V0, V0, -1
9D004A38  AFC20014   SW V0, 20(S8)
9D004A3C  8FC20014   LW V0, 20(S8)
9D004A40  00621021   ADDU V0, V1, V0
9D004A44  8FC30018   LW V1, 24(S8)
9D004A48  2463FFFF   ADDIU V1, V1, -1
9D004A4C  AFC30018   SW V1, 24(S8)
9D004A50  8FC4001C   LW A0, 28(S8)
9D004A54  8FC30018   LW V1, 24(S8)
9D004A58  00831821   ADDU V1, A0, V1
9D004A5C  80630000   LB V1, 0(V1)
9D004A60  A0430000   SB V1, 0(V0)
9D004A64  8FC20018   LW V0, 24(S8)
9D004A68  1440FFF0   BNE V0, ZERO, 0x9D004A2C
9D004A6C  00000000   NOP
2799:                            path[--i] = '/';
9D004A70  8FC30070   LW V1, 112(S8)
9D004A74  8FC20014   LW V0, 20(S8)
9D004A78  2442FFFF   ADDIU V0, V0, -1
9D004A7C  AFC20014   SW V0, 20(S8)
9D004A80  8FC20014   LW V0, 20(S8)
9D004A84  00621021   ADDU V0, V1, V0
9D004A88  2403002F   ADDIU V1, ZERO, 47
9D004A8C  A0430000   SB V1, 0(V0)
2800:                        }
2801:                        tp = path;
9D004AD4  8FC20070   LW V0, 112(S8)
9D004AD8  AFC2001C   SW V0, 28(S8)
2802:                        if (res == FR_OK) {
9D004ADC  8FC20010   LW V0, 16(S8)
9D004AE0  1440002D   BNE V0, ZERO, 0x9D004B98
9D004AE4  00000000   NOP
2803:                            *tp++ = '0' + CurrVol; /* Put drive number */
9D004AE8  9382805E   LBU V0, -32674(GP)
9D004AEC  24420030   ADDIU V0, V0, 48
9D004AF0  304200FF   ANDI V0, V0, 255
9D004AF4  7C021C20   SEB V1, V0
9D004AF8  8FC2001C   LW V0, 28(S8)
9D004AFC  A0430000   SB V1, 0(V0)
9D004B00  8FC2001C   LW V0, 28(S8)
9D004B04  24420001   ADDIU V0, V0, 1
9D004B08  AFC2001C   SW V0, 28(S8)
2804:                            *tp++ = ':';
9D004B0C  8FC2001C   LW V0, 28(S8)
9D004B10  2403003A   ADDIU V1, ZERO, 58
9D004B14  A0430000   SB V1, 0(V0)
9D004B18  8FC2001C   LW V0, 28(S8)
9D004B1C  24420001   ADDIU V0, V0, 1
9D004B20  AFC2001C   SW V0, 28(S8)
2805:                            if (i == sz_path) { /* Root-dir */
9D004B24  8FC30014   LW V1, 20(S8)
9D004B28  8FC20074   LW V0, 116(S8)
9D004B2C  14620009   BNE V1, V0, 0x9D004B54
9D004B30  00000000   NOP
2806:                                *tp++ = '/';
9D004B34  8FC2001C   LW V0, 28(S8)
9D004B38  2403002F   ADDIU V1, ZERO, 47
9D004B3C  A0430000   SB V1, 0(V0)
9D004B40  8FC2001C   LW V0, 28(S8)
9D004B44  24420001   ADDIU V0, V0, 1
9D004B48  AFC2001C   SW V0, 28(S8)
9D004B4C  0B4012E6   J 0x9D004B98
9D004B50  00000000   NOP
2807:                            } else { /* Sub-dir */
2808:                                do /* Add stacked path str */
2809:                                    *tp++ = path[i++]; while (i < sz_path);
9D004B54  8FC30070   LW V1, 112(S8)
9D004B58  8FC20014   LW V0, 20(S8)
9D004B5C  00621021   ADDU V0, V1, V0
9D004B60  80430000   LB V1, 0(V0)
9D004B64  8FC2001C   LW V0, 28(S8)
9D004B68  A0430000   SB V1, 0(V0)
9D004B6C  8FC2001C   LW V0, 28(S8)
9D004B70  24420001   ADDIU V0, V0, 1
9D004B74  AFC2001C   SW V0, 28(S8)
9D004B78  8FC20014   LW V0, 20(S8)
9D004B7C  24420001   ADDIU V0, V0, 1
9D004B80  AFC20014   SW V0, 20(S8)
9D004B84  8FC30014   LW V1, 20(S8)
9D004B88  8FC20074   LW V0, 116(S8)
9D004B8C  0062102B   SLTU V0, V1, V0
9D004B90  1440FFF0   BNE V0, ZERO, 0x9D004B54
9D004B94  00000000   NOP
2810:                            }
2811:                        }
2812:                        *tp = 0;
9D004B98  8FC2001C   LW V0, 28(S8)
9D004B9C  A0400000   SB ZERO, 0(V0)
2813:                        FREE_BUF();
2814:                    }
2815:                
2816:                    LEAVE_FF(dj.fs, res);
9D004BA0  8FC20010   LW V0, 16(S8)
2817:                }
9D004BA4  03C0E821   ADDU SP, S8, ZERO
9D004BA8  8FBF006C   LW RA, 108(SP)
9D004BAC  8FBE0068   LW S8, 104(SP)
9D004BB0  27BD0070   ADDIU SP, SP, 112
9D004BB4  03E00008   JR RA
9D004BB8  00000000   NOP
2818:                #endif /* _FS_RPATH >= 2 */
2819:                #endif /* _FS_RPATH >= 1 */
2820:                
2821:                
2822:                
2823:                #if _FS_MINIMIZE <= 2
2824:                /*-----------------------------------------------------------------------*/
2825:                /* Seek File R/W Pointer                                                 */
2826:                
2827:                /*-----------------------------------------------------------------------*/
2828:                
2829:                FRESULT f_lseek(
2830:                        FIL *fp, /* Pointer to the file object */
2831:                        DWORD ofs /* File pointer from top of file */
2832:                        ) {
9D004BBC  27BDFFD0   ADDIU SP, SP, -48
9D004BC0  AFBF002C   SW RA, 44(SP)
9D004BC4  AFBE0028   SW S8, 40(SP)
9D004BC8  03A0F021   ADDU S8, SP, ZERO
9D004BCC  AFC40030   SW A0, 48(S8)
9D004BD0  AFC50034   SW A1, 52(S8)
2833:                    FRESULT res;
2834:                
2835:                
2836:                    res = validate(fp->fs, fp->id); /* Check validity of the object */
9D004BD4  8FC20030   LW V0, 48(S8)
9D004BD8  8C430000   LW V1, 0(V0)
9D004BDC  8FC20030   LW V0, 48(S8)
9D004BE0  94420004   LHU V0, 4(V0)
9D004BE4  00602021   ADDU A0, V1, ZERO
9D004BE8  00402821   ADDU A1, V0, ZERO
9D004BEC  0F400C25   JAL 0x9D003094
9D004BF0  00000000   NOP
9D004BF4  AFC20018   SW V0, 24(S8)
2837:                    if (res != FR_OK) LEAVE_FF(fp->fs, res);
9D004BF8  8FC20018   LW V0, 24(S8)
9D004BFC  10400004   BEQ V0, ZERO, 0x9D004C10
9D004C00  00000000   NOP
9D004C04  8FC20018   LW V0, 24(S8)
9D004C08  0B401451   J 0x9D005144
9D004C0C  00000000   NOP
2838:                    if (fp->flag & FA__ERROR) /* Check abort flag */
9D004C10  8FC20030   LW V0, 48(S8)
9D004C14  90420006   LBU V0, 6(V0)
9D004C18  7C021420   SEB V0, V0
9D004C1C  04410004   BGEZ V0, 0x9D004C30
9D004C20  00000000   NOP
2839:                        LEAVE_FF(fp->fs, FR_INT_ERR);
9D004C24  24020002   ADDIU V0, ZERO, 2
9D004C28  0B401451   J 0x9D005144
9D004C2C  00000000   NOP
2840:                
2841:                #if _USE_FASTSEEK
2842:                    if (fp->cltbl) { /* Fast seek */
2843:                        DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
2844:                
2845:                        if (ofs == CREATE_LINKMAP) { /* Create CLMT */
2846:                            tbl = fp->cltbl;
2847:                            tlen = *tbl++;
2848:                            ulen = 2; /* Given table size and required table size */
2849:                            cl = fp->sclust; /* Top of the chain */
2850:                            if (cl) {
2851:                                do {
2852:                                    /* Get a fragment */
2853:                                    tcl = cl;
2854:                                    ncl = 0;
2855:                                    ulen += 2; /* Top, length and used items */
2856:                                    do {
2857:                                        pcl = cl;
2858:                                        ncl++;
2859:                                        cl = get_fat(fp->fs, cl);
2860:                                        if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
2861:                                        if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
2862:                                    } while (cl == pcl + 1);
2863:                                    if (ulen <= tlen) { /* Store the length and top of the fragment */
2864:                                        *tbl++ = ncl;
2865:                                        *tbl++ = tcl;
2866:                                    }
2867:                                } while (cl < fp->fs->n_fatent); /* Repeat until end of chain */
2868:                            }
2869:                            *fp->cltbl = ulen; /* Number of items used */
2870:                            if (ulen <= tlen)
2871:                                *tbl = 0; /* Terminate table */
2872:                            else
2873:                                res = FR_NOT_ENOUGH_CORE; /* Given table size is smaller than required */
2874:                
2875:                        } else { /* Fast seek */
2876:                            if (ofs > fp->fsize) /* Clip offset at the file size */
2877:                                ofs = fp->fsize;
2878:                            fp->fptr = ofs; /* Set file pointer */
2879:                            if (ofs) {
2880:                                fp->clust = clmt_clust(fp, ofs - 1);
2881:                                dsc = clust2sect(fp->fs, fp->clust);
2882:                                if (!dsc) ABORT(fp->fs, FR_INT_ERR);
2883:                                dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
2884:                                if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) { /* Refill sector cache if needed */
2885:                #if !_FS_TINY
2886:                #if !_FS_READONLY
2887:                                    if (fp->flag & FA__DIRTY) { /* Write-back dirty sector cache */
2888:                                        if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2889:                                            ABORT(fp->fs, FR_DISK_ERR);
2890:                                        fp->flag &= ~FA__DIRTY;
2891:                                    }
2892:                #endif
2893:                                    if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK) /* Load current sector */
2894:                                        ABORT(fp->fs, FR_DISK_ERR);
2895:                #endif
2896:                                    fp->dsect = dsc;
2897:                                }
2898:                            }
2899:                        }
2900:                    } else
2901:                #endif
2902:                
2903:                        /* Normal Seek */ {
2904:                        DWORD clst, bcs, nsect, ifptr;
2905:                
2906:                        if (ofs > fp->fsize /* In read-only mode, clip offset with the file size */
9D004C30  8FC20030   LW V0, 48(S8)
9D004C34  8C43000C   LW V1, 12(V0)
9D004C38  8FC20034   LW V0, 52(S8)
9D004C3C  0062102B   SLTU V0, V1, V0
9D004C40  10400009   BEQ V0, ZERO, 0x9D004C68
9D004C44  00000000   NOP
2907:                #if !_FS_READONLY
2908:                                && !(fp->flag & FA_WRITE)
9D004C48  8FC20030   LW V0, 48(S8)
9D004C4C  90420006   LBU V0, 6(V0)
9D004C50  30420002   ANDI V0, V0, 2
9D004C54  14400004   BNE V0, ZERO, 0x9D004C68
9D004C58  00000000   NOP
2909:                #endif
2910:                                ) ofs = fp->fsize;
9D004C5C  8FC20030   LW V0, 48(S8)
9D004C60  8C42000C   LW V0, 12(V0)
9D004C64  AFC20034   SW V0, 52(S8)
2911:                
2912:                        ifptr = fp->fptr;
9D004C68  8FC20030   LW V0, 48(S8)
9D004C6C  8C420008   LW V0, 8(V0)
9D004C70  AFC2001C   SW V0, 28(S8)
2913:                        fp->fptr = nsect = 0;
9D004C74  AFC00014   SW ZERO, 20(S8)
9D004C78  8FC20030   LW V0, 48(S8)
9D004C7C  8FC30014   LW V1, 20(S8)
9D004C80  AC430008   SW V1, 8(V0)
2914:                        if (ofs) {
9D004C84  8FC20034   LW V0, 52(S8)
9D004C88  104000D2   BEQ V0, ZERO, 0x9D004FD4
9D004C8C  00000000   NOP
2915:                            bcs = (DWORD) fp->fs->csize * SS(fp->fs); /* Cluster size (byte) */
9D004C90  8FC20030   LW V0, 48(S8)
9D004C94  8C420000   LW V0, 0(V0)
9D004C98  90420002   LBU V0, 2(V0)
9D004C9C  00021240   SLL V0, V0, 9
9D004CA0  AFC20020   SW V0, 32(S8)
2916:                            if (ifptr > 0 &&
9D004CA4  8FC2001C   LW V0, 28(S8)
9D004CA8  10400024   BEQ V0, ZERO, 0x9D004D3C
9D004CAC  00000000   NOP
9D004CEC  0062102B   SLTU V0, V1, V0
9D004CF0  14400012   BNE V0, ZERO, 0x9D004D3C
9D004CF4  00000000   NOP
2917:                                    (ofs - 1) / bcs >= (ifptr - 1) / bcs) { /* When seek to same or following cluster, */
9D004CB0  8FC20034   LW V0, 52(S8)
9D004CB4  2443FFFF   ADDIU V1, V0, -1
9D004CB8  8FC20020   LW V0, 32(S8)
9D004CBC  0062001B   DIVU V1, V0
9D004CC0  004001F4   TEQ V0, ZERO
9D004CC4  00001810   MFHI V1
9D004CC8  00001012   MFLO V0
9D004CCC  00401821   ADDU V1, V0, ZERO
9D004CD0  8FC2001C   LW V0, 28(S8)
9D004CD4  2444FFFF   ADDIU A0, V0, -1
9D004CD8  8FC20020   LW V0, 32(S8)
9D004CDC  0082001B   DIVU A0, V0
9D004CE0  004001F4   TEQ V0, ZERO
9D004CE4  00002010   MFHI A0
9D004CE8  00001012   MFLO V0
2918:                                fp->fptr = (ifptr - 1) & ~(bcs - 1); /* start from the current cluster */
9D004CF8  8FC2001C   LW V0, 28(S8)
9D004CFC  2443FFFF   ADDIU V1, V0, -1
9D004D00  8FC20020   LW V0, 32(S8)
9D004D04  00021023   SUBU V0, ZERO, V0
9D004D08  00621824   AND V1, V1, V0
9D004D0C  8FC20030   LW V0, 48(S8)
9D004D10  AC430008   SW V1, 8(V0)
2919:                                ofs -= fp->fptr;
9D004D14  8FC20030   LW V0, 48(S8)
9D004D18  8C420008   LW V0, 8(V0)
9D004D1C  8FC30034   LW V1, 52(S8)
9D004D20  00621023   SUBU V0, V1, V0
9D004D24  AFC20034   SW V0, 52(S8)
2920:                                clst = fp->clust;
9D004D28  8FC20030   LW V0, 48(S8)
9D004D2C  8C420014   LW V0, 20(V0)
9D004D30  AFC20010   SW V0, 16(S8)
9D004D34  0B40137E   J 0x9D004DF8
9D004D38  00000000   NOP
2921:                            } else { /* When seek to back cluster, */
2922:                                clst = fp->sclust; /* start from the first cluster */
9D004D3C  8FC20030   LW V0, 48(S8)
9D004D40  8C420010   LW V0, 16(V0)
9D004D44  AFC20010   SW V0, 16(S8)
2923:                #if !_FS_READONLY
2924:                                if (clst == 0) { /* If no cluster chain, create a new chain */
9D004D48  8FC20010   LW V0, 16(S8)
9D004D4C  14400027   BNE V0, ZERO, 0x9D004DEC
9D004D50  00000000   NOP
2925:                                    clst = create_chain(fp->fs, 0);
9D004D54  8FC20030   LW V0, 48(S8)
9D004D58  8C420000   LW V0, 0(V0)
9D004D5C  00402021   ADDU A0, V0, ZERO
9D004D60  00002821   ADDU A1, ZERO, ZERO
9D004D64  0F4003C2   JAL 0x9D000F08
9D004D68  00000000   NOP
9D004D6C  AFC20010   SW V0, 16(S8)
2926:                                    if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
9D004D70  8FC30010   LW V1, 16(S8)
9D004D74  24020001   ADDIU V0, ZERO, 1
9D004D78  1462000B   BNE V1, V0, 0x9D004DA8
9D004D7C  00000000   NOP
9D004D80  8FC20030   LW V0, 48(S8)
9D004D84  90430006   LBU V1, 6(V0)
9D004D88  2402FF80   ADDIU V0, ZERO, -128
9D004D8C  00621025   OR V0, V1, V0
9D004D90  304300FF   ANDI V1, V0, 255
9D004D94  8FC20030   LW V0, 48(S8)
9D004D98  A0430006   SB V1, 6(V0)
9D004D9C  24020002   ADDIU V0, ZERO, 2
9D004DA0  0B401451   J 0x9D005144
9D004DA4  00000000   NOP
2927:                                    if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
9D004DA8  8FC30010   LW V1, 16(S8)
9D004DAC  2402FFFF   ADDIU V0, ZERO, -1
9D004DB0  1462000B   BNE V1, V0, 0x9D004DE0
9D004DB4  00000000   NOP
9D004DB8  8FC20030   LW V0, 48(S8)
9D004DBC  90430006   LBU V1, 6(V0)
9D004DC0  2402FF80   ADDIU V0, ZERO, -128
9D004DC4  00621025   OR V0, V1, V0
9D004DC8  304300FF   ANDI V1, V0, 255
9D004DCC  8FC20030   LW V0, 48(S8)
9D004DD0  A0430006   SB V1, 6(V0)
9D004DD4  24020001   ADDIU V0, ZERO, 1
9D004DD8  0B401451   J 0x9D005144
9D004DDC  00000000   NOP
2928:                                    fp->sclust = clst;
9D004DE0  8FC20030   LW V0, 48(S8)
9D004DE4  8FC30010   LW V1, 16(S8)
9D004DE8  AC430010   SW V1, 16(V0)
2929:                                }
2930:                #endif
2931:                                fp->clust = clst;
9D004DEC  8FC20030   LW V0, 48(S8)
9D004DF0  8FC30010   LW V1, 16(S8)
9D004DF4  AC430014   SW V1, 20(V0)
2932:                            }
2933:                            if (clst != 0) {
9D004DF8  8FC20010   LW V0, 16(S8)
9D004DFC  10400075   BEQ V0, ZERO, 0x9D004FD4
9D004E00  00000000   NOP
2934:                                while (ofs > bcs) { /* Cluster following loop */
9D004E04  0B4013CD   J 0x9D004F34
9D004E08  00000000   NOP
9D004F34  8FC30034   LW V1, 52(S8)
9D004F38  8FC20020   LW V0, 32(S8)
9D004F3C  0043102B   SLTU V0, V0, V1
9D004F40  1440FFB2   BNE V0, ZERO, 0x9D004E0C
9D004F44  00000000   NOP
2935:                #if !_FS_READONLY
2936:                                    if (fp->flag & FA_WRITE) { /* Check if in write mode or not */
9D004E0C  8FC20030   LW V0, 48(S8)
9D004E10  90420006   LBU V0, 6(V0)
9D004E14  30420002   ANDI V0, V0, 2
9D004E18  1040000F   BEQ V0, ZERO, 0x9D004E58
9D004E1C  00000000   NOP
2937:                                        clst = create_chain(fp->fs, clst); /* Force stretch if in write mode */
9D004E20  8FC20030   LW V0, 48(S8)
9D004E24  8C420000   LW V0, 0(V0)
9D004E28  00402021   ADDU A0, V0, ZERO
9D004E2C  8FC50010   LW A1, 16(S8)
9D004E30  0F4003C2   JAL 0x9D000F08
9D004E34  00000000   NOP
9D004E38  AFC20010   SW V0, 16(S8)
2938:                                        if (clst == 0) { /* When disk gets full, clip file size */
9D004E3C  8FC20010   LW V0, 16(S8)
9D004E40  1440000C   BNE V0, ZERO, 0x9D004E74
9D004E44  00000000   NOP
2939:                                            ofs = bcs;
9D004E48  8FC20020   LW V0, 32(S8)
9D004E4C  AFC20034   SW V0, 52(S8)
2940:                                            break;
9D004E50  0B4013D2   J 0x9D004F48
9D004E54  00000000   NOP
2941:                                        }
2942:                                    } else
2943:                #endif
2944:                                        clst = get_fat(fp->fs, clst); /* Follow cluster chain if not in write mode */
9D004E58  8FC20030   LW V0, 48(S8)
9D004E5C  8C420000   LW V0, 0(V0)
9D004E60  00402021   ADDU A0, V0, ZERO
9D004E64  8FC50010   LW A1, 16(S8)
9D004E68  0F4001B4   JAL get_fat
9D004E6C  00000000   NOP
9D004E70  AFC20010   SW V0, 16(S8)
2945:                                    if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
9D004E74  8FC30010   LW V1, 16(S8)
9D004E78  2402FFFF   ADDIU V0, ZERO, -1
9D004E7C  1462000B   BNE V1, V0, 0x9D004EAC
9D004E80  00000000   NOP
9D004E84  8FC20030   LW V0, 48(S8)
9D004E88  90430006   LBU V1, 6(V0)
9D004E8C  2402FF80   ADDIU V0, ZERO, -128
9D004E90  00621025   OR V0, V1, V0
9D004E94  304300FF   ANDI V1, V0, 255
9D004E98  8FC20030   LW V0, 48(S8)
9D004E9C  A0430006   SB V1, 6(V0)
9D004EA0  24020001   ADDIU V0, ZERO, 1
9D004EA4  0B401451   J 0x9D005144
9D004EA8  00000000   NOP
2946:                                    if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
9D004EAC  8FC20010   LW V0, 16(S8)
9D004EB0  2C420002   SLTIU V0, V0, 2
9D004EB4  14400008   BNE V0, ZERO, 0x9D004ED8
9D004EB8  00000000   NOP
9D004EBC  8FC20030   LW V0, 48(S8)
9D004EC0  8C420000   LW V0, 0(V0)
9D004EC4  8C43001C   LW V1, 28(V0)
9D004EC8  8FC20010   LW V0, 16(S8)
9D004ECC  0043102B   SLTU V0, V0, V1
9D004ED0  1440000B   BNE V0, ZERO, 0x9D004F00
9D004ED4  00000000   NOP
9D004ED8  8FC20030   LW V0, 48(S8)
9D004EDC  90430006   LBU V1, 6(V0)
9D004EE0  2402FF80   ADDIU V0, ZERO, -128
9D004EE4  00621025   OR V0, V1, V0
9D004EE8  304300FF   ANDI V1, V0, 255
9D004EEC  8FC20030   LW V0, 48(S8)
9D004EF0  A0430006   SB V1, 6(V0)
9D004EF4  24020002   ADDIU V0, ZERO, 2
9D004EF8  0B401451   J 0x9D005144
9D004EFC  00000000   NOP
2947:                                    fp->clust = clst;
9D004F00  8FC20030   LW V0, 48(S8)
9D004F04  8FC30010   LW V1, 16(S8)
9D004F08  AC430014   SW V1, 20(V0)
2948:                                    fp->fptr += bcs;
9D004F0C  8FC20030   LW V0, 48(S8)
9D004F10  8C430008   LW V1, 8(V0)
9D004F14  8FC20020   LW V0, 32(S8)
9D004F18  00621821   ADDU V1, V1, V0
9D004F1C  8FC20030   LW V0, 48(S8)
9D004F20  AC430008   SW V1, 8(V0)
2949:                                    ofs -= bcs;
9D004F24  8FC30034   LW V1, 52(S8)
9D004F28  8FC20020   LW V0, 32(S8)
9D004F2C  00621023   SUBU V0, V1, V0
9D004F30  AFC20034   SW V0, 52(S8)
2950:                                }
2951:                                fp->fptr += ofs;
9D004F48  8FC20030   LW V0, 48(S8)
9D004F4C  8C430008   LW V1, 8(V0)
9D004F50  8FC20034   LW V0, 52(S8)
9D004F54  00621821   ADDU V1, V1, V0
9D004F58  8FC20030   LW V0, 48(S8)
9D004F5C  AC430008   SW V1, 8(V0)
2952:                                if (ofs % SS(fp->fs)) {
9D004F60  8FC20034   LW V0, 52(S8)
9D004F64  304201FF   ANDI V0, V0, 511
9D004F68  1040001A   BEQ V0, ZERO, 0x9D004FD4
9D004F6C  00000000   NOP
2953:                                    nsect = clust2sect(fp->fs, clst); /* Current sector */
9D004F70  8FC20030   LW V0, 48(S8)
9D004F74  8C420000   LW V0, 0(V0)
9D004F78  00402021   ADDU A0, V0, ZERO
9D004F7C  8FC50010   LW A1, 16(S8)
9D004F80  0F400195   JAL clust2sect
9D004F84  00000000   NOP
9D004F88  AFC20014   SW V0, 20(S8)
2954:                                    if (!nsect) ABORT(fp->fs, FR_INT_ERR);
9D004F8C  8FC20014   LW V0, 20(S8)
9D004F90  1440000B   BNE V0, ZERO, 0x9D004FC0
9D004F94  00000000   NOP
9D004F98  8FC20030   LW V0, 48(S8)
9D004F9C  90430006   LBU V1, 6(V0)
9D004FA0  2402FF80   ADDIU V0, ZERO, -128
9D004FA4  00621025   OR V0, V1, V0
9D004FA8  304300FF   ANDI V1, V0, 255
9D004FAC  8FC20030   LW V0, 48(S8)
9D004FB0  A0430006   SB V1, 6(V0)
9D004FB4  24020002   ADDIU V0, ZERO, 2
9D004FB8  0B401451   J 0x9D005144
9D004FBC  00000000   NOP
2955:                                    nsect += ofs / SS(fp->fs);
9D004FC0  8FC20034   LW V0, 52(S8)
9D004FC4  00021242   SRL V0, V0, 9
9D004FC8  8FC30014   LW V1, 20(S8)
9D004FCC  00621021   ADDU V0, V1, V0
9D004FD0  AFC20014   SW V0, 20(S8)
2956:                                }
2957:                            }
2958:                        }
2959:                        if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) { /* Fill sector cache if needed */
9D004FD4  8FC20030   LW V0, 48(S8)
9D004FD8  8C420008   LW V0, 8(V0)
9D004FDC  304201FF   ANDI V0, V0, 511
9D004FE0  10400046   BEQ V0, ZERO, 0x9D0050FC
9D004FE4  00000000   NOP
9D004FE8  8FC20030   LW V0, 48(S8)
9D004FEC  8C430018   LW V1, 24(V0)
9D004FF0  8FC20014   LW V0, 20(S8)
9D004FF4  10620041   BEQ V1, V0, 0x9D0050FC
9D004FF8  00000000   NOP
2960:                #if !_FS_TINY
2961:                #if !_FS_READONLY
2962:                            if (fp->flag & FA__DIRTY) { /* Write-back dirty sector cache */
9D004FFC  8FC20030   LW V0, 48(S8)
9D005000  90420006   LBU V0, 6(V0)
9D005004  30420040   ANDI V0, V0, 64
9D005008  10400021   BEQ V0, ZERO, 0x9D005090
9D00500C  00000000   NOP
2963:                                if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
9D005010  8FC20030   LW V0, 48(S8)
9D005014  8C420000   LW V0, 0(V0)
9D005018  90420001   LBU V0, 1(V0)
9D00501C  00402021   ADDU A0, V0, ZERO
9D005020  8FC20030   LW V0, 48(S8)
9D005024  24430024   ADDIU V1, V0, 36
9D005028  8FC20030   LW V0, 48(S8)
9D00502C  8C420018   LW V0, 24(V0)
9D005030  00602821   ADDU A1, V1, ZERO
9D005034  00403021   ADDU A2, V0, ZERO
9D005038  24070001   ADDIU A3, ZERO, 1
9D00503C  0F40218C   JAL disk_write
9D005040  00000000   NOP
9D005044  1040000B   BEQ V0, ZERO, 0x9D005074
9D005048  00000000   NOP
2964:                                    ABORT(fp->fs, FR_DISK_ERR);
9D00504C  8FC20030   LW V0, 48(S8)
9D005050  90430006   LBU V1, 6(V0)
9D005054  2402FF80   ADDIU V0, ZERO, -128
9D005058  00621025   OR V0, V1, V0
9D00505C  304300FF   ANDI V1, V0, 255
9D005060  8FC20030   LW V0, 48(S8)
9D005064  A0430006   SB V1, 6(V0)
9D005068  24020001   ADDIU V0, ZERO, 1
9D00506C  0B401451   J 0x9D005144
9D005070  00000000   NOP
2965:                                fp->flag &= ~FA__DIRTY;
9D005074  8FC20030   LW V0, 48(S8)
9D005078  90430006   LBU V1, 6(V0)
9D00507C  2402FFBF   ADDIU V0, ZERO, -65
9D005080  00621024   AND V0, V1, V0
9D005084  304300FF   ANDI V1, V0, 255
9D005088  8FC20030   LW V0, 48(S8)
9D00508C  A0430006   SB V1, 6(V0)
2966:                            }
2967:                #endif
2968:                            if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK) /* Fill sector cache */
9D005090  8FC20030   LW V0, 48(S8)
9D005094  8C420000   LW V0, 0(V0)
9D005098  90420001   LBU V0, 1(V0)
9D00509C  00401821   ADDU V1, V0, ZERO
9D0050A0  8FC20030   LW V0, 48(S8)
9D0050A4  24420024   ADDIU V0, V0, 36
9D0050A8  00602021   ADDU A0, V1, ZERO
9D0050AC  00402821   ADDU A1, V0, ZERO
9D0050B0  8FC60014   LW A2, 20(S8)
9D0050B4  24070001   ADDIU A3, ZERO, 1
9D0050B8  0F402130   JAL disk_read
9D0050BC  00000000   NOP
9D0050C0  1040000B   BEQ V0, ZERO, 0x9D0050F0
9D0050C4  00000000   NOP
2969:                                ABORT(fp->fs, FR_DISK_ERR);
9D0050C8  8FC20030   LW V0, 48(S8)
9D0050CC  90430006   LBU V1, 6(V0)
9D0050D0  2402FF80   ADDIU V0, ZERO, -128
9D0050D4  00621025   OR V0, V1, V0
9D0050D8  304300FF   ANDI V1, V0, 255
9D0050DC  8FC20030   LW V0, 48(S8)
9D0050E0  A0430006   SB V1, 6(V0)
9D0050E4  24020001   ADDIU V0, ZERO, 1
9D0050E8  0B401451   J 0x9D005144
9D0050EC  00000000   NOP
2970:                #endif
2971:                            fp->dsect = nsect;
9D0050F0  8FC20030   LW V0, 48(S8)
9D0050F4  8FC30014   LW V1, 20(S8)
9D0050F8  AC430018   SW V1, 24(V0)
2972:                        }
2973:                #if !_FS_READONLY
2974:                        if (fp->fptr > fp->fsize) { /* Set file change flag if the file size is extended */
9D0050FC  8FC20030   LW V0, 48(S8)
9D005100  8C430008   LW V1, 8(V0)
9D005104  8FC20030   LW V0, 48(S8)
9D005108  8C42000C   LW V0, 12(V0)
9D00510C  0043102B   SLTU V0, V0, V1
9D005110  1040000B   BEQ V0, ZERO, 0x9D005140
9D005114  00000000   NOP
2975:                            fp->fsize = fp->fptr;
9D005118  8FC20030   LW V0, 48(S8)
9D00511C  8C430008   LW V1, 8(V0)
9D005120  8FC20030   LW V0, 48(S8)
9D005124  AC43000C   SW V1, 12(V0)
2976:                            fp->flag |= FA__WRITTEN;
9D005128  8FC20030   LW V0, 48(S8)
9D00512C  90420006   LBU V0, 6(V0)
9D005130  34420020   ORI V0, V0, 32
9D005134  304300FF   ANDI V1, V0, 255
9D005138  8FC20030   LW V0, 48(S8)
9D00513C  A0430006   SB V1, 6(V0)
2977:                        }
2978:                #endif
2979:                    }
2980:                
2981:                    LEAVE_FF(fp->fs, res);
9D005140  8FC20018   LW V0, 24(S8)
2982:                }
9D005144  03C0E821   ADDU SP, S8, ZERO
9D005148  8FBF002C   LW RA, 44(SP)
9D00514C  8FBE0028   LW S8, 40(SP)
9D005150  27BD0030   ADDIU SP, SP, 48
9D005154  03E00008   JR RA
9D005158  00000000   NOP
2983:                
2984:                
2985:                
2986:                #if _FS_MINIMIZE <= 1
2987:                /*-----------------------------------------------------------------------*/
2988:                /* Create a Directroy Object                                             */
2989:                
2990:                /*-----------------------------------------------------------------------*/
2991:                
2992:                FRESULT f_opendir(
2993:                        DIR *dj, /* Pointer to directory object to create */
2994:                        const TCHAR *path /* Pointer to the directory path */
2995:                        ) {
9D00515C  27BDFFD8   ADDIU SP, SP, -40
9D005160  AFBF0024   SW RA, 36(SP)
9D005164  AFBE0020   SW S8, 32(SP)
9D005168  03A0F021   ADDU S8, SP, ZERO
9D00516C  AFC40028   SW A0, 40(S8)
9D005170  AFC5002C   SW A1, 44(S8)
2996:                    FRESULT res;
2997:                    DEF_NAMEBUF;
2998:                
2999:                
3000:                    res = chk_mounted(&path, &dj->fs, 0);
9D005174  8FC20028   LW V0, 40(S8)
9D005178  27C3002C   ADDIU V1, S8, 44
9D00517C  00602021   ADDU A0, V1, ZERO
9D005180  00402821   ADDU A1, V0, ZERO
9D005184  00003021   ADDU A2, ZERO, ZERO
9D005188  0F400998   JAL 0x9D002660
9D00518C  00000000   NOP
9D005190  AFC20010   SW V0, 16(S8)
3001:                    if (res == FR_OK) {
9D005194  8FC20010   LW V0, 16(S8)
9D005198  1440004F   BNE V0, ZERO, 0x9D0052D8
9D00519C  00000000   NOP
3002:                        INIT_BUF(*dj);
9D0051A0  8FC20028   LW V0, 40(S8)
9D0051A4  27C30014   ADDIU V1, S8, 20
9D0051A8  AC430018   SW V1, 24(V0)
3003:                        res = follow_path(dj, path); /* Follow the path to the directory */
9D0051AC  8FC2002C   LW V0, 44(S8)
9D0051B0  8FC40028   LW A0, 40(S8)
9D0051B4  00402821   ADDU A1, V0, ZERO
9D0051B8  0F400897   JAL 0x9D00225C
9D0051BC  00000000   NOP
9D0051C0  AFC20010   SW V0, 16(S8)
3004:                        FREE_BUF();
3005:                        if (res == FR_OK) { /* Follow completed */
9D0051C4  8FC20010   LW V0, 16(S8)
9D0051C8  1440003D   BNE V0, ZERO, 0x9D0052C0
9D0051CC  00000000   NOP
3006:                            if (dj->dir) { /* It is not the root dir */
9D0051D0  8FC20028   LW V0, 40(S8)
9D0051D4  8C420014   LW V0, 20(V0)
9D0051D8  1040002C   BEQ V0, ZERO, 0x9D00528C
9D0051DC  00000000   NOP
3007:                                if (dj->dir[DIR_Attr] & AM_DIR) { /* The object is a directory */
9D0051E0  8FC20028   LW V0, 40(S8)
9D0051E4  8C420014   LW V0, 20(V0)
9D0051E8  2442000B   ADDIU V0, V0, 11
9D0051EC  90420000   LBU V0, 0(V0)
9D0051F0  30420010   ANDI V0, V0, 16
9D0051F4  10400023   BEQ V0, ZERO, 0x9D005284
9D0051F8  00000000   NOP
3008:                                    dj->sclust = LD_CLUST(dj->dir);
9D0051FC  8FC20028   LW V0, 40(S8)
9D005200  8C420014   LW V0, 20(V0)
9D005204  24420015   ADDIU V0, V0, 21
9D005208  90420000   LBU V0, 0(V0)
9D00520C  00021200   SLL V0, V0, 8
9D005210  7C021E20   SEH V1, V0
9D005214  8FC20028   LW V0, 40(S8)
9D005218  8C420014   LW V0, 20(V0)
9D00521C  24420014   ADDIU V0, V0, 20
9D005220  90420000   LBU V0, 0(V0)
9D005224  7C021620   SEH V0, V0
9D005228  00621025   OR V0, V1, V0
9D00522C  7C021620   SEH V0, V0
9D005230  3042FFFF   ANDI V0, V0, -1
9D005234  00021C00   SLL V1, V0, 16
9D005238  8FC20028   LW V0, 40(S8)
9D00523C  8C420014   LW V0, 20(V0)
9D005240  2442001B   ADDIU V0, V0, 27
9D005244  90420000   LBU V0, 0(V0)
9D005248  00021200   SLL V0, V0, 8
9D00524C  7C022620   SEH A0, V0
9D005250  8FC20028   LW V0, 40(S8)
9D005254  8C420014   LW V0, 20(V0)
9D005258  2442001A   ADDIU V0, V0, 26
9D00525C  90420000   LBU V0, 0(V0)
9D005260  7C021620   SEH V0, V0
9D005264  00821025   OR V0, A0, V0
9D005268  7C021620   SEH V0, V0
9D00526C  3042FFFF   ANDI V0, V0, -1
9D005270  00621825   OR V1, V1, V0
9D005274  8FC20028   LW V0, 40(S8)
9D005278  AC430008   SW V1, 8(V0)
9D00527C  0B4014A3   J 0x9D00528C
9D005280  00000000   NOP
3009:                                } else { /* The object is not a directory */
3010:                                    res = FR_NO_PATH;
9D005284  24020005   ADDIU V0, ZERO, 5
9D005288  AFC20010   SW V0, 16(S8)
3011:                                }
3012:                            }
3013:                            if (res == FR_OK) {
9D00528C  8FC20010   LW V0, 16(S8)
9D005290  1440000B   BNE V0, ZERO, 0x9D0052C0
9D005294  00000000   NOP
3014:                                dj->id = dj->fs->id;
9D005298  8FC20028   LW V0, 40(S8)
9D00529C  8C420000   LW V0, 0(V0)
9D0052A0  94430006   LHU V1, 6(V0)
9D0052A4  8FC20028   LW V0, 40(S8)
9D0052A8  A4430004   SH V1, 4(V0)
3015:                                res = dir_sdi(dj, 0); /* Rewind dir */
9D0052AC  8FC40028   LW A0, 40(S8)
9D0052B0  00002821   ADDU A1, ZERO, ZERO
9D0052B4  0F40045E   JAL 0x9D001178
9D0052B8  00000000   NOP
9D0052BC  AFC20010   SW V0, 16(S8)
3016:                            }
3017:                        }
3018:                        if (res == FR_NO_FILE) res = FR_NO_PATH;
9D0052C0  8FC30010   LW V1, 16(S8)
9D0052C4  24020004   ADDIU V0, ZERO, 4
9D0052C8  14620003   BNE V1, V0, 0x9D0052D8
9D0052CC  00000000   NOP
9D0052D0  24020005   ADDIU V0, ZERO, 5
9D0052D4  AFC20010   SW V0, 16(S8)
3019:                    }
3020:                
3021:                    LEAVE_FF(dj->fs, res);
9D0052D8  8FC20010   LW V0, 16(S8)
3022:                }
9D0052DC  03C0E821   ADDU SP, S8, ZERO
9D0052E0  8FBF0024   LW RA, 36(SP)
9D0052E4  8FBE0020   LW S8, 32(SP)
9D0052E8  27BD0028   ADDIU SP, SP, 40
9D0052EC  03E00008   JR RA
9D0052F0  00000000   NOP
3023:                
3024:                
3025:                
3026:                
3027:                /*-----------------------------------------------------------------------*/
3028:                /* Read Directory Entry in Sequense                                      */
3029:                
3030:                /*-----------------------------------------------------------------------*/
3031:                
3032:                FRESULT f_readdir(
3033:                        DIR *dj, /* Pointer to the open directory object */
3034:                        FILINFO *fno /* Pointer to file information to return */
3035:                        ) {
9D0052F4  27BDFFD8   ADDIU SP, SP, -40
9D0052F8  AFBF0024   SW RA, 36(SP)
9D0052FC  AFBE0020   SW S8, 32(SP)
9D005300  03A0F021   ADDU S8, SP, ZERO
9D005304  AFC40028   SW A0, 40(S8)
9D005308  AFC5002C   SW A1, 44(S8)
3036:                    FRESULT res;
3037:                    DEF_NAMEBUF;
3038:                
3039:                
3040:                    res = validate(dj->fs, dj->id); /* Check validity of the object */
9D00530C  8FC20028   LW V0, 40(S8)
9D005310  8C430000   LW V1, 0(V0)
9D005314  8FC20028   LW V0, 40(S8)
9D005318  94420004   LHU V0, 4(V0)
9D00531C  00602021   ADDU A0, V1, ZERO
9D005320  00402821   ADDU A1, V0, ZERO
9D005324  0F400C25   JAL 0x9D003094
9D005328  00000000   NOP
9D00532C  AFC20010   SW V0, 16(S8)
3041:                    if (res == FR_OK) {
9D005330  8FC20010   LW V0, 16(S8)
9D005334  1440002C   BNE V0, ZERO, 0x9D0053E8
9D005338  00000000   NOP
3042:                        if (!fno) {
9D00533C  8FC2002C   LW V0, 44(S8)
9D005340  14400008   BNE V0, ZERO, 0x9D005364
9D005344  00000000   NOP
3043:                            res = dir_sdi(dj, 0); /* Rewind the directory object */
9D005348  8FC40028   LW A0, 40(S8)
9D00534C  00002821   ADDU A1, ZERO, ZERO
9D005350  0F40045E   JAL 0x9D001178
9D005354  00000000   NOP
9D005358  AFC20010   SW V0, 16(S8)
9D00535C  0B4014FA   J 0x9D0053E8
9D005360  00000000   NOP
3044:                        } else {
3045:                            INIT_BUF(*dj);
9D005364  8FC20028   LW V0, 40(S8)
9D005368  27C30014   ADDIU V1, S8, 20
9D00536C  AC430018   SW V1, 24(V0)
3046:                            res = dir_read(dj); /* Read an directory item */
9D005370  8FC40028   LW A0, 40(S8)
9D005374  0F400618   JAL 0x9D001860
9D005378  00000000   NOP
9D00537C  AFC20010   SW V0, 16(S8)
3047:                            if (res == FR_NO_FILE) { /* Reached end of dir */
9D005380  8FC30010   LW V1, 16(S8)
9D005384  24020004   ADDIU V0, ZERO, 4
9D005388  14620004   BNE V1, V0, 0x9D00539C
9D00538C  00000000   NOP
3048:                                dj->sect = 0;
9D005390  8FC20028   LW V0, 40(S8)
9D005394  AC400010   SW ZERO, 16(V0)
3049:                                res = FR_OK;
9D005398  AFC00010   SW ZERO, 16(S8)
3050:                            }
3051:                            if (res == FR_OK) { /* A valid entry is found */
9D00539C  8FC20010   LW V0, 16(S8)
9D0053A0  14400011   BNE V0, ZERO, 0x9D0053E8
9D0053A4  00000000   NOP
3052:                                get_fileinfo(dj, fno); /* Get the object information */
9D0053A8  8FC40028   LW A0, 40(S8)
9D0053AC  8FC5002C   LW A1, 44(S8)
9D0053B0  0F4007FD   JAL 0x9D001FF4
9D0053B4  00000000   NOP
3053:                                res = dir_next(dj, 0); /* Increment index for next */
9D0053B8  8FC40028   LW A0, 40(S8)
9D0053BC  00002821   ADDU A1, ZERO, ZERO
9D0053C0  0F4004ED   JAL 0x9D0013B4
9D0053C4  00000000   NOP
9D0053C8  AFC20010   SW V0, 16(S8)
3054:                                if (res == FR_NO_FILE) {
9D0053CC  8FC30010   LW V1, 16(S8)
9D0053D0  24020004   ADDIU V0, ZERO, 4
9D0053D4  14620004   BNE V1, V0, 0x9D0053E8
9D0053D8  00000000   NOP
3055:                                    dj->sect = 0;
9D0053DC  8FC20028   LW V0, 40(S8)
9D0053E0  AC400010   SW ZERO, 16(V0)
3056:                                    res = FR_OK;
9D0053E4  AFC00010   SW ZERO, 16(S8)
3057:                                }
3058:                            }
3059:                            FREE_BUF();
3060:                        }
3061:                    }
3062:                
3063:                    LEAVE_FF(dj->fs, res);
9D0053E8  8FC20010   LW V0, 16(S8)
3064:                }
9D0053EC  03C0E821   ADDU SP, S8, ZERO
9D0053F0  8FBF0024   LW RA, 36(SP)
9D0053F4  8FBE0020   LW S8, 32(SP)
9D0053F8  27BD0028   ADDIU SP, SP, 40
9D0053FC  03E00008   JR RA
9D005400  00000000   NOP
3065:                
3066:                
3067:                
3068:                #if _FS_MINIMIZE == 0
3069:                /*-----------------------------------------------------------------------*/
3070:                /* Get File Status                                                       */
3071:                
3072:                /*-----------------------------------------------------------------------*/
3073:                
3074:                FRESULT f_stat(
3075:                        const TCHAR *path, /* Pointer to the file path */
3076:                        FILINFO *fno /* Pointer to file information to return */
3077:                        ) {
9D005404  27BDFFB8   ADDIU SP, SP, -72
9D005408  AFBF0044   SW RA, 68(SP)
9D00540C  AFBE0040   SW S8, 64(SP)
9D005410  03A0F021   ADDU S8, SP, ZERO
9D005414  AFC40048   SW A0, 72(S8)
9D005418  AFC5004C   SW A1, 76(S8)
3078:                    FRESULT res;
3079:                    DIR dj;
3080:                    DEF_NAMEBUF;
3081:                
3082:                
3083:                    res = chk_mounted(&path, &dj.fs, 0);
9D00541C  27C20014   ADDIU V0, S8, 20
9D005420  27C40048   ADDIU A0, S8, 72
9D005424  00402821   ADDU A1, V0, ZERO
9D005428  00003021   ADDU A2, ZERO, ZERO
9D00542C  0F400998   JAL 0x9D002660
9D005430  00000000   NOP
9D005434  AFC20010   SW V0, 16(S8)
3084:                    if (res == FR_OK) {
9D005438  8FC20010   LW V0, 16(S8)
9D00543C  14400019   BNE V0, ZERO, 0x9D0054A4
9D005440  00000000   NOP
3085:                        INIT_BUF(dj);
9D005444  27C20030   ADDIU V0, S8, 48
9D005448  AFC2002C   SW V0, 44(S8)
3086:                        res = follow_path(&dj, path); /* Follow the file path */
9D00544C  8FC20048   LW V0, 72(S8)
9D005450  27C30014   ADDIU V1, S8, 20
9D005454  00602021   ADDU A0, V1, ZERO
9D005458  00402821   ADDU A1, V0, ZERO
9D00545C  0F400897   JAL 0x9D00225C
9D005460  00000000   NOP
9D005464  AFC20010   SW V0, 16(S8)
3087:                        if (res == FR_OK) { /* Follow completed */
9D005468  8FC20010   LW V0, 16(S8)
9D00546C  1440000D   BNE V0, ZERO, 0x9D0054A4
9D005470  00000000   NOP
3088:                            if (dj.dir) /* Found an object */
9D005474  8FC20028   LW V0, 40(S8)
9D005478  10400008   BEQ V0, ZERO, 0x9D00549C
9D00547C  00000000   NOP
3089:                                get_fileinfo(&dj, fno);
9D005480  27C20014   ADDIU V0, S8, 20
9D005484  00402021   ADDU A0, V0, ZERO
9D005488  8FC5004C   LW A1, 76(S8)
9D00548C  0F4007FD   JAL 0x9D001FF4
9D005490  00000000   NOP
9D005494  0B401529   J 0x9D0054A4
9D005498  00000000   NOP
3090:                            else /* It is root dir */
3091:                                res = FR_INVALID_NAME;
9D00549C  24020006   ADDIU V0, ZERO, 6
9D0054A0  AFC20010   SW V0, 16(S8)
3092:                        }
3093:                        FREE_BUF();
3094:                    }
3095:                
3096:                    LEAVE_FF(dj.fs, res);
9D0054A4  8FC20010   LW V0, 16(S8)
3097:                }
9D0054A8  03C0E821   ADDU SP, S8, ZERO
9D0054AC  8FBF0044   LW RA, 68(SP)
9D0054B0  8FBE0040   LW S8, 64(SP)
9D0054B4  27BD0048   ADDIU SP, SP, 72
9D0054B8  03E00008   JR RA
9D0054BC  00000000   NOP
3098:                
3099:                
3100:                
3101:                #if !_FS_READONLY
3102:                /*-----------------------------------------------------------------------*/
3103:                /* Get Number of Free Clusters                                           */
3104:                
3105:                /*-----------------------------------------------------------------------*/
3106:                
3107:                FRESULT f_getfree(
3108:                        const TCHAR *path, /* Pointer to the logical drive number (root dir) */
3109:                        DWORD *nclst, /* Pointer to the variable to return number of free clusters */
3110:                        FATFS **fatfs /* Pointer to pointer to corresponding file system object to return */
3111:                        ) {
9D0054C0  27BDFFC8   ADDIU SP, SP, -56
9D0054C4  AFBF0034   SW RA, 52(SP)
9D0054C8  AFBE0030   SW S8, 48(SP)
9D0054CC  03A0F021   ADDU S8, SP, ZERO
9D0054D0  AFC40038   SW A0, 56(S8)
9D0054D4  AFC5003C   SW A1, 60(S8)
9D0054D8  AFC60040   SW A2, 64(S8)
3112:                    FRESULT res;
3113:                    DWORD n, clst, sect, stat;
3114:                    UINT i;
3115:                    BYTE fat, *p;
3116:                
3117:                
3118:                    /* Get drive number */
3119:                    res = chk_mounted(&path, fatfs, 0);
9D0054DC  27C40038   ADDIU A0, S8, 56
9D0054E0  8FC50040   LW A1, 64(S8)
9D0054E4  00003021   ADDU A2, ZERO, ZERO
9D0054E8  0F400998   JAL 0x9D002660
9D0054EC  00000000   NOP
9D0054F0  AFC20010   SW V0, 16(S8)
3120:                    if (res == FR_OK) {
9D0054F4  8FC20010   LW V0, 16(S8)
9D0054F8  144000B8   BNE V0, ZERO, 0x9D0057DC
9D0054FC  00000000   NOP
3121:                        /* If free_clust is valid, return it without full cluster scan */
3122:                        if ((*fatfs)->free_clust <= (*fatfs)->n_fatent - 2) {
9D005500  8FC20040   LW V0, 64(S8)
9D005504  8C420000   LW V0, 0(V0)
9D005508  8C430010   LW V1, 16(V0)
9D00550C  8FC20040   LW V0, 64(S8)
9D005510  8C420000   LW V0, 0(V0)
9D005514  8C42001C   LW V0, 28(V0)
9D005518  2442FFFE   ADDIU V0, V0, -2
9D00551C  0043102B   SLTU V0, V0, V1
9D005520  14400008   BNE V0, ZERO, 0x9D005544
9D005524  00000000   NOP
3123:                            *nclst = (*fatfs)->free_clust;
9D005528  8FC20040   LW V0, 64(S8)
9D00552C  8C420000   LW V0, 0(V0)
9D005530  8C430010   LW V1, 16(V0)
9D005534  8FC2003C   LW V0, 60(S8)
9D005538  AC430000   SW V1, 0(V0)
9D00553C  0B4015F7   J 0x9D0057DC
9D005540  00000000   NOP
3124:                        } else {
3125:                            /* Get number of free clusters */
3126:                            fat = (*fatfs)->fs_type;
9D005544  8FC20040   LW V0, 64(S8)
9D005548  8C420000   LW V0, 0(V0)
9D00554C  90420000   LBU V0, 0(V0)
9D005550  A3C20028   SB V0, 40(S8)
3127:                            n = 0;
9D005554  AFC00014   SW ZERO, 20(S8)
3128:                            if (fat == FS_FAT12) {
9D005558  93C30028   LBU V1, 40(S8)
9D00555C  24020001   ADDIU V0, ZERO, 1
9D005560  1462002D   BNE V1, V0, 0x9D005618
9D005564  00000000   NOP
3129:                                clst = 2;
9D005568  24020002   ADDIU V0, ZERO, 2
9D00556C  AFC20018   SW V0, 24(S8)
3130:                                do {
3131:                                    stat = get_fat(*fatfs, clst);
9D005570  8FC20040   LW V0, 64(S8)
9D005574  8C420000   LW V0, 0(V0)
9D005578  00402021   ADDU A0, V0, ZERO
9D00557C  8FC50018   LW A1, 24(S8)
9D005580  0F4001B4   JAL get_fat
9D005584  00000000   NOP
9D005588  AFC2002C   SW V0, 44(S8)
3132:                                    if (stat == 0xFFFFFFFF) {
9D00558C  8FC3002C   LW V1, 44(S8)
9D005590  2402FFFF   ADDIU V0, ZERO, -1
9D005594  14620005   BNE V1, V0, 0x9D0055AC
9D005598  00000000   NOP
3133:                                        res = FR_DISK_ERR;
9D00559C  24020001   ADDIU V0, ZERO, 1
9D0055A0  AFC20010   SW V0, 16(S8)
3134:                                        break;
9D0055A4  0B4015E8   J 0x9D0057A0
9D0055A8  00000000   NOP
3135:                                    }
3136:                                    if (stat == 1) {
9D0055AC  8FC3002C   LW V1, 44(S8)
9D0055B0  24020001   ADDIU V0, ZERO, 1
9D0055B4  14620006   BNE V1, V0, 0x9D0055D0
9D0055B8  00000000   NOP
3137:                                        res = FR_INT_ERR;
9D0055BC  24020002   ADDIU V0, ZERO, 2
9D0055C0  AFC20010   SW V0, 16(S8)
3138:                                        break;
9D0055C4  00000000   NOP
9D0055C8  0B4015E8   J 0x9D0057A0
9D0055CC  00000000   NOP
3139:                                    }
3140:                                    if (stat == 0) n++;
9D0055D0  8FC2002C   LW V0, 44(S8)
9D0055D4  14400004   BNE V0, ZERO, 0x9D0055E8
9D0055D8  00000000   NOP
9D0055DC  8FC20014   LW V0, 20(S8)
9D0055E0  24420001   ADDIU V0, V0, 1
9D0055E4  AFC20014   SW V0, 20(S8)
3141:                                } while (++clst < (*fatfs)->n_fatent);
9D0055E8  8FC20018   LW V0, 24(S8)
9D0055EC  24420001   ADDIU V0, V0, 1
9D0055F0  AFC20018   SW V0, 24(S8)
9D0055F4  8FC20040   LW V0, 64(S8)
9D0055F8  8C420000   LW V0, 0(V0)
9D0055FC  8C42001C   LW V0, 28(V0)
9D005600  8FC30018   LW V1, 24(S8)
9D005604  0062102B   SLTU V0, V1, V0
9D005608  1440FFD9   BNE V0, ZERO, 0x9D005570
9D00560C  00000000   NOP
9D005610  0B4015E8   J 0x9D0057A0
9D005614  00000000   NOP
3142:                            } else {
3143:                                clst = (*fatfs)->n_fatent;
9D005618  8FC20040   LW V0, 64(S8)
9D00561C  8C420000   LW V0, 0(V0)
9D005620  8C42001C   LW V0, 28(V0)
9D005624  AFC20018   SW V0, 24(S8)
3144:                                sect = (*fatfs)->fatbase;
9D005628  8FC20040   LW V0, 64(S8)
9D00562C  8C420000   LW V0, 0(V0)
9D005630  8C420024   LW V0, 36(V0)
9D005634  AFC2001C   SW V0, 28(S8)
3145:                                i = 0;
9D005638  AFC00020   SW ZERO, 32(S8)
3146:                                p = 0;
9D00563C  AFC00024   SW ZERO, 36(S8)
3147:                                do {
3148:                                    if (!i) {
9D005640  8FC20020   LW V0, 32(S8)
9D005644  14400015   BNE V0, ZERO, 0x9D00569C
9D005648  00000000   NOP
3149:                                        res = move_window(*fatfs, sect++);
9D00564C  8FC20040   LW V0, 64(S8)
9D005650  8C430000   LW V1, 0(V0)
9D005654  8FC2001C   LW V0, 28(S8)
9D005658  8FC4001C   LW A0, 28(S8)
9D00565C  24840001   ADDIU A0, A0, 1
9D005660  AFC4001C   SW A0, 28(S8)
9D005664  00602021   ADDU A0, V1, ZERO
9D005668  00402821   ADDU A1, V0, ZERO
9D00566C  0F400090   JAL 0x9D000240
9D005670  00000000   NOP
9D005674  AFC20010   SW V0, 16(S8)
3150:                                        if (res != FR_OK) break;
9D005678  8FC20010   LW V0, 16(S8)
9D00567C  14400047   BNE V0, ZERO, 0x9D00579C
9D005680  00000000   NOP
9D00579C  00000000   NOP
3151:                                        p = (*fatfs)->win;
9D005684  8FC20040   LW V0, 64(S8)
9D005688  8C420000   LW V0, 0(V0)
9D00568C  24420034   ADDIU V0, V0, 52
9D005690  AFC20024   SW V0, 36(S8)
3152:                                        i = SS(*fatfs);
9D005694  24020200   ADDIU V0, ZERO, 512
9D005698  AFC20020   SW V0, 32(S8)
3153:                                    }
3154:                                    if (fat == FS_FAT16) {
9D00569C  93C30028   LBU V1, 40(S8)
9D0056A0  24020002   ADDIU V0, ZERO, 2
9D0056A4  14620018   BNE V1, V0, 0x9D005708
9D0056A8  00000000   NOP
3155:                                        if (LD_WORD(p) == 0) n++;
9D0056AC  8FC20024   LW V0, 36(S8)
9D0056B0  24420001   ADDIU V0, V0, 1
9D0056B4  90420000   LBU V0, 0(V0)
9D0056B8  00021200   SLL V0, V0, 8
9D0056BC  7C021E20   SEH V1, V0
9D0056C0  8FC20024   LW V0, 36(S8)
9D0056C4  90420000   LBU V0, 0(V0)
9D0056C8  7C021620   SEH V0, V0
9D0056CC  00621025   OR V0, V1, V0
9D0056D0  7C021620   SEH V0, V0
9D0056D4  14400004   BNE V0, ZERO, 0x9D0056E8
9D0056D8  00000000   NOP
9D0056DC  8FC20014   LW V0, 20(S8)
9D0056E0  24420001   ADDIU V0, V0, 1
9D0056E4  AFC20014   SW V0, 20(S8)
3156:                                        p += 2;
9D0056E8  8FC20024   LW V0, 36(S8)
9D0056EC  24420002   ADDIU V0, V0, 2
9D0056F0  AFC20024   SW V0, 36(S8)
3157:                                        i -= 2;
9D0056F4  8FC20020   LW V0, 32(S8)
9D0056F8  2442FFFE   ADDIU V0, V0, -2
9D0056FC  AFC20020   SW V0, 32(S8)
9D005700  0B4015DF   J 0x9D00577C
9D005704  00000000   NOP
3158:                                    } else {
3159:                                        if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
9D005708  8FC20024   LW V0, 36(S8)
9D00570C  24420003   ADDIU V0, V0, 3
9D005710  90420000   LBU V0, 0(V0)
9D005714  00021E00   SLL V1, V0, 24
9D005718  8FC20024   LW V0, 36(S8)
9D00571C  24420002   ADDIU V0, V0, 2
9D005720  90420000   LBU V0, 0(V0)
9D005724  00021400   SLL V0, V0, 16
9D005728  00621825   OR V1, V1, V0
9D00572C  8FC20024   LW V0, 36(S8)
9D005730  24420001   ADDIU V0, V0, 1
9D005734  90420000   LBU V0, 0(V0)
9D005738  00021200   SLL V0, V0, 8
9D00573C  00621825   OR V1, V1, V0
9D005740  8FC20024   LW V0, 36(S8)
9D005744  90420000   LBU V0, 0(V0)
9D005748  00621025   OR V0, V1, V0
9D00574C  7C42D800   EXT V0, V0, 0, 28
9D005750  14400004   BNE V0, ZERO, 0x9D005764
9D005754  00000000   NOP
9D005758  8FC20014   LW V0, 20(S8)
9D00575C  24420001   ADDIU V0, V0, 1
9D005760  AFC20014   SW V0, 20(S8)
3160:                                        p += 4;
9D005764  8FC20024   LW V0, 36(S8)
9D005768  24420004   ADDIU V0, V0, 4
9D00576C  AFC20024   SW V0, 36(S8)
3161:                                        i -= 4;
9D005770  8FC20020   LW V0, 32(S8)
9D005774  2442FFFC   ADDIU V0, V0, -4
9D005778  AFC20020   SW V0, 32(S8)
3162:                                    }
3163:                                } while (--clst);
9D00577C  8FC20018   LW V0, 24(S8)
9D005780  2442FFFF   ADDIU V0, V0, -1
9D005784  AFC20018   SW V0, 24(S8)
9D005788  8FC20018   LW V0, 24(S8)
9D00578C  1440FFAC   BNE V0, ZERO, 0x9D005640
9D005790  00000000   NOP
9D005794  0B4015E8   J 0x9D0057A0
9D005798  00000000   NOP
3164:                            }
3165:                            (*fatfs)->free_clust = n;
9D0057A0  8FC20040   LW V0, 64(S8)
9D0057A4  8C420000   LW V0, 0(V0)
9D0057A8  8FC30014   LW V1, 20(S8)
9D0057AC  AC430010   SW V1, 16(V0)
3166:                            if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
9D0057B0  93C30028   LBU V1, 40(S8)
9D0057B4  24020003   ADDIU V0, ZERO, 3
9D0057B8  14620005   BNE V1, V0, 0x9D0057D0
9D0057BC  00000000   NOP
9D0057C0  8FC20040   LW V0, 64(S8)
9D0057C4  8C420000   LW V0, 0(V0)
9D0057C8  24030001   ADDIU V1, ZERO, 1
9D0057CC  A0430005   SB V1, 5(V0)
3167:                            *nclst = n;
9D0057D0  8FC2003C   LW V0, 60(S8)
9D0057D4  8FC30014   LW V1, 20(S8)
9D0057D8  AC430000   SW V1, 0(V0)
3168:                        }
3169:                    }
3170:                    LEAVE_FF(*fatfs, res);
9D0057DC  8FC20010   LW V0, 16(S8)
3171:                }
9D0057E0  03C0E821   ADDU SP, S8, ZERO
9D0057E4  8FBF0034   LW RA, 52(SP)
9D0057E8  8FBE0030   LW S8, 48(SP)
9D0057EC  27BD0038   ADDIU SP, SP, 56
9D0057F0  03E00008   JR RA
9D0057F4  00000000   NOP
3172:                
3173:                
3174:                
3175:                
3176:                /*-----------------------------------------------------------------------*/
3177:                /* Truncate File                                                         */
3178:                
3179:                /*-----------------------------------------------------------------------*/
3180:                
3181:                FRESULT f_truncate(
3182:                        FIL *fp /* Pointer to the file object */
3183:                        ) {
9D0057F8  27BDFFE0   ADDIU SP, SP, -32
9D0057FC  AFBF001C   SW RA, 28(SP)
9D005800  AFBE0018   SW S8, 24(SP)
9D005804  03A0F021   ADDU S8, SP, ZERO
9D005808  AFC40020   SW A0, 32(S8)
3184:                    FRESULT res;
3185:                    DWORD ncl;
3186:                
3187:                
3188:                    res = validate(fp->fs, fp->id); /* Check validity of the object */
9D00580C  8FC20020   LW V0, 32(S8)
9D005810  8C430000   LW V1, 0(V0)
9D005814  8FC20020   LW V0, 32(S8)
9D005818  94420004   LHU V0, 4(V0)
9D00581C  00602021   ADDU A0, V1, ZERO
9D005820  00402821   ADDU A1, V0, ZERO
9D005824  0F400C25   JAL 0x9D003094
9D005828  00000000   NOP
9D00582C  AFC20010   SW V0, 16(S8)
3189:                    if (res == FR_OK) {
9D005830  8FC20010   LW V0, 16(S8)
9D005834  14400011   BNE V0, ZERO, 0x9D00587C
9D005838  00000000   NOP
3190:                        if (fp->flag & FA__ERROR) { /* Check abort flag */
9D00583C  8FC20020   LW V0, 32(S8)
9D005840  90420006   LBU V0, 6(V0)
9D005844  7C021420   SEB V0, V0
9D005848  04410005   BGEZ V0, 0x9D005860
9D00584C  00000000   NOP
3191:                            res = FR_INT_ERR;
9D005850  24020002   ADDIU V0, ZERO, 2
9D005854  AFC20010   SW V0, 16(S8)
9D005858  0B40161F   J 0x9D00587C
9D00585C  00000000   NOP
3192:                        } else {
3193:                            if (!(fp->flag & FA_WRITE)) /* Check access mode */
9D005860  8FC20020   LW V0, 32(S8)
9D005864  90420006   LBU V0, 6(V0)
9D005868  30420002   ANDI V0, V0, 2
9D00586C  14400003   BNE V0, ZERO, 0x9D00587C
9D005870  00000000   NOP
3194:                                res = FR_DENIED;
9D005874  24020007   ADDIU V0, ZERO, 7
9D005878  AFC20010   SW V0, 16(S8)
3195:                        }
3196:                    }
3197:                    if (res == FR_OK) {
9D00587C  8FC20010   LW V0, 16(S8)
9D005880  14400062   BNE V0, ZERO, 0x9D005A0C
9D005884  00000000   NOP
3198:                        if (fp->fsize > fp->fptr) {
9D005888  8FC20020   LW V0, 32(S8)
9D00588C  8C43000C   LW V1, 12(V0)
9D005890  8FC20020   LW V0, 32(S8)
9D005894  8C420008   LW V0, 8(V0)
9D005898  0043102B   SLTU V0, V0, V1
9D00589C  10400051   BEQ V0, ZERO, 0x9D0059E4
9D0058A0  00000000   NOP
3199:                            fp->fsize = fp->fptr; /* Set file size to current R/W point */
9D0058A4  8FC20020   LW V0, 32(S8)
9D0058A8  8C430008   LW V1, 8(V0)
9D0058AC  8FC20020   LW V0, 32(S8)
9D0058B0  AC43000C   SW V1, 12(V0)
3200:                            fp->flag |= FA__WRITTEN;
9D0058B4  8FC20020   LW V0, 32(S8)
9D0058B8  90420006   LBU V0, 6(V0)
9D0058BC  34420020   ORI V0, V0, 32
9D0058C0  304300FF   ANDI V1, V0, 255
9D0058C4  8FC20020   LW V0, 32(S8)
9D0058C8  A0430006   SB V1, 6(V0)
3201:                            if (fp->fptr == 0) { /* When set file size to zero, remove entire cluster chain */
9D0058CC  8FC20020   LW V0, 32(S8)
9D0058D0  8C420008   LW V0, 8(V0)
9D0058D4  1440000E   BNE V0, ZERO, 0x9D005910
9D0058D8  00000000   NOP
3202:                                res = remove_chain(fp->fs, fp->sclust);
9D0058DC  8FC20020   LW V0, 32(S8)
9D0058E0  8C430000   LW V1, 0(V0)
9D0058E4  8FC20020   LW V0, 32(S8)
9D0058E8  8C420010   LW V0, 16(V0)
9D0058EC  00602021   ADDU A0, V1, ZERO
9D0058F0  00402821   ADDU A1, V0, ZERO
9D0058F4  0F400368   JAL 0x9D000DA0
9D0058F8  00000000   NOP
9D0058FC  AFC20010   SW V0, 16(S8)
3203:                                fp->sclust = 0;
9D005900  8FC20020   LW V0, 32(S8)
9D005904  AC400010   SW ZERO, 16(V0)
9D005908  0B401679   J 0x9D0059E4
9D00590C  00000000   NOP
3204:                            } else { /* When truncate a part of the file, remove remaining clusters */
3205:                                ncl = get_fat(fp->fs, fp->clust);
9D005910  8FC20020   LW V0, 32(S8)
9D005914  8C430000   LW V1, 0(V0)
9D005918  8FC20020   LW V0, 32(S8)
9D00591C  8C420014   LW V0, 20(V0)
9D005920  00602021   ADDU A0, V1, ZERO
9D005924  00402821   ADDU A1, V0, ZERO
9D005928  0F4001B4   JAL get_fat
9D00592C  00000000   NOP
9D005930  AFC20014   SW V0, 20(S8)
3206:                                res = FR_OK;
9D005934  AFC00010   SW ZERO, 16(S8)
3207:                                if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
9D005938  8FC30014   LW V1, 20(S8)
9D00593C  2402FFFF   ADDIU V0, ZERO, -1
9D005940  14620003   BNE V1, V0, 0x9D005950
9D005944  00000000   NOP
9D005948  24020001   ADDIU V0, ZERO, 1
9D00594C  AFC20010   SW V0, 16(S8)
3208:                                if (ncl == 1) res = FR_INT_ERR;
9D005950  8FC30014   LW V1, 20(S8)
9D005954  24020001   ADDIU V0, ZERO, 1
9D005958  14620003   BNE V1, V0, 0x9D005968
9D00595C  00000000   NOP
9D005960  24020002   ADDIU V0, ZERO, 2
9D005964  AFC20010   SW V0, 16(S8)
3209:                                if (res == FR_OK && ncl < fp->fs->n_fatent) {
9D005968  8FC20010   LW V0, 16(S8)
9D00596C  1440001D   BNE V0, ZERO, 0x9D0059E4
9D005970  00000000   NOP
9D005974  8FC20020   LW V0, 32(S8)
9D005978  8C420000   LW V0, 0(V0)
9D00597C  8C43001C   LW V1, 28(V0)
9D005980  8FC20014   LW V0, 20(S8)
9D005984  0043102B   SLTU V0, V0, V1
9D005988  10400016   BEQ V0, ZERO, 0x9D0059E4
9D00598C  00000000   NOP
3210:                                    res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
9D005990  8FC20020   LW V0, 32(S8)
9D005994  8C430000   LW V1, 0(V0)
9D005998  8FC20020   LW V0, 32(S8)
9D00599C  8C420014   LW V0, 20(V0)
9D0059A0  00602021   ADDU A0, V1, ZERO
9D0059A4  00402821   ADDU A1, V0, ZERO
9D0059A8  3C020FFF   LUI V0, 4095
9D0059AC  3446FFFF   ORI A2, V0, -1
9D0059B0  0F400264   JAL put_fat
9D0059B4  00000000   NOP
9D0059B8  AFC20010   SW V0, 16(S8)
3211:                                    if (res == FR_OK) res = remove_chain(fp->fs, ncl);
9D0059BC  8FC20010   LW V0, 16(S8)
9D0059C0  14400008   BNE V0, ZERO, 0x9D0059E4
9D0059C4  00000000   NOP
9D0059C8  8FC20020   LW V0, 32(S8)
9D0059CC  8C420000   LW V0, 0(V0)
9D0059D0  00402021   ADDU A0, V0, ZERO
9D0059D4  8FC50014   LW A1, 20(S8)
9D0059D8  0F400368   JAL 0x9D000DA0
9D0059DC  00000000   NOP
9D0059E0  AFC20010   SW V0, 16(S8)
3212:                                }
3213:                            }
3214:                        }
3215:                        if (res != FR_OK) fp->flag |= FA__ERROR;
9D0059E4  8FC20010   LW V0, 16(S8)
9D0059E8  10400008   BEQ V0, ZERO, 0x9D005A0C
9D0059EC  00000000   NOP
9D0059F0  8FC20020   LW V0, 32(S8)
9D0059F4  90430006   LBU V1, 6(V0)
9D0059F8  2402FF80   ADDIU V0, ZERO, -128
9D0059FC  00621025   OR V0, V1, V0
9D005A00  304300FF   ANDI V1, V0, 255
9D005A04  8FC20020   LW V0, 32(S8)
9D005A08  A0430006   SB V1, 6(V0)
3216:                    }
3217:                
3218:                    LEAVE_FF(fp->fs, res);
9D005A0C  8FC20010   LW V0, 16(S8)
3219:                }
9D005A10  03C0E821   ADDU SP, S8, ZERO
9D005A14  8FBF001C   LW RA, 28(SP)
9D005A18  8FBE0018   LW S8, 24(SP)
9D005A1C  27BD0020   ADDIU SP, SP, 32
9D005A20  03E00008   JR RA
9D005A24  00000000   NOP
3220:                
3221:                
3222:                
3223:                
3224:                /*-----------------------------------------------------------------------*/
3225:                /* Delete a File or Directory                                            */
3226:                
3227:                /*-----------------------------------------------------------------------*/
3228:                
3229:                FRESULT f_unlink(
3230:                        const TCHAR *path /* Pointer to the file or directory path */
3231:                        ) {
9D005A28  27BDFF98   ADDIU SP, SP, -104
9D005A2C  AFBF0064   SW RA, 100(SP)
9D005A30  AFBE0060   SW S8, 96(SP)
9D005A34  03A0F021   ADDU S8, SP, ZERO
9D005A38  AFC40068   SW A0, 104(S8)
3232:                    FRESULT res;
3233:                    DIR dj, sdj;
3234:                    BYTE *dir;
3235:                    DWORD dclst;
3236:                    DEF_NAMEBUF;
3237:                
3238:                
3239:                    res = chk_mounted(&path, &dj.fs, 1);
9D005A3C  27C2001C   ADDIU V0, S8, 28
9D005A40  27C40068   ADDIU A0, S8, 104
9D005A44  00402821   ADDU A1, V0, ZERO
9D005A48  24060001   ADDIU A2, ZERO, 1
9D005A4C  0F400998   JAL 0x9D002660
9D005A50  00000000   NOP
9D005A54  AFC20010   SW V0, 16(S8)
3240:                    if (res == FR_OK) {
9D005A58  8FC20010   LW V0, 16(S8)
9D005A5C  14400098   BNE V0, ZERO, 0x9D005CC0
9D005A60  00000000   NOP
3241:                        INIT_BUF(dj);
9D005A64  27C20054   ADDIU V0, S8, 84
9D005A68  AFC20034   SW V0, 52(S8)
3242:                        res = follow_path(&dj, path); /* Follow the file path */
9D005A6C  8FC20068   LW V0, 104(S8)
9D005A70  27C3001C   ADDIU V1, S8, 28
9D005A74  00602021   ADDU A0, V1, ZERO
9D005A78  00402821   ADDU A1, V0, ZERO
9D005A7C  0F400897   JAL 0x9D00225C
9D005A80  00000000   NOP
9D005A84  AFC20010   SW V0, 16(S8)
3243:                        if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
9D005A88  8FC20010   LW V0, 16(S8)
9D005A8C  14400009   BNE V0, ZERO, 0x9D005AB4
9D005A90  00000000   NOP
9D005A94  8FC20034   LW V0, 52(S8)
9D005A98  2442000B   ADDIU V0, V0, 11
9D005A9C  90420000   LBU V0, 0(V0)
9D005AA0  30420020   ANDI V0, V0, 32
9D005AA4  10400003   BEQ V0, ZERO, 0x9D005AB4
9D005AA8  00000000   NOP
3244:                            res = FR_INVALID_NAME; /* Cannot remove dot entry */
9D005AAC  24020006   ADDIU V0, ZERO, 6
9D005AB0  AFC20010   SW V0, 16(S8)
3245:                #if _FS_SHARE
3246:                        if (res == FR_OK) res = chk_lock(&dj, 2); /* Cannot remove open file */
3247:                #endif
3248:                        if (res == FR_OK) { /* The object is accessible */
9D005AB4  8FC20010   LW V0, 16(S8)
9D005AB8  14400081   BNE V0, ZERO, 0x9D005CC0
9D005ABC  00000000   NOP
3249:                            dir = dj.dir;
9D005AC0  8FC20030   LW V0, 48(S8)
9D005AC4  AFC20014   SW V0, 20(S8)
3250:                            if (!dir) {
9D005AC8  8FC20014   LW V0, 20(S8)
9D005ACC  14400005   BNE V0, ZERO, 0x9D005AE4
9D005AD0  00000000   NOP
3251:                                res = FR_INVALID_NAME; /* Cannot remove the start directory */
9D005AD4  24020006   ADDIU V0, ZERO, 6
9D005AD8  AFC20010   SW V0, 16(S8)
9D005ADC  0B4016C2   J 0x9D005B08
9D005AE0  00000000   NOP
3252:                            } else {
3253:                                if (dir[DIR_Attr] & AM_RDO)
9D005AE4  8FC20014   LW V0, 20(S8)
9D005AE8  2442000B   ADDIU V0, V0, 11
9D005AEC  90420000   LBU V0, 0(V0)
9D005AF0  30420001   ANDI V0, V0, 1
9D005AF4  304200FF   ANDI V0, V0, 255
9D005AF8  10400003   BEQ V0, ZERO, 0x9D005B08
9D005AFC  00000000   NOP
3254:                                    res = FR_DENIED; /* Cannot remove R/O object */
9D005B00  24020007   ADDIU V0, ZERO, 7
9D005B04  AFC20010   SW V0, 16(S8)
3255:                            }
3256:                            dclst = LD_CLUST(dir);
9D005B08  8FC20014   LW V0, 20(S8)
9D005B0C  24420015   ADDIU V0, V0, 21
9D005B10  90420000   LBU V0, 0(V0)
9D005B14  00021200   SLL V0, V0, 8
9D005B18  7C021E20   SEH V1, V0
9D005B1C  8FC20014   LW V0, 20(S8)
9D005B20  24420014   ADDIU V0, V0, 20
9D005B24  90420000   LBU V0, 0(V0)
9D005B28  7C021620   SEH V0, V0
9D005B2C  00621025   OR V0, V1, V0
9D005B30  7C021620   SEH V0, V0
9D005B34  3042FFFF   ANDI V0, V0, -1
9D005B38  00021C00   SLL V1, V0, 16
9D005B3C  8FC20014   LW V0, 20(S8)
9D005B40  2442001B   ADDIU V0, V0, 27
9D005B44  90420000   LBU V0, 0(V0)
9D005B48  00021200   SLL V0, V0, 8
9D005B4C  7C022620   SEH A0, V0
9D005B50  8FC20014   LW V0, 20(S8)
9D005B54  2442001A   ADDIU V0, V0, 26
9D005B58  90420000   LBU V0, 0(V0)
9D005B5C  7C021620   SEH V0, V0
9D005B60  00821025   OR V0, A0, V0
9D005B64  7C021620   SEH V0, V0
9D005B68  3042FFFF   ANDI V0, V0, -1
9D005B6C  00621025   OR V0, V1, V0
9D005B70  AFC20018   SW V0, 24(S8)
3257:                            if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) { /* Is it a sub-dir? */
9D005B74  8FC20010   LW V0, 16(S8)
9D005B78  14400035   BNE V0, ZERO, 0x9D005C50
9D005B7C  00000000   NOP
9D005B80  8FC20014   LW V0, 20(S8)
9D005B84  2442000B   ADDIU V0, V0, 11
9D005B88  90420000   LBU V0, 0(V0)
9D005B8C  30420010   ANDI V0, V0, 16
9D005B90  1040002F   BEQ V0, ZERO, 0x9D005C50
9D005B94  00000000   NOP
3258:                                if (dclst < 2) {
9D005B98  8FC20018   LW V0, 24(S8)
9D005B9C  2C420002   SLTIU V0, V0, 2
9D005BA0  10400005   BEQ V0, ZERO, 0x9D005BB8
9D005BA4  00000000   NOP
3259:                                    res = FR_INT_ERR;
9D005BA8  24020002   ADDIU V0, ZERO, 2
9D005BAC  AFC20010   SW V0, 16(S8)
9D005BB0  0B401714   J 0x9D005C50
9D005BB4  00000000   NOP
3260:                                } else {
3261:                                    mem_cpy(&sdj, &dj, sizeof (DIR)); /* Check if the sub-dir is empty or not */
9D005BB8  27C30038   ADDIU V1, S8, 56
9D005BBC  27C2001C   ADDIU V0, S8, 28
9D005BC0  00602021   ADDU A0, V1, ZERO
9D005BC4  00402821   ADDU A1, V0, ZERO
9D005BC8  2406001C   ADDIU A2, ZERO, 28
9D005BCC  0F400008   JAL 0x9D000020
9D005BD0  00000000   NOP
3262:                                    sdj.sclust = dclst;
9D005BD4  8FC20018   LW V0, 24(S8)
9D005BD8  AFC20040   SW V0, 64(S8)
3263:                                    res = dir_sdi(&sdj, 2); /* Exclude dot entries */
9D005BDC  27C20038   ADDIU V0, S8, 56
9D005BE0  00402021   ADDU A0, V0, ZERO
9D005BE4  24050002   ADDIU A1, ZERO, 2
9D005BE8  0F40045E   JAL 0x9D001178
9D005BEC  00000000   NOP
9D005BF0  AFC20010   SW V0, 16(S8)
3264:                                    if (res == FR_OK) {
9D005BF4  8FC20010   LW V0, 16(S8)
9D005BF8  14400015   BNE V0, ZERO, 0x9D005C50
9D005BFC  00000000   NOP
3265:                                        res = dir_read(&sdj);
9D005C00  27C20038   ADDIU V0, S8, 56
9D005C04  00402021   ADDU A0, V0, ZERO
9D005C08  0F400618   JAL 0x9D001860
9D005C0C  00000000   NOP
9D005C10  AFC20010   SW V0, 16(S8)
3266:                                        if (res == FR_OK /* Not empty dir */
9D005C14  8FC20010   LW V0, 16(S8)
9D005C18  10400006   BEQ V0, ZERO, 0x9D005C34
9D005C1C  00000000   NOP
3267:                #if _FS_RPATH
3268:                                                || dclst == sdj.fs->cdir /* Current dir */
9D005C20  8FC20038   LW V0, 56(S8)
9D005C24  8C430018   LW V1, 24(V0)
9D005C28  8FC20018   LW V0, 24(S8)
9D005C2C  14620003   BNE V1, V0, 0x9D005C3C
9D005C30  00000000   NOP
3269:                #endif
3270:                                                ) res = FR_DENIED;
9D005C34  24020007   ADDIU V0, ZERO, 7
9D005C38  AFC20010   SW V0, 16(S8)
3271:                                        if (res == FR_NO_FILE) res = FR_OK; /* Empty */
9D005C3C  8FC30010   LW V1, 16(S8)
9D005C40  24020004   ADDIU V0, ZERO, 4
9D005C44  14620002   BNE V1, V0, 0x9D005C50
9D005C48  00000000   NOP
9D005C4C  AFC00010   SW ZERO, 16(S8)
3272:                                    }
3273:                                }
3274:                            }
3275:                            if (res == FR_OK) {
9D005C50  8FC20010   LW V0, 16(S8)
9D005C54  1440001A   BNE V0, ZERO, 0x9D005CC0
9D005C58  00000000   NOP
3276:                                res = dir_remove(&dj); /* Remove the directory entry */
9D005C5C  27C2001C   ADDIU V0, S8, 28
9D005C60  00402021   ADDU A0, V0, ZERO
9D005C64  0F4006BD   JAL 0x9D001AF4
9D005C68  00000000   NOP
9D005C6C  AFC20010   SW V0, 16(S8)
3277:                                if (res == FR_OK) {
9D005C70  8FC20010   LW V0, 16(S8)
9D005C74  14400012   BNE V0, ZERO, 0x9D005CC0
9D005C78  00000000   NOP
3278:                                    if (dclst) /* Remove the cluster chain if exist */
9D005C7C  8FC20018   LW V0, 24(S8)
9D005C80  10400007   BEQ V0, ZERO, 0x9D005CA0
9D005C84  00000000   NOP
3279:                                        res = remove_chain(dj.fs, dclst);
9D005C88  8FC2001C   LW V0, 28(S8)
9D005C8C  00402021   ADDU A0, V0, ZERO
9D005C90  8FC50018   LW A1, 24(S8)
9D005C94  0F400368   JAL 0x9D000DA0
9D005C98  00000000   NOP
9D005C9C  AFC20010   SW V0, 16(S8)
3280:                                    if (res == FR_OK) res = sync(dj.fs);
9D005CA0  8FC20010   LW V0, 16(S8)
9D005CA4  14400006   BNE V0, ZERO, 0x9D005CC0
9D005CA8  00000000   NOP
9D005CAC  8FC2001C   LW V0, 28(S8)
9D005CB0  00402021   ADDU A0, V0, ZERO
9D005CB4  0F4000F5   JAL 0x9D0003D4
9D005CB8  00000000   NOP
9D005CBC  AFC20010   SW V0, 16(S8)
3281:                                }
3282:                            }
3283:                        }
3284:                        FREE_BUF();
3285:                    }
3286:                    LEAVE_FF(dj.fs, res);
9D005CC0  8FC20010   LW V0, 16(S8)
3287:                }
9D005CC4  03C0E821   ADDU SP, S8, ZERO
9D005CC8  8FBF0064   LW RA, 100(SP)
9D005CCC  8FBE0060   LW S8, 96(SP)
9D005CD0  27BD0068   ADDIU SP, SP, 104
9D005CD4  03E00008   JR RA
9D005CD8  00000000   NOP
3288:                
3289:                
3290:                
3291:                
3292:                /*-----------------------------------------------------------------------*/
3293:                /* Create a Directory                                                    */
3294:                
3295:                /*-----------------------------------------------------------------------*/
3296:                
3297:                FRESULT f_mkdir(
3298:                        const TCHAR *path /* Pointer to the directory path */
3299:                        ) {
9D005CDC  27BDFFA0   ADDIU SP, SP, -96
9D005CE0  AFBF005C   SW RA, 92(SP)
9D005CE4  AFBE0058   SW S8, 88(SP)
9D005CE8  03A0F021   ADDU S8, SP, ZERO
9D005CEC  AFC40060   SW A0, 96(S8)
3300:                    FRESULT res;
3301:                    DIR dj;
3302:                    BYTE *dir, n;
3303:                    DWORD dsc, dcl, pcl, tim = get_fattime();
9D005CF0  0F402C66   JAL get_fattime
9D005CF4  00000000   NOP
9D005CF8  AFC20020   SW V0, 32(S8)
3304:                    DEF_NAMEBUF;
3305:                
3306:                
3307:                    res = chk_mounted(&path, &dj.fs, 1);
9D005CFC  27C2002C   ADDIU V0, S8, 44
9D005D00  27C40060   ADDIU A0, S8, 96
9D005D04  00402821   ADDU A1, V0, ZERO
9D005D08  24060001   ADDIU A2, ZERO, 1
9D005D0C  0F400998   JAL 0x9D002660
9D005D10  00000000   NOP
9D005D14  AFC20010   SW V0, 16(S8)
3308:                    if (res == FR_OK) {
9D005D18  8FC20010   LW V0, 16(S8)
9D005D1C  14400140   BNE V0, ZERO, 0x9D006220
9D005D20  00000000   NOP
3309:                        INIT_BUF(dj);
9D005D24  27C20048   ADDIU V0, S8, 72
9D005D28  AFC20044   SW V0, 68(S8)
3310:                        res = follow_path(&dj, path); /* Follow the file path */
9D005D2C  8FC20060   LW V0, 96(S8)
9D005D30  27C3002C   ADDIU V1, S8, 44
9D005D34  00602021   ADDU A0, V1, ZERO
9D005D38  00402821   ADDU A1, V0, ZERO
9D005D3C  0F400897   JAL 0x9D00225C
9D005D40  00000000   NOP
9D005D44  AFC20010   SW V0, 16(S8)
3311:                        if (res == FR_OK) res = FR_EXIST; /* Any object with same name is already existing */
9D005D48  8FC20010   LW V0, 16(S8)
9D005D4C  14400003   BNE V0, ZERO, 0x9D005D5C
9D005D50  00000000   NOP
9D005D54  24020008   ADDIU V0, ZERO, 8
9D005D58  AFC20010   SW V0, 16(S8)
3312:                        if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
9D005D5C  8FC30010   LW V1, 16(S8)
9D005D60  24020004   ADDIU V0, ZERO, 4
9D005D64  14620009   BNE V1, V0, 0x9D005D8C
9D005D68  00000000   NOP
9D005D6C  8FC20044   LW V0, 68(S8)
9D005D70  2442000B   ADDIU V0, V0, 11
9D005D74  90420000   LBU V0, 0(V0)
9D005D78  30420020   ANDI V0, V0, 32
9D005D7C  10400003   BEQ V0, ZERO, 0x9D005D8C
9D005D80  00000000   NOP
3313:                            res = FR_INVALID_NAME;
9D005D84  24020006   ADDIU V0, ZERO, 6
9D005D88  AFC20010   SW V0, 16(S8)
3314:                        if (res == FR_NO_FILE) { /* Can create a new directory */
9D005D8C  8FC30010   LW V1, 16(S8)
9D005D90  24020004   ADDIU V0, ZERO, 4
9D005D94  14620122   BNE V1, V0, 0x9D006220
9D005D98  00000000   NOP
3315:                            dcl = create_chain(dj.fs, 0); /* Allocate a cluster for the new directory table */
9D005D9C  8FC2002C   LW V0, 44(S8)
9D005DA0  00402021   ADDU A0, V0, ZERO
9D005DA4  00002821   ADDU A1, ZERO, ZERO
9D005DA8  0F4003C2   JAL 0x9D000F08
9D005DAC  00000000   NOP
9D005DB0  AFC20024   SW V0, 36(S8)
3316:                            res = FR_OK;
9D005DB4  AFC00010   SW ZERO, 16(S8)
3317:                            if (dcl == 0) res = FR_DENIED; /* No space to allocate a new cluster */
9D005DB8  8FC20024   LW V0, 36(S8)
9D005DBC  14400003   BNE V0, ZERO, 0x9D005DCC
9D005DC0  00000000   NOP
9D005DC4  24020007   ADDIU V0, ZERO, 7
9D005DC8  AFC20010   SW V0, 16(S8)
3318:                            if (dcl == 1) res = FR_INT_ERR;
9D005DCC  8FC30024   LW V1, 36(S8)
9D005DD0  24020001   ADDIU V0, ZERO, 1
9D005DD4  14620003   BNE V1, V0, 0x9D005DE4
9D005DD8  00000000   NOP
9D005DDC  24020002   ADDIU V0, ZERO, 2
9D005DE0  AFC20010   SW V0, 16(S8)
3319:                            if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
9D005DE4  8FC30024   LW V1, 36(S8)
9D005DE8  2402FFFF   ADDIU V0, ZERO, -1
9D005DEC  14620003   BNE V1, V0, 0x9D005DFC
9D005DF0  00000000   NOP
9D005DF4  24020001   ADDIU V0, ZERO, 1
9D005DF8  AFC20010   SW V0, 16(S8)
3320:                            if (res == FR_OK) /* Flush FAT */
9D005DFC  8FC20010   LW V0, 16(S8)
9D005E00  14400007   BNE V0, ZERO, 0x9D005E20
9D005E04  00000000   NOP
3321:                                res = move_window(dj.fs, 0);
9D005E08  8FC2002C   LW V0, 44(S8)
9D005E0C  00402021   ADDU A0, V0, ZERO
9D005E10  00002821   ADDU A1, ZERO, ZERO
9D005E14  0F400090   JAL 0x9D000240
9D005E18  00000000   NOP
9D005E1C  AFC20010   SW V0, 16(S8)
3322:                            if (res == FR_OK) { /* Initialize the new directory table */
9D005E20  8FC20010   LW V0, 16(S8)
9D005E24  144000A9   BNE V0, ZERO, 0x9D0060CC
9D005E28  00000000   NOP
3323:                                dsc = clust2sect(dj.fs, dcl);
9D005E2C  8FC2002C   LW V0, 44(S8)
9D005E30  00402021   ADDU A0, V0, ZERO
9D005E34  8FC50024   LW A1, 36(S8)
9D005E38  0F400195   JAL clust2sect
9D005E3C  00000000   NOP
9D005E40  AFC20018   SW V0, 24(S8)
3324:                                dir = dj.fs->win;
9D005E44  8FC2002C   LW V0, 44(S8)
9D005E48  24420034   ADDIU V0, V0, 52
9D005E4C  AFC20028   SW V0, 40(S8)
3325:                                mem_set(dir, 0, SS(dj.fs));
9D005E50  8FC40028   LW A0, 40(S8)
9D005E54  00002821   ADDU A1, ZERO, ZERO
9D005E58  24060200   ADDIU A2, ZERO, 512
9D005E5C  0F40002B   JAL 0x9D0000AC
9D005E60  00000000   NOP
3326:                                mem_set(dir + DIR_Name, ' ', 8 + 3); /* Create "." entry */
9D005E64  8FC40028   LW A0, 40(S8)
9D005E68  24050020   ADDIU A1, ZERO, 32
9D005E6C  2406000B   ADDIU A2, ZERO, 11
9D005E70  0F40002B   JAL 0x9D0000AC
9D005E74  00000000   NOP
3327:                                dir[DIR_Name] = '.';
9D005E78  8FC20028   LW V0, 40(S8)
9D005E7C  2403002E   ADDIU V1, ZERO, 46
9D005E80  A0430000   SB V1, 0(V0)
3328:                                dir[DIR_Attr] = AM_DIR;
9D005E84  8FC20028   LW V0, 40(S8)
9D005E88  2442000B   ADDIU V0, V0, 11
9D005E8C  24030010   ADDIU V1, ZERO, 16
9D005E90  A0430000   SB V1, 0(V0)
3329:                                ST_DWORD(dir + DIR_WrtTime, tim);
9D005E94  8FC20028   LW V0, 40(S8)
9D005E98  24420016   ADDIU V0, V0, 22
9D005E9C  8FC30020   LW V1, 32(S8)
9D005EA0  306300FF   ANDI V1, V1, 255
9D005EA4  A0430000   SB V1, 0(V0)
9D005EA8  8FC20028   LW V0, 40(S8)
9D005EAC  24420017   ADDIU V0, V0, 23
9D005EB0  8FC30020   LW V1, 32(S8)
9D005EB4  3063FFFF   ANDI V1, V1, -1
9D005EB8  00031A02   SRL V1, V1, 8
9D005EBC  3063FFFF   ANDI V1, V1, -1
9D005EC0  306300FF   ANDI V1, V1, 255
9D005EC4  A0430000   SB V1, 0(V0)
9D005EC8  8FC20028   LW V0, 40(S8)
9D005ECC  24420018   ADDIU V0, V0, 24
9D005ED0  8FC30020   LW V1, 32(S8)
9D005ED4  00031C02   SRL V1, V1, 16
9D005ED8  306300FF   ANDI V1, V1, 255
9D005EDC  A0430000   SB V1, 0(V0)
9D005EE0  8FC20028   LW V0, 40(S8)
9D005EE4  24420019   ADDIU V0, V0, 25
9D005EE8  8FC30020   LW V1, 32(S8)
9D005EEC  00031E02   SRL V1, V1, 24
9D005EF0  306300FF   ANDI V1, V1, 255
9D005EF4  A0430000   SB V1, 0(V0)
3330:                                ST_CLUST(dir, dcl);
9D005EF8  8FC20028   LW V0, 40(S8)
9D005EFC  2442001A   ADDIU V0, V0, 26
9D005F00  8FC30024   LW V1, 36(S8)
9D005F04  306300FF   ANDI V1, V1, 255
9D005F08  A0430000   SB V1, 0(V0)
9D005F0C  8FC20028   LW V0, 40(S8)
9D005F10  2442001B   ADDIU V0, V0, 27
9D005F14  8FC30024   LW V1, 36(S8)
9D005F18  3063FFFF   ANDI V1, V1, -1
9D005F1C  00031A02   SRL V1, V1, 8
9D005F20  3063FFFF   ANDI V1, V1, -1
9D005F24  306300FF   ANDI V1, V1, 255
9D005F28  A0430000   SB V1, 0(V0)
9D005F2C  8FC20028   LW V0, 40(S8)
9D005F30  24420014   ADDIU V0, V0, 20
9D005F34  8FC30024   LW V1, 36(S8)
9D005F38  00031C02   SRL V1, V1, 16
9D005F3C  306300FF   ANDI V1, V1, 255
9D005F40  A0430000   SB V1, 0(V0)
9D005F44  8FC20028   LW V0, 40(S8)
9D005F48  24420015   ADDIU V0, V0, 21
9D005F4C  8FC30024   LW V1, 36(S8)
9D005F50  00031C02   SRL V1, V1, 16
9D005F54  3063FFFF   ANDI V1, V1, -1
9D005F58  00031A02   SRL V1, V1, 8
9D005F5C  3063FFFF   ANDI V1, V1, -1
9D005F60  306300FF   ANDI V1, V1, 255
9D005F64  A0430000   SB V1, 0(V0)
3331:                                mem_cpy(dir + SZ_DIR, dir, SZ_DIR); /* Create ".." entry */
9D005F68  8FC20028   LW V0, 40(S8)
9D005F6C  24420020   ADDIU V0, V0, 32
9D005F70  00402021   ADDU A0, V0, ZERO
9D005F74  8FC50028   LW A1, 40(S8)
9D005F78  24060020   ADDIU A2, ZERO, 32
9D005F7C  0F400008   JAL 0x9D000020
9D005F80  00000000   NOP
3332:                                dir[33] = '.';
9D005F84  8FC20028   LW V0, 40(S8)
9D005F88  24420021   ADDIU V0, V0, 33
9D005F8C  2403002E   ADDIU V1, ZERO, 46
9D005F90  A0430000   SB V1, 0(V0)
3333:                                pcl = dj.sclust;
9D005F94  8FC20034   LW V0, 52(S8)
9D005F98  AFC2001C   SW V0, 28(S8)
3334:                                if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
9D005F9C  8FC2002C   LW V0, 44(S8)
9D005FA0  90430000   LBU V1, 0(V0)
9D005FA4  24020003   ADDIU V0, ZERO, 3
9D005FA8  14620007   BNE V1, V0, 0x9D005FC8
9D005FAC  00000000   NOP
9D005FB0  8FC2002C   LW V0, 44(S8)
9D005FB4  8C430028   LW V1, 40(V0)
9D005FB8  8FC2001C   LW V0, 28(S8)
9D005FBC  14620002   BNE V1, V0, 0x9D005FC8
9D005FC0  00000000   NOP
3335:                                    pcl = 0;
9D005FC4  AFC0001C   SW ZERO, 28(S8)
3336:                                ST_CLUST(dir + SZ_DIR, pcl);
9D005FC8  8FC20028   LW V0, 40(S8)
9D005FCC  2442003A   ADDIU V0, V0, 58
9D005FD0  8FC3001C   LW V1, 28(S8)
9D005FD4  306300FF   ANDI V1, V1, 255
9D005FD8  A0430000   SB V1, 0(V0)
9D005FDC  8FC20028   LW V0, 40(S8)
9D005FE0  2442003B   ADDIU V0, V0, 59
9D005FE4  8FC3001C   LW V1, 28(S8)
9D005FE8  3063FFFF   ANDI V1, V1, -1
9D005FEC  00031A02   SRL V1, V1, 8
9D005FF0  3063FFFF   ANDI V1, V1, -1
9D005FF4  306300FF   ANDI V1, V1, 255
9D005FF8  A0430000   SB V1, 0(V0)
9D005FFC  8FC20028   LW V0, 40(S8)
9D006000  24420034   ADDIU V0, V0, 52
9D006004  8FC3001C   LW V1, 28(S8)
9D006008  00031C02   SRL V1, V1, 16
9D00600C  306300FF   ANDI V1, V1, 255
9D006010  A0430000   SB V1, 0(V0)
9D006014  8FC20028   LW V0, 40(S8)
9D006018  24420035   ADDIU V0, V0, 53
9D00601C  8FC3001C   LW V1, 28(S8)
9D006020  00031C02   SRL V1, V1, 16
9D006024  3063FFFF   ANDI V1, V1, -1
9D006028  00031A02   SRL V1, V1, 8
9D00602C  3063FFFF   ANDI V1, V1, -1
9D006030  306300FF   ANDI V1, V1, 255
9D006034  A0430000   SB V1, 0(V0)
3337:                                for (n = dj.fs->csize; n; n--) { /* Write dot entries and clear following sectors */
9D006038  8FC2002C   LW V0, 44(S8)
9D00603C  90420002   LBU V0, 2(V0)
9D006040  A3C20014   SB V0, 20(S8)
9D006044  0B40182D   J 0x9D0060B4
9D006048  00000000   NOP
9D0060A8  93C20014   LBU V0, 20(S8)
9D0060AC  2442FFFF   ADDIU V0, V0, -1
9D0060B0  A3C20014   SB V0, 20(S8)
9D0060B4  93C20014   LBU V0, 20(S8)
9D0060B8  1440FFE4   BNE V0, ZERO, 0x9D00604C
9D0060BC  00000000   NOP
9D0060C0  0B401833   J 0x9D0060CC
9D0060C4  00000000   NOP
3338:                                    dj.fs->winsect = dsc++;
9D00604C  8FC2002C   LW V0, 44(S8)
9D006050  8FC30018   LW V1, 24(S8)
9D006054  AC430030   SW V1, 48(V0)
9D006058  8FC20018   LW V0, 24(S8)
9D00605C  24420001   ADDIU V0, V0, 1
9D006060  AFC20018   SW V0, 24(S8)
3339:                                    dj.fs->wflag = 1;
9D006064  8FC2002C   LW V0, 44(S8)
9D006068  24030001   ADDIU V1, ZERO, 1
9D00606C  A0430004   SB V1, 4(V0)
3340:                                    res = move_window(dj.fs, 0);
9D006070  8FC2002C   LW V0, 44(S8)
9D006074  00402021   ADDU A0, V0, ZERO
9D006078  00002821   ADDU A1, ZERO, ZERO
9D00607C  0F400090   JAL 0x9D000240
9D006080  00000000   NOP
9D006084  AFC20010   SW V0, 16(S8)
3341:                                    if (res != FR_OK) break;
9D006088  8FC20010   LW V0, 16(S8)
9D00608C  1440000E   BNE V0, ZERO, 0x9D0060C8
9D006090  00000000   NOP
9D0060C8  00000000   NOP
3342:                                    mem_set(dir, 0, SS(dj.fs));
9D006094  8FC40028   LW A0, 40(S8)
9D006098  00002821   ADDU A1, ZERO, ZERO
9D00609C  24060200   ADDIU A2, ZERO, 512
9D0060A0  0F40002B   JAL 0x9D0000AC
9D0060A4  00000000   NOP
3343:                                }
3344:                            }
3345:                            if (res == FR_OK) res = dir_register(&dj); /* Register the object to the directoy */
9D0060CC  8FC20010   LW V0, 16(S8)
9D0060D0  14400006   BNE V0, ZERO, 0x9D0060EC
9D0060D4  00000000   NOP
9D0060D8  27C2002C   ADDIU V0, S8, 44
9D0060DC  00402021   ADDU A0, V0, ZERO
9D0060E0  0F400665   JAL 0x9D001994
9D0060E4  00000000   NOP
9D0060E8  AFC20010   SW V0, 16(S8)
3346:                            if (res != FR_OK) {
9D0060EC  8FC20010   LW V0, 16(S8)
9D0060F0  10400008   BEQ V0, ZERO, 0x9D006114
9D0060F4  00000000   NOP
3347:                                remove_chain(dj.fs, dcl); /* Could not register, remove cluster chain */
9D0060F8  8FC2002C   LW V0, 44(S8)
9D0060FC  00402021   ADDU A0, V0, ZERO
9D006100  8FC50024   LW A1, 36(S8)
9D006104  0F400368   JAL 0x9D000DA0
9D006108  00000000   NOP
9D00610C  0B401888   J 0x9D006220
9D006110  00000000   NOP
3348:                            } else {
3349:                                dir = dj.dir;
9D006114  8FC20040   LW V0, 64(S8)
9D006118  AFC20028   SW V0, 40(S8)
3350:                                dir[DIR_Attr] = AM_DIR; /* Attribute */
9D00611C  8FC20028   LW V0, 40(S8)
9D006120  2442000B   ADDIU V0, V0, 11
9D006124  24030010   ADDIU V1, ZERO, 16
9D006128  A0430000   SB V1, 0(V0)
3351:                                ST_DWORD(dir + DIR_WrtTime, tim); /* Created time */
9D00612C  8FC20028   LW V0, 40(S8)
9D006130  24420016   ADDIU V0, V0, 22
9D006134  8FC30020   LW V1, 32(S8)
9D006138  306300FF   ANDI V1, V1, 255
9D00613C  A0430000   SB V1, 0(V0)
9D006140  8FC20028   LW V0, 40(S8)
9D006144  24420017   ADDIU V0, V0, 23
9D006148  8FC30020   LW V1, 32(S8)
9D00614C  3063FFFF   ANDI V1, V1, -1
9D006150  00031A02   SRL V1, V1, 8
9D006154  3063FFFF   ANDI V1, V1, -1
9D006158  306300FF   ANDI V1, V1, 255
9D00615C  A0430000   SB V1, 0(V0)
9D006160  8FC20028   LW V0, 40(S8)
9D006164  24420018   ADDIU V0, V0, 24
9D006168  8FC30020   LW V1, 32(S8)
9D00616C  00031C02   SRL V1, V1, 16
9D006170  306300FF   ANDI V1, V1, 255
9D006174  A0430000   SB V1, 0(V0)
9D006178  8FC20028   LW V0, 40(S8)
9D00617C  24420019   ADDIU V0, V0, 25
9D006180  8FC30020   LW V1, 32(S8)
9D006184  00031E02   SRL V1, V1, 24
9D006188  306300FF   ANDI V1, V1, 255
9D00618C  A0430000   SB V1, 0(V0)
3352:                                ST_CLUST(dir, dcl); /* Table start cluster */
9D006190  8FC20028   LW V0, 40(S8)
9D006194  2442001A   ADDIU V0, V0, 26
9D006198  8FC30024   LW V1, 36(S8)
9D00619C  306300FF   ANDI V1, V1, 255
9D0061A0  A0430000   SB V1, 0(V0)
9D0061A4  8FC20028   LW V0, 40(S8)
9D0061A8  2442001B   ADDIU V0, V0, 27
9D0061AC  8FC30024   LW V1, 36(S8)
9D0061B0  3063FFFF   ANDI V1, V1, -1
9D0061B4  00031A02   SRL V1, V1, 8
9D0061B8  3063FFFF   ANDI V1, V1, -1
9D0061BC  306300FF   ANDI V1, V1, 255
9D0061C0  A0430000   SB V1, 0(V0)
9D0061C4  8FC20028   LW V0, 40(S8)
9D0061C8  24420014   ADDIU V0, V0, 20
9D0061CC  8FC30024   LW V1, 36(S8)
9D0061D0  00031C02   SRL V1, V1, 16
9D0061D4  306300FF   ANDI V1, V1, 255
9D0061D8  A0430000   SB V1, 0(V0)
9D0061DC  8FC20028   LW V0, 40(S8)
9D0061E0  24420015   ADDIU V0, V0, 21
9D0061E4  8FC30024   LW V1, 36(S8)
9D0061E8  00031C02   SRL V1, V1, 16
9D0061EC  3063FFFF   ANDI V1, V1, -1
9D0061F0  00031A02   SRL V1, V1, 8
9D0061F4  3063FFFF   ANDI V1, V1, -1
9D0061F8  306300FF   ANDI V1, V1, 255
9D0061FC  A0430000   SB V1, 0(V0)
3353:                                dj.fs->wflag = 1;
9D006200  8FC2002C   LW V0, 44(S8)
9D006204  24030001   ADDIU V1, ZERO, 1
9D006208  A0430004   SB V1, 4(V0)
3354:                                res = sync(dj.fs);
9D00620C  8FC2002C   LW V0, 44(S8)
9D006210  00402021   ADDU A0, V0, ZERO
9D006214  0F4000F5   JAL 0x9D0003D4
9D006218  00000000   NOP
9D00621C  AFC20010   SW V0, 16(S8)
3355:                            }
3356:                        }
3357:                        FREE_BUF();
3358:                    }
3359:                
3360:                    LEAVE_FF(dj.fs, res);
9D006220  8FC20010   LW V0, 16(S8)
3361:                }
9D006224  03C0E821   ADDU SP, S8, ZERO
9D006228  8FBF005C   LW RA, 92(SP)
9D00622C  8FBE0058   LW S8, 88(SP)
9D006230  27BD0060   ADDIU SP, SP, 96
9D006234  03E00008   JR RA
9D006238  00000000   NOP
3362:                
3363:                
3364:                
3365:                
3366:                /*-----------------------------------------------------------------------*/
3367:                /* Change Attribute                                                      */
3368:                
3369:                /*-----------------------------------------------------------------------*/
3370:                
3371:                FRESULT f_chmod(
3372:                        const TCHAR *path, /* Pointer to the file path */
3373:                        BYTE value, /* Attribute bits */
3374:                        BYTE mask /* Attribute mask to change */
3375:                        ) {
9D00623C  27BDFFB8   ADDIU SP, SP, -72
9D006240  AFBF0044   SW RA, 68(SP)
9D006244  AFBE0040   SW S8, 64(SP)
9D006248  03A0F021   ADDU S8, SP, ZERO
9D00624C  AFC40048   SW A0, 72(S8)
9D006250  00A01821   ADDU V1, A1, ZERO
9D006254  00C01021   ADDU V0, A2, ZERO
9D006258  A3C3004C   SB V1, 76(S8)
9D00625C  A3C20050   SB V0, 80(S8)
3376:                    FRESULT res;
3377:                    DIR dj;
3378:                    BYTE *dir;
3379:                    DEF_NAMEBUF;
3380:                
3381:                
3382:                    res = chk_mounted(&path, &dj.fs, 1);
9D006260  27C20018   ADDIU V0, S8, 24
9D006264  27C40048   ADDIU A0, S8, 72
9D006268  00402821   ADDU A1, V0, ZERO
9D00626C  24060001   ADDIU A2, ZERO, 1
9D006270  0F400998   JAL 0x9D002660
9D006274  00000000   NOP
9D006278  AFC20010   SW V0, 16(S8)
3383:                    if (res == FR_OK) {
9D00627C  8FC20010   LW V0, 16(S8)
9D006280  1440003D   BNE V0, ZERO, 0x9D006378
9D006284  00000000   NOP
3384:                        INIT_BUF(dj);
9D006288  27C20034   ADDIU V0, S8, 52
9D00628C  AFC20030   SW V0, 48(S8)
3385:                        res = follow_path(&dj, path); /* Follow the file path */
9D006290  8FC20048   LW V0, 72(S8)
9D006294  27C30018   ADDIU V1, S8, 24
9D006298  00602021   ADDU A0, V1, ZERO
9D00629C  00402821   ADDU A1, V0, ZERO
9D0062A0  0F400897   JAL 0x9D00225C
9D0062A4  00000000   NOP
9D0062A8  AFC20010   SW V0, 16(S8)
3386:                        FREE_BUF();
3387:                        if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
9D0062AC  8FC20010   LW V0, 16(S8)
9D0062B0  14400009   BNE V0, ZERO, 0x9D0062D8
9D0062B4  00000000   NOP
9D0062B8  8FC20030   LW V0, 48(S8)
9D0062BC  2442000B   ADDIU V0, V0, 11
9D0062C0  90420000   LBU V0, 0(V0)
9D0062C4  30420020   ANDI V0, V0, 32
9D0062C8  10400003   BEQ V0, ZERO, 0x9D0062D8
9D0062CC  00000000   NOP
3388:                            res = FR_INVALID_NAME;
9D0062D0  24020006   ADDIU V0, ZERO, 6
9D0062D4  AFC20010   SW V0, 16(S8)
3389:                        if (res == FR_OK) {
9D0062D8  8FC20010   LW V0, 16(S8)
9D0062DC  14400026   BNE V0, ZERO, 0x9D006378
9D0062E0  00000000   NOP
3390:                            dir = dj.dir;
9D0062E4  8FC2002C   LW V0, 44(S8)
9D0062E8  AFC20014   SW V0, 20(S8)
3391:                            if (!dir) { /* Is it a root directory? */
9D0062EC  8FC20014   LW V0, 20(S8)
9D0062F0  14400005   BNE V0, ZERO, 0x9D006308
9D0062F4  00000000   NOP
3392:                                res = FR_INVALID_NAME;
9D0062F8  24020006   ADDIU V0, ZERO, 6
9D0062FC  AFC20010   SW V0, 16(S8)
9D006300  0B4018DE   J 0x9D006378
9D006304  00000000   NOP
3393:                            } else { /* File or sub directory */
3394:                                mask &= AM_RDO | AM_HID | AM_SYS | AM_ARC; /* Valid attribute mask */
9D006308  93C20050   LBU V0, 80(S8)
9D00630C  30420027   ANDI V0, V0, 39
9D006310  A3C20050   SB V0, 80(S8)
3395:                                dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE) ~mask); /* Apply attribute change */
9D006314  8FC20014   LW V0, 20(S8)
9D006318  2442000B   ADDIU V0, V0, 11
9D00631C  93C4004C   LBU A0, 76(S8)
9D006320  93C30050   LBU V1, 80(S8)
9D006324  00831824   AND V1, A0, V1
9D006328  306400FF   ANDI A0, V1, 255
9D00632C  8FC30014   LW V1, 20(S8)
9D006330  2463000B   ADDIU V1, V1, 11
9D006334  90650000   LBU A1, 0(V1)
9D006338  93C30050   LBU V1, 80(S8)
9D00633C  00031827   NOR V1, ZERO, V1
9D006340  306300FF   ANDI V1, V1, 255
9D006344  00A31824   AND V1, A1, V1
9D006348  306300FF   ANDI V1, V1, 255
9D00634C  00831825   OR V1, A0, V1
9D006350  306300FF   ANDI V1, V1, 255
9D006354  A0430000   SB V1, 0(V0)
3396:                                dj.fs->wflag = 1;
9D006358  8FC20018   LW V0, 24(S8)
9D00635C  24030001   ADDIU V1, ZERO, 1
9D006360  A0430004   SB V1, 4(V0)
3397:                                res = sync(dj.fs);
9D006364  8FC20018   LW V0, 24(S8)
9D006368  00402021   ADDU A0, V0, ZERO
9D00636C  0F4000F5   JAL 0x9D0003D4
9D006370  00000000   NOP
9D006374  AFC20010   SW V0, 16(S8)
3398:                            }
3399:                        }
3400:                    }
3401:                
3402:                    LEAVE_FF(dj.fs, res);
9D006378  8FC20010   LW V0, 16(S8)
3403:                }
9D00637C  03C0E821   ADDU SP, S8, ZERO
9D006380  8FBF0044   LW RA, 68(SP)
9D006384  8FBE0040   LW S8, 64(SP)
9D006388  27BD0048   ADDIU SP, SP, 72
9D00638C  03E00008   JR RA
9D006390  00000000   NOP
3404:                
3405:                
3406:                
3407:                
3408:                /*-----------------------------------------------------------------------*/
3409:                /* Change Timestamp                                                      */
3410:                
3411:                /*-----------------------------------------------------------------------*/
3412:                
3413:                FRESULT f_utime(
3414:                        const TCHAR *path, /* Pointer to the file/directory name */
3415:                        const FILINFO *fno /* Pointer to the time stamp to be set */
3416:                        ) {
9D006394  27BDFFB8   ADDIU SP, SP, -72
9D006398  AFBF0044   SW RA, 68(SP)
9D00639C  AFBE0040   SW S8, 64(SP)
9D0063A0  03A0F021   ADDU S8, SP, ZERO
9D0063A4  AFC40048   SW A0, 72(S8)
9D0063A8  AFC5004C   SW A1, 76(S8)
3417:                    FRESULT res;
3418:                    DIR dj;
3419:                    BYTE *dir;
3420:                    DEF_NAMEBUF;
3421:                
3422:                
3423:                    res = chk_mounted(&path, &dj.fs, 1);
9D0063AC  27C20018   ADDIU V0, S8, 24
9D0063B0  27C40048   ADDIU A0, S8, 72
9D0063B4  00402821   ADDU A1, V0, ZERO
9D0063B8  24060001   ADDIU A2, ZERO, 1
9D0063BC  0F400998   JAL 0x9D002660
9D0063C0  00000000   NOP
9D0063C4  AFC20010   SW V0, 16(S8)
3424:                    if (res == FR_OK) {
9D0063C8  8FC20010   LW V0, 16(S8)
9D0063CC  14400045   BNE V0, ZERO, 0x9D0064E4
9D0063D0  00000000   NOP
3425:                        INIT_BUF(dj);
9D0063D4  27C20034   ADDIU V0, S8, 52
9D0063D8  AFC20030   SW V0, 48(S8)
3426:                        res = follow_path(&dj, path); /* Follow the file path */
9D0063DC  8FC20048   LW V0, 72(S8)
9D0063E0  27C30018   ADDIU V1, S8, 24
9D0063E4  00602021   ADDU A0, V1, ZERO
9D0063E8  00402821   ADDU A1, V0, ZERO
9D0063EC  0F400897   JAL 0x9D00225C
9D0063F0  00000000   NOP
9D0063F4  AFC20010   SW V0, 16(S8)
3427:                        FREE_BUF();
3428:                        if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
9D0063F8  8FC20010   LW V0, 16(S8)
9D0063FC  14400009   BNE V0, ZERO, 0x9D006424
9D006400  00000000   NOP
9D006404  8FC20030   LW V0, 48(S8)
9D006408  2442000B   ADDIU V0, V0, 11
9D00640C  90420000   LBU V0, 0(V0)
9D006410  30420020   ANDI V0, V0, 32
9D006414  10400003   BEQ V0, ZERO, 0x9D006424
9D006418  00000000   NOP
3429:                            res = FR_INVALID_NAME;
9D00641C  24020006   ADDIU V0, ZERO, 6
9D006420  AFC20010   SW V0, 16(S8)
3430:                        if (res == FR_OK) {
9D006424  8FC20010   LW V0, 16(S8)
9D006428  1440002E   BNE V0, ZERO, 0x9D0064E4
9D00642C  00000000   NOP
3431:                            dir = dj.dir;
9D006430  8FC2002C   LW V0, 44(S8)
9D006434  AFC20014   SW V0, 20(S8)
3432:                            if (!dir) { /* Root directory */
9D006438  8FC20014   LW V0, 20(S8)
9D00643C  14400005   BNE V0, ZERO, 0x9D006454
9D006440  00000000   NOP
3433:                                res = FR_INVALID_NAME;
9D006444  24020006   ADDIU V0, ZERO, 6
9D006448  AFC20010   SW V0, 16(S8)
9D00644C  0B401939   J 0x9D0064E4
9D006450  00000000   NOP
3434:                            } else { /* File or sub-directory */
3435:                                ST_WORD(dir + DIR_WrtTime, fno->ftime);
9D006454  8FC20014   LW V0, 20(S8)
9D006458  24420016   ADDIU V0, V0, 22
9D00645C  8FC3004C   LW V1, 76(S8)
9D006460  94630006   LHU V1, 6(V1)
9D006464  306300FF   ANDI V1, V1, 255
9D006468  A0430000   SB V1, 0(V0)
9D00646C  8FC20014   LW V0, 20(S8)
9D006470  24420017   ADDIU V0, V0, 23
9D006474  8FC3004C   LW V1, 76(S8)
9D006478  94630006   LHU V1, 6(V1)
9D00647C  00031A02   SRL V1, V1, 8
9D006480  3063FFFF   ANDI V1, V1, -1
9D006484  306300FF   ANDI V1, V1, 255
9D006488  A0430000   SB V1, 0(V0)
3436:                                ST_WORD(dir + DIR_WrtDate, fno->fdate);
9D00648C  8FC20014   LW V0, 20(S8)
9D006490  24420018   ADDIU V0, V0, 24
9D006494  8FC3004C   LW V1, 76(S8)
9D006498  94630004   LHU V1, 4(V1)
9D00649C  306300FF   ANDI V1, V1, 255
9D0064A0  A0430000   SB V1, 0(V0)
9D0064A4  8FC20014   LW V0, 20(S8)
9D0064A8  24420019   ADDIU V0, V0, 25
9D0064AC  8FC3004C   LW V1, 76(S8)
9D0064B0  94630004   LHU V1, 4(V1)
9D0064B4  00031A02   SRL V1, V1, 8
9D0064B8  3063FFFF   ANDI V1, V1, -1
9D0064BC  306300FF   ANDI V1, V1, 255
9D0064C0  A0430000   SB V1, 0(V0)
3437:                                dj.fs->wflag = 1;
9D0064C4  8FC20018   LW V0, 24(S8)
9D0064C8  24030001   ADDIU V1, ZERO, 1
9D0064CC  A0430004   SB V1, 4(V0)
3438:                                res = sync(dj.fs);
9D0064D0  8FC20018   LW V0, 24(S8)
9D0064D4  00402021   ADDU A0, V0, ZERO
9D0064D8  0F4000F5   JAL 0x9D0003D4
9D0064DC  00000000   NOP
9D0064E0  AFC20010   SW V0, 16(S8)
3439:                            }
3440:                        }
3441:                    }
3442:                
3443:                    LEAVE_FF(dj.fs, res);
9D0064E4  8FC20010   LW V0, 16(S8)
3444:                }
9D0064E8  03C0E821   ADDU SP, S8, ZERO
9D0064EC  8FBF0044   LW RA, 68(SP)
9D0064F0  8FBE0040   LW S8, 64(SP)
9D0064F4  27BD0048   ADDIU SP, SP, 72
9D0064F8  03E00008   JR RA
9D0064FC  00000000   NOP
3445:                
3446:                
3447:                
3448:                
3449:                /*-----------------------------------------------------------------------*/
3450:                /* Rename File/Directory                                                 */
3451:                
3452:                /*-----------------------------------------------------------------------*/
3453:                
3454:                FRESULT f_rename(
3455:                        const TCHAR *path_old, /* Pointer to the old name */
3456:                        const TCHAR *path_new /* Pointer to the new name */
3457:                        ) {
9D006500  27BDFF80   ADDIU SP, SP, -128
9D006504  AFBF007C   SW RA, 124(SP)
9D006508  AFBE0078   SW S8, 120(SP)
9D00650C  03A0F021   ADDU S8, SP, ZERO
9D006510  AFC40080   SW A0, 128(S8)
9D006514  AFC50084   SW A1, 132(S8)
3458:                    FRESULT res;
3459:                    DIR djo, djn;
3460:                    BYTE buf[21], *dir;
3461:                    DWORD dw;
3462:                    DEF_NAMEBUF;
3463:                
3464:                
3465:                    res = chk_mounted(&path_old, &djo.fs, 1);
9D006518  27C2001C   ADDIU V0, S8, 28
9D00651C  27C40080   ADDIU A0, S8, 128
9D006520  00402821   ADDU A1, V0, ZERO
9D006524  24060001   ADDIU A2, ZERO, 1
9D006528  0F400998   JAL 0x9D002660
9D00652C  00000000   NOP
9D006530  AFC20010   SW V0, 16(S8)
3466:                    if (res == FR_OK) {
9D006534  8FC20010   LW V0, 16(S8)
9D006538  144000DC   BNE V0, ZERO, 0x9D0068AC
9D00653C  00000000   NOP
3467:                        djn.fs = djo.fs;
9D006540  8FC2001C   LW V0, 28(S8)
9D006544  AFC20038   SW V0, 56(S8)
3468:                        INIT_BUF(djo);
9D006548  27C2006C   ADDIU V0, S8, 108
9D00654C  AFC20034   SW V0, 52(S8)
3469:                        res = follow_path(&djo, path_old); /* Check old object */
9D006550  8FC20080   LW V0, 128(S8)
9D006554  27C3001C   ADDIU V1, S8, 28
9D006558  00602021   ADDU A0, V1, ZERO
9D00655C  00402821   ADDU A1, V0, ZERO
9D006560  0F400897   JAL 0x9D00225C
9D006564  00000000   NOP
9D006568  AFC20010   SW V0, 16(S8)
3470:                        if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
9D00656C  8FC20010   LW V0, 16(S8)
9D006570  14400009   BNE V0, ZERO, 0x9D006598
9D006574  00000000   NOP
9D006578  8FC20034   LW V0, 52(S8)
9D00657C  2442000B   ADDIU V0, V0, 11
9D006580  90420000   LBU V0, 0(V0)
9D006584  30420020   ANDI V0, V0, 32
9D006588  10400003   BEQ V0, ZERO, 0x9D006598
9D00658C  00000000   NOP
3471:                            res = FR_INVALID_NAME;
9D006590  24020006   ADDIU V0, ZERO, 6
9D006594  AFC20010   SW V0, 16(S8)
3472:                #if _FS_SHARE
3473:                        if (res == FR_OK) res = chk_lock(&djo, 2);
3474:                #endif
3475:                        if (res == FR_OK) { /* Old object is found */
9D006598  8FC20010   LW V0, 16(S8)
9D00659C  144000C3   BNE V0, ZERO, 0x9D0068AC
9D0065A0  00000000   NOP
3476:                            if (!djo.dir) { /* Is root dir? */
9D0065A4  8FC20030   LW V0, 48(S8)
9D0065A8  14400005   BNE V0, ZERO, 0x9D0065C0
9D0065AC  00000000   NOP
3477:                                res = FR_NO_FILE;
9D0065B0  24020004   ADDIU V0, ZERO, 4
9D0065B4  AFC20010   SW V0, 16(S8)
9D0065B8  0B401A2B   J 0x9D0068AC
9D0065BC  00000000   NOP
3478:                            } else {
3479:                                mem_cpy(buf, djo.dir + DIR_Attr, 21); /* Save the object information except for name */
9D0065C0  8FC20030   LW V0, 48(S8)
9D0065C4  2442000B   ADDIU V0, V0, 11
9D0065C8  27C30054   ADDIU V1, S8, 84
9D0065CC  00602021   ADDU A0, V1, ZERO
9D0065D0  00402821   ADDU A1, V0, ZERO
9D0065D4  24060015   ADDIU A2, ZERO, 21
9D0065D8  0F400008   JAL 0x9D000020
9D0065DC  00000000   NOP
3480:                                mem_cpy(&djn, &djo, sizeof (DIR)); /* Check new object */
9D0065E0  27C30038   ADDIU V1, S8, 56
9D0065E4  27C2001C   ADDIU V0, S8, 28
9D0065E8  00602021   ADDU A0, V1, ZERO
9D0065EC  00402821   ADDU A1, V0, ZERO
9D0065F0  2406001C   ADDIU A2, ZERO, 28
9D0065F4  0F400008   JAL 0x9D000020
9D0065F8  00000000   NOP
3481:                                res = follow_path(&djn, path_new);
9D0065FC  27C20038   ADDIU V0, S8, 56
9D006600  00402021   ADDU A0, V0, ZERO
9D006604  8FC50084   LW A1, 132(S8)
9D006608  0F400897   JAL 0x9D00225C
9D00660C  00000000   NOP
9D006610  AFC20010   SW V0, 16(S8)
3482:                                if (res == FR_OK) res = FR_EXIST; /* The new object name is already existing */
9D006614  8FC20010   LW V0, 16(S8)
9D006618  14400003   BNE V0, ZERO, 0x9D006628
9D00661C  00000000   NOP
9D006620  24020008   ADDIU V0, ZERO, 8
9D006624  AFC20010   SW V0, 16(S8)
3483:                                if (res == FR_NO_FILE) { /* Is it a valid path and no name collision? */
9D006628  8FC30010   LW V1, 16(S8)
9D00662C  24020004   ADDIU V0, ZERO, 4
9D006630  1462009E   BNE V1, V0, 0x9D0068AC
9D006634  00000000   NOP
3484:                                    /* Start critical section that any interruption or error can cause cross-link */
3485:                                    res = dir_register(&djn); /* Register the new entry */
9D006638  27C20038   ADDIU V0, S8, 56
9D00663C  00402021   ADDU A0, V0, ZERO
9D006640  0F400665   JAL 0x9D001994
9D006644  00000000   NOP
9D006648  AFC20010   SW V0, 16(S8)
3486:                                    if (res == FR_OK) {
9D00664C  8FC20010   LW V0, 16(S8)
9D006650  14400096   BNE V0, ZERO, 0x9D0068AC
9D006654  00000000   NOP
3487:                                        dir = djn.dir; /* Copy object information except for name */
9D006658  8FC2004C   LW V0, 76(S8)
9D00665C  AFC20014   SW V0, 20(S8)
3488:                                        mem_cpy(dir + 13, buf + 2, 19);
9D006660  8FC20014   LW V0, 20(S8)
9D006664  2443000D   ADDIU V1, V0, 13
9D006668  27C20054   ADDIU V0, S8, 84
9D00666C  24420002   ADDIU V0, V0, 2
9D006670  00602021   ADDU A0, V1, ZERO
9D006674  00402821   ADDU A1, V0, ZERO
9D006678  24060013   ADDIU A2, ZERO, 19
9D00667C  0F400008   JAL 0x9D000020
9D006680  00000000   NOP
3489:                                        dir[DIR_Attr] = buf[0] | AM_ARC;
9D006684  8FC20014   LW V0, 20(S8)
9D006688  2442000B   ADDIU V0, V0, 11
9D00668C  93C30054   LBU V1, 84(S8)
9D006690  34630020   ORI V1, V1, 32
9D006694  306300FF   ANDI V1, V1, 255
9D006698  A0430000   SB V1, 0(V0)
3490:                                        djo.fs->wflag = 1;
9D00669C  8FC2001C   LW V0, 28(S8)
9D0066A0  24030001   ADDIU V1, ZERO, 1
9D0066A4  A0430004   SB V1, 4(V0)
3491:                                        if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) { /* Update .. entry in the directory if needed */
9D0066A8  8FC30024   LW V1, 36(S8)
9D0066AC  8FC20040   LW V0, 64(S8)
9D0066B0  1062006E   BEQ V1, V0, 0x9D00686C
9D0066B4  00000000   NOP
9D0066B8  8FC20014   LW V0, 20(S8)
9D0066BC  2442000B   ADDIU V0, V0, 11
9D0066C0  90420000   LBU V0, 0(V0)
9D0066C4  30420010   ANDI V0, V0, 16
9D0066C8  10400068   BEQ V0, ZERO, 0x9D00686C
9D0066CC  00000000   NOP
3492:                                            dw = clust2sect(djn.fs, LD_CLUST(dir));
9D0066D0  8FC30038   LW V1, 56(S8)
9D0066D4  8FC20014   LW V0, 20(S8)
9D0066D8  24420015   ADDIU V0, V0, 21
9D0066DC  90420000   LBU V0, 0(V0)
9D0066E0  00021200   SLL V0, V0, 8
9D0066E4  7C022620   SEH A0, V0
9D0066E8  8FC20014   LW V0, 20(S8)
9D0066EC  24420014   ADDIU V0, V0, 20
9D0066F0  90420000   LBU V0, 0(V0)
9D0066F4  7C021620   SEH V0, V0
9D0066F8  00821025   OR V0, A0, V0
9D0066FC  7C021620   SEH V0, V0
9D006700  3042FFFF   ANDI V0, V0, -1
9D006704  00022400   SLL A0, V0, 16
9D006708  8FC20014   LW V0, 20(S8)
9D00670C  2442001B   ADDIU V0, V0, 27
9D006710  90420000   LBU V0, 0(V0)
9D006714  00021200   SLL V0, V0, 8
9D006718  7C022E20   SEH A1, V0
9D00671C  8FC20014   LW V0, 20(S8)
9D006720  2442001A   ADDIU V0, V0, 26
9D006724  90420000   LBU V0, 0(V0)
9D006728  7C021620   SEH V0, V0
9D00672C  00A21025   OR V0, A1, V0
9D006730  7C021620   SEH V0, V0
9D006734  3042FFFF   ANDI V0, V0, -1
9D006738  00821025   OR V0, A0, V0
9D00673C  00602021   ADDU A0, V1, ZERO
9D006740  00402821   ADDU A1, V0, ZERO
9D006744  0F400195   JAL clust2sect
9D006748  00000000   NOP
9D00674C  AFC20018   SW V0, 24(S8)
3493:                                            if (!dw) {
9D006750  8FC20018   LW V0, 24(S8)
9D006754  14400005   BNE V0, ZERO, 0x9D00676C
9D006758  00000000   NOP
3494:                                                res = FR_INT_ERR;
9D00675C  24020002   ADDIU V0, ZERO, 2
9D006760  AFC20010   SW V0, 16(S8)
9D006764  0B401A1B   J 0x9D00686C
9D006768  00000000   NOP
3495:                                            } else {
3496:                                                res = move_window(djn.fs, dw);
9D00676C  8FC20038   LW V0, 56(S8)
9D006770  00402021   ADDU A0, V0, ZERO
9D006774  8FC50018   LW A1, 24(S8)
9D006778  0F400090   JAL 0x9D000240
9D00677C  00000000   NOP
9D006780  AFC20010   SW V0, 16(S8)
3497:                                                dir = djn.fs->win + SZ_DIR; /* .. entry */
9D006784  8FC20038   LW V0, 56(S8)
9D006788  24420054   ADDIU V0, V0, 84
9D00678C  AFC20014   SW V0, 20(S8)
3498:                                                if (res == FR_OK && dir[1] == '.') {
9D006790  8FC20010   LW V0, 16(S8)
9D006794  14400035   BNE V0, ZERO, 0x9D00686C
9D006798  00000000   NOP
9D00679C  8FC20014   LW V0, 20(S8)
9D0067A0  24420001   ADDIU V0, V0, 1
9D0067A4  90430000   LBU V1, 0(V0)
9D0067A8  2402002E   ADDIU V0, ZERO, 46
9D0067AC  1462002F   BNE V1, V0, 0x9D00686C
9D0067B0  00000000   NOP
3499:                                                    dw = (djn.fs->fs_type == FS_FAT32 && djn.sclust == djn.fs->dirbase) ? 0 : djn.sclust;
9D0067B4  8FC20038   LW V0, 56(S8)
9D0067B8  90430000   LBU V1, 0(V0)
9D0067BC  24020003   ADDIU V0, ZERO, 3
9D0067C0  14620006   BNE V1, V0, 0x9D0067DC
9D0067C4  00000000   NOP
9D0067C8  8FC30040   LW V1, 64(S8)
9D0067CC  8FC20038   LW V0, 56(S8)
9D0067D0  8C420028   LW V0, 40(V0)
9D0067D4  10620004   BEQ V1, V0, 0x9D0067E8
9D0067D8  00000000   NOP
9D0067DC  8FC20040   LW V0, 64(S8)
9D0067E0  0B4019FB   J 0x9D0067EC
9D0067E4  00000000   NOP
9D0067E8  00001021   ADDU V0, ZERO, ZERO
9D0067EC  AFC20018   SW V0, 24(S8)
3500:                                                    ST_CLUST(dir, dw);
9D0067F0  8FC20014   LW V0, 20(S8)
9D0067F4  2442001A   ADDIU V0, V0, 26
9D0067F8  8FC30018   LW V1, 24(S8)
9D0067FC  306300FF   ANDI V1, V1, 255
9D006800  A0430000   SB V1, 0(V0)
9D006804  8FC20014   LW V0, 20(S8)
9D006808  2442001B   ADDIU V0, V0, 27
9D00680C  8FC30018   LW V1, 24(S8)
9D006810  3063FFFF   ANDI V1, V1, -1
9D006814  00031A02   SRL V1, V1, 8
9D006818  3063FFFF   ANDI V1, V1, -1
9D00681C  306300FF   ANDI V1, V1, 255
9D006820  A0430000   SB V1, 0(V0)
9D006824  8FC20014   LW V0, 20(S8)
9D006828  24420014   ADDIU V0, V0, 20
9D00682C  8FC30018   LW V1, 24(S8)
9D006830  00031C02   SRL V1, V1, 16
9D006834  306300FF   ANDI V1, V1, 255
9D006838  A0430000   SB V1, 0(V0)
9D00683C  8FC20014   LW V0, 20(S8)
9D006840  24420015   ADDIU V0, V0, 21
9D006844  8FC30018   LW V1, 24(S8)
9D006848  00031C02   SRL V1, V1, 16
9D00684C  3063FFFF   ANDI V1, V1, -1
9D006850  00031A02   SRL V1, V1, 8
9D006854  3063FFFF   ANDI V1, V1, -1
9D006858  306300FF   ANDI V1, V1, 255
9D00685C  A0430000   SB V1, 0(V0)
3501:                                                    djn.fs->wflag = 1;
9D006860  8FC20038   LW V0, 56(S8)
9D006864  24030001   ADDIU V1, ZERO, 1
9D006868  A0430004   SB V1, 4(V0)
3502:                                                }
3503:                                            }
3504:                                        }
3505:                                        if (res == FR_OK) {
9D00686C  8FC20010   LW V0, 16(S8)
9D006870  1440000E   BNE V0, ZERO, 0x9D0068AC
9D006874  00000000   NOP
3506:                                            res = dir_remove(&djo); /* Remove old entry */
9D006878  27C2001C   ADDIU V0, S8, 28
9D00687C  00402021   ADDU A0, V0, ZERO
9D006880  0F4006BD   JAL 0x9D001AF4
9D006884  00000000   NOP
9D006888  AFC20010   SW V0, 16(S8)
3507:                                            if (res == FR_OK)
9D00688C  8FC20010   LW V0, 16(S8)
9D006890  14400006   BNE V0, ZERO, 0x9D0068AC
9D006894  00000000   NOP
3508:                                                res = sync(djo.fs);
9D006898  8FC2001C   LW V0, 28(S8)
9D00689C  00402021   ADDU A0, V0, ZERO
9D0068A0  0F4000F5   JAL 0x9D0003D4
9D0068A4  00000000   NOP
9D0068A8  AFC20010   SW V0, 16(S8)
3509:                                        }
3510:                                    }
3511:                                    /* End critical section */
3512:                                }
3513:                            }
3514:                        }
3515:                        FREE_BUF();
3516:                    }
3517:                    LEAVE_FF(djo.fs, res);
9D0068AC  8FC20010   LW V0, 16(S8)
3518:                }
9D0068B0  03C0E821   ADDU SP, S8, ZERO
9D0068B4  8FBF007C   LW RA, 124(SP)
9D0068B8  8FBE0078   LW S8, 120(SP)
9D0068BC  27BD0080   ADDIU SP, SP, 128
9D0068C0  03E00008   JR RA
9D0068C4  00000000   NOP
3519:                
3520:                #endif /* !_FS_READONLY */
3521:                #endif /* _FS_MINIMIZE == 0 */
3522:                #endif /* _FS_MINIMIZE <= 1 */
3523:                #endif /* _FS_MINIMIZE <= 2 */
3524:                
3525:                
3526:                
3527:                /*-----------------------------------------------------------------------*/
3528:                /* Forward data to the stream directly (available on only tiny cfg)      */
3529:                /*-----------------------------------------------------------------------*/
3530:                #if _USE_FORWARD && _FS_TINY
3531:                
3532:                FRESULT f_forward(
3533:                        FIL *fp, /* Pointer to the file object */
3534:                        UINT(*func)(const BYTE*, UINT), /* Pointer to the streaming function */
3535:                        UINT btr, /* Number of bytes to forward */
3536:                        UINT *bf /* Pointer to number of bytes forwarded */
3537:                        ) {
3538:                    FRESULT res;
3539:                    DWORD remain, clst, sect;
3540:                    UINT rcnt;
3541:                    BYTE csect;
3542:                
3543:                
3544:                    *bf = 0; /* Initialize byte counter */
3545:                
3546:                    res = validate(fp->fs, fp->id); /* Check validity of the object */
3547:                    if (res != FR_OK) LEAVE_FF(fp->fs, res);
3548:                    if (fp->flag & FA__ERROR) /* Check error flag */
3549:                        LEAVE_FF(fp->fs, FR_INT_ERR);
3550:                    if (!(fp->flag & FA_READ)) /* Check access mode */
3551:                        LEAVE_FF(fp->fs, FR_DENIED);
3552:                
3553:                    remain = fp->fsize - fp->fptr;
3554:                    if (btr > remain) btr = (UINT) remain; /* Truncate btr by remaining bytes */
3555:                
3556:                    for (; btr && (*func)(0, 0); /* Repeat until all data transferred or stream becomes busy */
3557:                            fp->fptr += rcnt, *bf += rcnt, btr -= rcnt) {
3558:                        csect = (BYTE) (fp->fptr / SS(fp->fs) & (fp->fs->csize - 1)); /* Sector offset in the cluster */
3559:                        if ((fp->fptr % SS(fp->fs)) == 0) { /* On the sector boundary? */
3560:                            if (!csect) { /* On the cluster boundary? */
3561:                                clst = (fp->fptr == 0) ? /* On the top of the file? */
3562:                                        fp->sclust : get_fat(fp->fs, fp->clust);
3563:                                if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
3564:                                if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
3565:                                fp->clust = clst; /* Update current cluster */
3566:                            }
3567:                        }
3568:                        sect = clust2sect(fp->fs, fp->clust); /* Get current data sector */
3569:                        if (!sect) ABORT(fp->fs, FR_INT_ERR);
3570:                        sect += csect;
3571:                        if (move_window(fp->fs, sect)) /* Move sector window */
3572:                            ABORT(fp->fs, FR_DISK_ERR);
3573:                        fp->dsect = sect;
3574:                        rcnt = SS(fp->fs) - (WORD) (fp->fptr % SS(fp->fs)); /* Forward data from sector window */
3575:                        if (rcnt > btr) rcnt = btr;
3576:                        rcnt = (*func)(&fp->fs->win[(WORD) fp->fptr % SS(fp->fs)], rcnt);
3577:                        if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
3578:                    }
3579:                
3580:                    LEAVE_FF(fp->fs, FR_OK);
3581:                }
3582:                #endif /* _USE_FORWARD */
3583:                
3584:                
3585:                
3586:                #if _USE_MKFS && !_FS_READONLY
3587:                /*-----------------------------------------------------------------------*/
3588:                /* Create File System on the Drive                                       */
3589:                /*-----------------------------------------------------------------------*/
3590:                #define N_ROOTDIR	512		/* Number of root dir entries for FAT12/16 */
3591:                #define N_FATS		1		/* Number of FAT copies (1 or 2) */
3592:                
3593:                FRESULT f_mkfs(
3594:                        BYTE drv, /* Logical drive number */
3595:                        BYTE sfd, /* Partitioning rule 0:FDISK, 1:SFD */
3596:                        UINT au /* Allocation unit size [bytes] */
3597:                        ) {
9D0068C8  27BDFFA0   ADDIU SP, SP, -96
9D0068CC  AFBF005C   SW RA, 92(SP)
9D0068D0  AFBE0058   SW S8, 88(SP)
9D0068D4  03A0F021   ADDU S8, SP, ZERO
9D0068D8  00801821   ADDU V1, A0, ZERO
9D0068DC  00A01021   ADDU V0, A1, ZERO
9D0068E0  AFC60068   SW A2, 104(S8)
9D0068E4  A3C30060   SB V1, 96(S8)
9D0068E8  A3C20064   SB V0, 100(S8)
3598:                    static const WORD vst[] = {1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 0};
3599:                    static const WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
3600:                    BYTE fmt, md, sys, *tbl, pdrv, part;
3601:                    DWORD n_clst, vs, n, wsect;
3602:                    UINT i;
3603:                    DWORD b_vol, b_fat, b_dir, b_data; /* LBA */
3604:                    DWORD n_vol, n_rsv, n_fat, n_dir; /* Size */
3605:                    FATFS *fs;
3606:                    DSTATUS stat;
3607:                
3608:                
3609:                    /* Check mounted drive and clear work area */
3610:                    if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
9D0068EC  93C20060   LBU V0, 96(S8)
9D0068F0  10400004   BEQ V0, ZERO, 0x9D006904
9D0068F4  00000000   NOP
9D0068F8  2402000B   ADDIU V0, ZERO, 11
9D0068FC  0B401E93   J 0x9D007A4C
9D006900  00000000   NOP
3611:                    if (sfd > 1) return FR_INVALID_PARAMETER;
9D006904  93C20064   LBU V0, 100(S8)
9D006908  2C420002   SLTIU V0, V0, 2
9D00690C  14400004   BNE V0, ZERO, 0x9D006920
9D006910  00000000   NOP
9D006914  24020013   ADDIU V0, ZERO, 19
9D006918  0B401E93   J 0x9D007A4C
9D00691C  00000000   NOP
3612:                    if (au & (au - 1)) return FR_INVALID_PARAMETER;
9D006920  8FC20068   LW V0, 104(S8)
9D006924  2443FFFF   ADDIU V1, V0, -1
9D006928  8FC20068   LW V0, 104(S8)
9D00692C  00621024   AND V0, V1, V0
9D006930  10400004   BEQ V0, ZERO, 0x9D006944
9D006934  00000000   NOP
9D006938  24020013   ADDIU V0, ZERO, 19
9D00693C  0B401E93   J 0x9D007A4C
9D006940  00000000   NOP
3613:                    fs = FatFs[drv];
9D006944  93C20060   LBU V0, 96(S8)
9D006948  00021880   SLL V1, V0, 2
9D00694C  27828058   ADDIU V0, GP, -32680
9D006950  00621021   ADDU V0, V1, V0
9D006954  8C420000   LW V0, 0(V0)
9D006958  AFC2002C   SW V0, 44(S8)
3614:                    if (!fs) return FR_NOT_ENABLED;
9D00695C  8FC2002C   LW V0, 44(S8)
9D006960  14400004   BNE V0, ZERO, 0x9D006974
9D006964  00000000   NOP
9D006968  2402000C   ADDIU V0, ZERO, 12
9D00696C  0B401E93   J 0x9D007A4C
9D006970  00000000   NOP
3615:                    fs->fs_type = 0;
9D006974  8FC2002C   LW V0, 44(S8)
9D006978  A0400000   SB ZERO, 0(V0)
3616:                    pdrv = LD2PD(drv); /* Physical drive */
9D00697C  93C20060   LBU V0, 96(S8)
9D006980  A3C20030   SB V0, 48(S8)
3617:                    part = LD2PT(drv); /* Partition (0:auto detect, 1-4:get from partition table)*/
9D006984  A3C00031   SB ZERO, 49(S8)
3618:                
3619:                    /* Get disk statics */
3620:                    stat = disk_initialize(pdrv);
9D006988  93C20030   LBU V0, 48(S8)
9D00698C  00402021   ADDU A0, V0, ZERO
9D006990  0F402045   JAL disk_initialize
9D006994  00000000   NOP
9D006998  A3C20032   SB V0, 50(S8)
3621:                    if (stat & STA_NOINIT) return FR_NOT_READY;
9D00699C  93C20032   LBU V0, 50(S8)
9D0069A0  30420001   ANDI V0, V0, 1
9D0069A4  304200FF   ANDI V0, V0, 255
9D0069A8  10400004   BEQ V0, ZERO, 0x9D0069BC
9D0069AC  00000000   NOP
9D0069B0  24020003   ADDIU V0, ZERO, 3
9D0069B4  0B401E93   J 0x9D007A4C
9D0069B8  00000000   NOP
3622:                    if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
9D0069BC  93C20032   LBU V0, 50(S8)
9D0069C0  30420004   ANDI V0, V0, 4
9D0069C4  10400004   BEQ V0, ZERO, 0x9D0069D8
9D0069C8  00000000   NOP
9D0069CC  2402000A   ADDIU V0, ZERO, 10
9D0069D0  0B401E93   J 0x9D007A4C
9D0069D4  00000000   NOP
3623:                #if _MAX_SS != 512					/* Get disk sector size */
3624:                    if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
3625:                        return FR_DISK_ERR;
3626:                #endif
3627:                    if (_MULTI_PARTITION && part) {
3628:                        /* Get partition information from partition table in the MBR */
3629:                        if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
3630:                        if (LD_WORD(fs->win + BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
3631:                        tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
3632:                        if (!tbl[4]) return FR_MKFS_ABORTED; /* No partition? */
3633:                        b_vol = LD_DWORD(tbl + 8); /* Volume start sector */
3634:                        n_vol = LD_DWORD(tbl + 12); /* Volume size */
3635:                    } else {
3636:                        /* Create a partition in this function */
3637:                        if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
9D0069D8  93C30030   LBU V1, 48(S8)
9D0069DC  27C20050   ADDIU V0, S8, 80
9D0069E0  00602021   ADDU A0, V1, ZERO
9D0069E4  24050001   ADDIU A1, ZERO, 1
9D0069E8  00403021   ADDU A2, V0, ZERO
9D0069EC  0F4021FD   JAL disk_ioctl
9D0069F0  00000000   NOP
9D0069F4  14400005   BNE V0, ZERO, 0x9D006A0C
9D0069F8  00000000   NOP
9D0069FC  8FC20050   LW V0, 80(S8)
9D006A00  2C420080   SLTIU V0, V0, 128
9D006A04  10400004   BEQ V0, ZERO, 0x9D006A18
9D006A08  00000000   NOP
3638:                            return FR_DISK_ERR;
9D006A0C  24020001   ADDIU V0, ZERO, 1
9D006A10  0B401E93   J 0x9D007A4C
9D006A14  00000000   NOP
3639:                        b_vol = (sfd) ? 0 : 63; /* Volume start sector */
9D006A18  93C20064   LBU V0, 100(S8)
9D006A1C  10400004   BEQ V0, ZERO, 0x9D006A30
9D006A20  00000000   NOP
9D006A24  00001021   ADDU V0, ZERO, ZERO
9D006A28  0B401A8D   J 0x9D006A34
9D006A2C  00000000   NOP
9D006A30  2402003F   ADDIU V0, ZERO, 63
9D006A34  AFC20034   SW V0, 52(S8)
3640:                        n_vol -= b_vol; /* Volume size */
9D006A38  8FC30050   LW V1, 80(S8)
9D006A3C  8FC20034   LW V0, 52(S8)
9D006A40  00621023   SUBU V0, V1, V0
9D006A44  AFC20050   SW V0, 80(S8)
3641:                    }
3642:                
3643:                    if (!au) { /* AU auto selection */
9D006A48  8FC20068   LW V0, 104(S8)
9D006A4C  14400021   BNE V0, ZERO, 0x9D006AD4
9D006A50  00000000   NOP
3644:                        vs = n_vol / (2000 / (SS(fs) / 512));
9D006A54  8FC30050   LW V1, 80(S8)
9D006A58  3C021062   LUI V0, 4194
9D006A5C  34424DD3   ORI V0, V0, 19923
9D006A60  00620019   MULTU V1, V0
9D006A64  00001012   MFLO V0
9D006A68  00001810   MFHI V1
9D006A6C  000311C2   SRL V0, V1, 7
9D006A70  AFC20038   SW V0, 56(S8)
3645:                        for (i = 0; vs < vst[i]; i++);
9D006A74  AFC00018   SW ZERO, 24(S8)
9D006A78  0B401AA3   J 0x9D006A8C
9D006A7C  00000000   NOP
9D006A80  8FC20018   LW V0, 24(S8)
9D006A84  24420001   ADDIU V0, V0, 1
9D006A88  AFC20018   SW V0, 24(S8)
9D006A8C  3C029D01   LUI V0, -25343
9D006A90  8FC30018   LW V1, 24(S8)
9D006A94  00031840   SLL V1, V1, 1
9D006A98  2442CD44   ADDIU V0, V0, -12988
9D006A9C  00621021   ADDU V0, V1, V0
9D006AA0  94420000   LHU V0, 0(V0)
9D006AA4  00401821   ADDU V1, V0, ZERO
9D006AA8  8FC20038   LW V0, 56(S8)
9D006AAC  0043102B   SLTU V0, V0, V1
9D006AB0  1440FFF3   BNE V0, ZERO, 0x9D006A80
9D006AB4  00000000   NOP
3646:                        au = cst[i];
9D006AB8  3C029D01   LUI V0, -25343
9D006ABC  8FC30018   LW V1, 24(S8)
9D006AC0  00031840   SLL V1, V1, 1
9D006AC4  2442CD5C   ADDIU V0, V0, -12964
9D006AC8  00621021   ADDU V0, V1, V0
9D006ACC  94420000   LHU V0, 0(V0)
9D006AD0  AFC20068   SW V0, 104(S8)
3647:                    }
3648:                    au /= SS(fs); /* Number of sectors per cluster */
9D006AD4  8FC20068   LW V0, 104(S8)
9D006AD8  00021242   SRL V0, V0, 9
9D006ADC  AFC20068   SW V0, 104(S8)
3649:                    if (au == 0) au = 1;
9D006AE0  8FC20068   LW V0, 104(S8)
9D006AE4  14400003   BNE V0, ZERO, 0x9D006AF4
9D006AE8  00000000   NOP
9D006AEC  24020001   ADDIU V0, ZERO, 1
9D006AF0  AFC20068   SW V0, 104(S8)
3650:                    if (au > 128) au = 128;
9D006AF4  8FC20068   LW V0, 104(S8)
9D006AF8  2C420081   SLTIU V0, V0, 129
9D006AFC  14400003   BNE V0, ZERO, 0x9D006B0C
9D006B00  00000000   NOP
9D006B04  24020080   ADDIU V0, ZERO, 128
9D006B08  AFC20068   SW V0, 104(S8)
3651:                
3652:                    /* Pre-compute number of clusters and FAT syb-type */
3653:                    n_clst = n_vol / au;
9D006B0C  8FC30050   LW V1, 80(S8)
9D006B10  8FC20068   LW V0, 104(S8)
9D006B14  0062001B   DIVU V1, V0
9D006B18  004001F4   TEQ V0, ZERO
9D006B1C  00001810   MFHI V1
9D006B20  00001012   MFLO V0
9D006B24  AFC2003C   SW V0, 60(S8)
3654:                    fmt = FS_FAT12;
9D006B28  24020001   ADDIU V0, ZERO, 1
9D006B2C  A3C20010   SB V0, 16(S8)
3655:                    if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
9D006B30  8FC2003C   LW V0, 60(S8)
9D006B34  2C420FF6   SLTIU V0, V0, 4086
9D006B38  14400003   BNE V0, ZERO, 0x9D006B48
9D006B3C  00000000   NOP
9D006B40  24020002   ADDIU V0, ZERO, 2
9D006B44  A3C20010   SB V0, 16(S8)
3656:                    if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
9D006B48  8FC3003C   LW V1, 60(S8)
9D006B4C  3402FFF6   ORI V0, ZERO, -10
9D006B50  0062102B   SLTU V0, V1, V0
9D006B54  14400003   BNE V0, ZERO, 0x9D006B64
9D006B58  00000000   NOP
9D006B5C  24020003   ADDIU V0, ZERO, 3
9D006B60  A3C20010   SB V0, 16(S8)
3657:                
3658:                    /* Determine offset and size of FAT structure */
3659:                    if (fmt == FS_FAT32) {
9D006B64  93C30010   LBU V1, 16(S8)
9D006B68  24020003   ADDIU V0, ZERO, 3
9D006B6C  1462000C   BNE V1, V0, 0x9D006BA0
9D006B70  00000000   NOP
3660:                        n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
9D006B74  8FC2003C   LW V0, 60(S8)
9D006B78  24420082   ADDIU V0, V0, 130
9D006B7C  00021080   SLL V0, V0, 2
9D006B80  2442FFFF   ADDIU V0, V0, -1
9D006B84  00021242   SRL V0, V0, 9
9D006B88  AFC20024   SW V0, 36(S8)
3661:                        n_rsv = 32;
9D006B8C  24020020   ADDIU V0, ZERO, 32
9D006B90  AFC20020   SW V0, 32(S8)
3662:                        n_dir = 0;
9D006B94  AFC00028   SW ZERO, 40(S8)
9D006B98  0B401B00   J 0x9D006C00
9D006B9C  00000000   NOP
3663:                    } else {
3664:                        n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
9D006BA0  93C30010   LBU V1, 16(S8)
9D006BA4  24020001   ADDIU V0, ZERO, 1
9D006BA8  14620009   BNE V1, V0, 0x9D006BD0
9D006BAC  00000000   NOP
9D006BB0  8FC3003C   LW V1, 60(S8)
9D006BB4  24020003   ADDIU V0, ZERO, 3
9D006BB8  70621002   MUL V0, V1, V0
9D006BBC  24420001   ADDIU V0, V0, 1
9D006BC0  00021042   SRL V0, V0, 1
9D006BC4  24420003   ADDIU V0, V0, 3
9D006BC8  0B401AF7   J 0x9D006BDC
9D006BCC  00000000   NOP
9D006BD0  8FC2003C   LW V0, 60(S8)
9D006BD4  24420002   ADDIU V0, V0, 2
9D006BD8  00021040   SLL V0, V0, 1
9D006BDC  AFC20024   SW V0, 36(S8)
3665:                        n_fat = (n_fat + SS(fs) - 1) / SS(fs);
9D006BE0  8FC20024   LW V0, 36(S8)
9D006BE4  244201FF   ADDIU V0, V0, 511
9D006BE8  00021242   SRL V0, V0, 9
9D006BEC  AFC20024   SW V0, 36(S8)
3666:                        n_rsv = 1;
9D006BF0  24020001   ADDIU V0, ZERO, 1
9D006BF4  AFC20020   SW V0, 32(S8)
3667:                        n_dir = (DWORD) N_ROOTDIR * SZ_DIR / SS(fs);
9D006BF8  24020020   ADDIU V0, ZERO, 32
9D006BFC  AFC20028   SW V0, 40(S8)
3668:                    }
3669:                    b_fat = b_vol + n_rsv; /* FAT area start sector */
9D006C00  8FC30034   LW V1, 52(S8)
9D006C04  8FC20020   LW V0, 32(S8)
9D006C08  00621021   ADDU V0, V1, V0
9D006C0C  AFC2001C   SW V0, 28(S8)
3670:                    b_dir = b_fat + n_fat * N_FATS; /* Directory area start sector */
9D006C10  8FC3001C   LW V1, 28(S8)
9D006C14  8FC20024   LW V0, 36(S8)
9D006C18  00621021   ADDU V0, V1, V0
9D006C1C  AFC20040   SW V0, 64(S8)
3671:                    b_data = b_dir + n_dir; /* Data area start sector */
9D006C20  8FC30040   LW V1, 64(S8)
9D006C24  8FC20028   LW V0, 40(S8)
9D006C28  00621021   ADDU V0, V1, V0
9D006C2C  AFC20044   SW V0, 68(S8)
3672:                    if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED; /* Too small volume */
9D006C30  8FC30044   LW V1, 68(S8)
9D006C34  8FC20068   LW V0, 104(S8)
9D006C38  00621821   ADDU V1, V1, V0
9D006C3C  8FC20034   LW V0, 52(S8)
9D006C40  00621823   SUBU V1, V1, V0
9D006C44  8FC20050   LW V0, 80(S8)
9D006C48  0043102B   SLTU V0, V0, V1
9D006C4C  10400004   BEQ V0, ZERO, 0x9D006C60
9D006C50  00000000   NOP
9D006C54  2402000E   ADDIU V0, ZERO, 14
9D006C58  0B401E93   J 0x9D007A4C
9D006C5C  00000000   NOP
3673:                
3674:                    /* Align data start sector to erase block boundary (for flash memory media) */
3675:                    if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
9D006C60  93C30030   LBU V1, 48(S8)
9D006C64  27C2004C   ADDIU V0, S8, 76
9D006C68  00602021   ADDU A0, V1, ZERO
9D006C6C  24050003   ADDIU A1, ZERO, 3
9D006C70  00403021   ADDU A2, V0, ZERO
9D006C74  0F4021FD   JAL disk_ioctl
9D006C78  00000000   NOP
9D006C7C  14400009   BNE V0, ZERO, 0x9D006CA4
9D006C80  00000000   NOP
9D006C84  8FC2004C   LW V0, 76(S8)
9D006C88  10400006   BEQ V0, ZERO, 0x9D006CA4
9D006C8C  00000000   NOP
9D006C90  8FC3004C   LW V1, 76(S8)
9D006C94  34028001   ORI V0, ZERO, -32767
9D006C98  0062102B   SLTU V0, V1, V0
9D006C9C  14400003   BNE V0, ZERO, 0x9D006CAC
9D006CA0  00000000   NOP
9D006CA4  24020001   ADDIU V0, ZERO, 1
9D006CA8  AFC2004C   SW V0, 76(S8)
3676:                    n = (b_data + n - 1) & ~(n - 1); /* Next nearest erase block from current data start */
9D006CAC  8FC3004C   LW V1, 76(S8)
9D006CB0  8FC20044   LW V0, 68(S8)
9D006CB4  00621021   ADDU V0, V1, V0
9D006CB8  2443FFFF   ADDIU V1, V0, -1
9D006CBC  8FC2004C   LW V0, 76(S8)
9D006CC0  00021023   SUBU V0, ZERO, V0
9D006CC4  00621024   AND V0, V1, V0
9D006CC8  AFC2004C   SW V0, 76(S8)
3677:                    n = (n - b_data) / N_FATS;
9D006CCC  8FC3004C   LW V1, 76(S8)
9D006CD0  8FC20044   LW V0, 68(S8)
9D006CD4  00621023   SUBU V0, V1, V0
9D006CD8  AFC2004C   SW V0, 76(S8)
3678:                    if (fmt == FS_FAT32) { /* FAT32: Move FAT offset */
9D006CDC  93C30010   LBU V1, 16(S8)
9D006CE0  24020003   ADDIU V0, ZERO, 3
9D006CE4  1462000B   BNE V1, V0, 0x9D006D14
9D006CE8  00000000   NOP
3679:                        n_rsv += n;
9D006CEC  8FC2004C   LW V0, 76(S8)
9D006CF0  8FC30020   LW V1, 32(S8)
9D006CF4  00621021   ADDU V0, V1, V0
9D006CF8  AFC20020   SW V0, 32(S8)
3680:                        b_fat += n;
9D006CFC  8FC2004C   LW V0, 76(S8)
9D006D00  8FC3001C   LW V1, 28(S8)
9D006D04  00621021   ADDU V0, V1, V0
9D006D08  AFC2001C   SW V0, 28(S8)
9D006D0C  0B401B49   J 0x9D006D24
9D006D10  00000000   NOP
3681:                    } else { /* FAT12/16: Expand FAT size */
3682:                        n_fat += n;
9D006D14  8FC2004C   LW V0, 76(S8)
9D006D18  8FC30024   LW V1, 36(S8)
9D006D1C  00621021   ADDU V0, V1, V0
9D006D20  AFC20024   SW V0, 36(S8)
3683:                    }
3684:                
3685:                    /* Determine number of clusters and final check of validity of the FAT sub-type */
3686:                    n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
9D006D24  8FC30050   LW V1, 80(S8)
9D006D28  8FC20020   LW V0, 32(S8)
9D006D2C  00621823   SUBU V1, V1, V0
9D006D30  8FC20024   LW V0, 36(S8)
9D006D34  00621823   SUBU V1, V1, V0
9D006D38  8FC20028   LW V0, 40(S8)
9D006D3C  00621823   SUBU V1, V1, V0
9D006D40  8FC20068   LW V0, 104(S8)
9D006D44  0062001B   DIVU V1, V0
9D006D48  004001F4   TEQ V0, ZERO
9D006D4C  00001810   MFHI V1
9D006D50  00001012   MFLO V0
9D006D54  AFC2003C   SW V0, 60(S8)
3687:                    if ((fmt == FS_FAT16 && n_clst < MIN_FAT16)
9D006D58  93C30010   LBU V1, 16(S8)
9D006D5C  24020002   ADDIU V0, ZERO, 2
9D006D60  14620005   BNE V1, V0, 0x9D006D78
9D006D64  00000000   NOP
9D006D68  8FC2003C   LW V0, 60(S8)
9D006D6C  2C420FF6   SLTIU V0, V0, 4086
9D006D70  1440000A   BNE V0, ZERO, 0x9D006D9C
9D006D74  00000000   NOP
3688:                            || (fmt == FS_FAT32 && n_clst < MIN_FAT32))
9D006D78  93C30010   LBU V1, 16(S8)
9D006D7C  24020003   ADDIU V0, ZERO, 3
9D006D80  14620009   BNE V1, V0, 0x9D006DA8
9D006D84  00000000   NOP
9D006D88  8FC3003C   LW V1, 60(S8)
9D006D8C  3402FFF6   ORI V0, ZERO, -10
9D006D90  0062102B   SLTU V0, V1, V0
9D006D94  10400004   BEQ V0, ZERO, 0x9D006DA8
9D006D98  00000000   NOP
3689:                        return FR_MKFS_ABORTED;
9D006D9C  2402000E   ADDIU V0, ZERO, 14
9D006DA0  0B401E93   J 0x9D007A4C
9D006DA4  00000000   NOP
3690:                
3691:                    switch (fmt) { /* Determine system ID for partition table */
9D006DA8  93C20010   LBU V0, 16(S8)
9D006DAC  24030001   ADDIU V1, ZERO, 1
9D006DB0  10430006   BEQ V0, V1, 0x9D006DCC
9D006DB4  00000000   NOP
9D006DB8  24030002   ADDIU V1, ZERO, 2
9D006DBC  10430007   BEQ V0, V1, 0x9D006DDC
9D006DC0  00000000   NOP
9D006DC4  0B401B83   J 0x9D006E0C
9D006DC8  00000000   NOP
3692:                        case FS_FAT12: sys = 0x01;
9D006DCC  24020001   ADDIU V0, ZERO, 1
9D006DD0  A3C20012   SB V0, 18(S8)
3693:                            break;
9D006DD4  0B401B85   J 0x9D006E14
9D006DD8  00000000   NOP
3694:                        case FS_FAT16: sys = (n_vol < 0x10000) ? 0x04: 0x06;
9D006DDC  8FC30050   LW V1, 80(S8)
9D006DE0  3C020001   LUI V0, 1
9D006DE4  0062102B   SLTU V0, V1, V0
9D006DE8  10400004   BEQ V0, ZERO, 0x9D006DFC
9D006DEC  00000000   NOP
9D006DF0  24020004   ADDIU V0, ZERO, 4
9D006DF4  0B401B80   J 0x9D006E00
9D006DF8  00000000   NOP
9D006DFC  24020006   ADDIU V0, ZERO, 6
9D006E00  A3C20012   SB V0, 18(S8)
3695:                            break;
9D006E04  0B401B85   J 0x9D006E14
9D006E08  00000000   NOP
3696:                        default: sys = 0x0C;
9D006E0C  2402000C   ADDIU V0, ZERO, 12
9D006E10  A3C20012   SB V0, 18(S8)
3697:                    }
3698:                
3699:                    if (_MULTI_PARTITION && part) {
3700:                        /* Update system ID in the partition table */
3701:                        tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
3702:                        tbl[4] = sys;
3703:                        if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
3704:                        md = 0xF8;
3705:                    } else {
3706:                        if (sfd) { /* No patition table (SFD) */
9D006E14  93C20064   LBU V0, 100(S8)
9D006E18  10400005   BEQ V0, ZERO, 0x9D006E30
9D006E1C  00000000   NOP
3707:                            md = 0xF0;
9D006E20  2402FFF0   ADDIU V0, ZERO, -16
9D006E24  A3C20011   SB V0, 17(S8)
9D006E28  0B401BFD   J 0x9D006FF4
9D006E2C  00000000   NOP
3708:                        } else { /* Create partition table (FDISK) */
3709:                            mem_set(fs->win, 0, SS(fs));
9D006E30  8FC2002C   LW V0, 44(S8)
9D006E34  24420034   ADDIU V0, V0, 52
9D006E38  00402021   ADDU A0, V0, ZERO
9D006E3C  00002821   ADDU A1, ZERO, ZERO
9D006E40  24060200   ADDIU A2, ZERO, 512
9D006E44  0F40002B   JAL 0x9D0000AC
9D006E48  00000000   NOP
3710:                            tbl = fs->win + MBR_Table; /* Create partiton table for single partition in the drive */
9D006E4C  8FC2002C   LW V0, 44(S8)
9D006E50  244201F2   ADDIU V0, V0, 498
9D006E54  AFC20048   SW V0, 72(S8)
3711:                            tbl[1] = 1; /* Partition start head */
9D006E58  8FC20048   LW V0, 72(S8)
9D006E5C  24420001   ADDIU V0, V0, 1
9D006E60  24030001   ADDIU V1, ZERO, 1
9D006E64  A0430000   SB V1, 0(V0)
3712:                            tbl[2] = 1; /* Partition start sector */
9D006E68  8FC20048   LW V0, 72(S8)
9D006E6C  24420002   ADDIU V0, V0, 2
9D006E70  24030001   ADDIU V1, ZERO, 1
9D006E74  A0430000   SB V1, 0(V0)
3713:                            tbl[3] = 0; /* Partition start cylinder */
9D006E78  8FC20048   LW V0, 72(S8)
9D006E7C  24420003   ADDIU V0, V0, 3
9D006E80  A0400000   SB ZERO, 0(V0)
3714:                            tbl[4] = sys; /* System type */
9D006E84  8FC20048   LW V0, 72(S8)
9D006E88  24420004   ADDIU V0, V0, 4
9D006E8C  93C30012   LBU V1, 18(S8)
9D006E90  A0430000   SB V1, 0(V0)
3715:                            tbl[5] = 254; /* Partition end head */
9D006E94  8FC20048   LW V0, 72(S8)
9D006E98  24420005   ADDIU V0, V0, 5
9D006E9C  2403FFFE   ADDIU V1, ZERO, -2
9D006EA0  A0430000   SB V1, 0(V0)
3716:                            n = (b_vol + n_vol) / 63 / 255;
9D006EA4  8FC30050   LW V1, 80(S8)
9D006EA8  8FC20034   LW V0, 52(S8)
9D006EAC  00621821   ADDU V1, V1, V0
9D006EB0  24023EC1   ADDIU V0, ZERO, 16065
9D006EB4  0062001B   DIVU V1, V0
9D006EB8  004001F4   TEQ V0, ZERO
9D006EBC  00001810   MFHI V1
9D006EC0  00001012   MFLO V0
9D006EC4  AFC2004C   SW V0, 76(S8)
3717:                            tbl[6] = (BYTE) ((n >> 2) | 63); /* Partiiton end sector */
9D006EC8  8FC20048   LW V0, 72(S8)
9D006ECC  24420006   ADDIU V0, V0, 6
9D006ED0  8FC3004C   LW V1, 76(S8)
9D006ED4  00031882   SRL V1, V1, 2
9D006ED8  306300FF   ANDI V1, V1, 255
9D006EDC  3463003F   ORI V1, V1, 63
9D006EE0  306300FF   ANDI V1, V1, 255
9D006EE4  A0430000   SB V1, 0(V0)
3718:                            tbl[7] = (BYTE) n; /* End cylinder */
9D006EE8  8FC20048   LW V0, 72(S8)
9D006EEC  24420007   ADDIU V0, V0, 7
9D006EF0  8FC3004C   LW V1, 76(S8)
9D006EF4  306300FF   ANDI V1, V1, 255
9D006EF8  A0430000   SB V1, 0(V0)
3719:                            ST_DWORD(tbl + 8, 63); /* Partition start in LBA */
9D006EFC  8FC20048   LW V0, 72(S8)
9D006F00  24420008   ADDIU V0, V0, 8
9D006F04  2403003F   ADDIU V1, ZERO, 63
9D006F08  A0430000   SB V1, 0(V0)
9D006F0C  8FC20048   LW V0, 72(S8)
9D006F10  24420009   ADDIU V0, V0, 9
9D006F14  A0400000   SB ZERO, 0(V0)
9D006F18  8FC20048   LW V0, 72(S8)
9D006F1C  2442000A   ADDIU V0, V0, 10
9D006F20  A0400000   SB ZERO, 0(V0)
9D006F24  8FC20048   LW V0, 72(S8)
9D006F28  2442000B   ADDIU V0, V0, 11
9D006F2C  A0400000   SB ZERO, 0(V0)
3720:                            ST_DWORD(tbl + 12, n_vol); /* Partition size in LBA */
9D006F30  8FC20048   LW V0, 72(S8)
9D006F34  2442000C   ADDIU V0, V0, 12
9D006F38  8FC30050   LW V1, 80(S8)
9D006F3C  306300FF   ANDI V1, V1, 255
9D006F40  A0430000   SB V1, 0(V0)
9D006F44  8FC20048   LW V0, 72(S8)
9D006F48  2442000D   ADDIU V0, V0, 13
9D006F4C  8FC30050   LW V1, 80(S8)
9D006F50  3063FFFF   ANDI V1, V1, -1
9D006F54  00031A02   SRL V1, V1, 8
9D006F58  3063FFFF   ANDI V1, V1, -1
9D006F5C  306300FF   ANDI V1, V1, 255
9D006F60  A0430000   SB V1, 0(V0)
9D006F64  8FC20048   LW V0, 72(S8)
9D006F68  2442000E   ADDIU V0, V0, 14
9D006F6C  8FC30050   LW V1, 80(S8)
9D006F70  00031C02   SRL V1, V1, 16
9D006F74  306300FF   ANDI V1, V1, 255
9D006F78  A0430000   SB V1, 0(V0)
9D006F7C  8FC20048   LW V0, 72(S8)
9D006F80  2442000F   ADDIU V0, V0, 15
9D006F84  8FC30050   LW V1, 80(S8)
9D006F88  00031E02   SRL V1, V1, 24
9D006F8C  306300FF   ANDI V1, V1, 255
9D006F90  A0430000   SB V1, 0(V0)
3721:                            ST_WORD(fs->win + BS_55AA, 0xAA55); /* MBR signature */
9D006F94  8FC2002C   LW V0, 44(S8)
9D006F98  24420232   ADDIU V0, V0, 562
9D006F9C  24030055   ADDIU V1, ZERO, 85
9D006FA0  A0430000   SB V1, 0(V0)
9D006FA4  8FC2002C   LW V0, 44(S8)
9D006FA8  24420233   ADDIU V0, V0, 563
9D006FAC  2403FFAA   ADDIU V1, ZERO, -86
9D006FB0  A0430000   SB V1, 0(V0)
3722:                            if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) /* Write it to the MBR sector */
9D006FB4  93C30030   LBU V1, 48(S8)
9D006FB8  8FC2002C   LW V0, 44(S8)
9D006FBC  24420034   ADDIU V0, V0, 52
9D006FC0  00602021   ADDU A0, V1, ZERO
9D006FC4  00402821   ADDU A1, V0, ZERO
9D006FC8  00003021   ADDU A2, ZERO, ZERO
9D006FCC  24070001   ADDIU A3, ZERO, 1
9D006FD0  0F40218C   JAL disk_write
9D006FD4  00000000   NOP
9D006FD8  10400004   BEQ V0, ZERO, 0x9D006FEC
9D006FDC  00000000   NOP
3723:                                return FR_DISK_ERR;
9D006FE0  24020001   ADDIU V0, ZERO, 1
9D006FE4  0B401E93   J 0x9D007A4C
9D006FE8  00000000   NOP
3724:                            md = 0xF8;
9D006FEC  2402FFF8   ADDIU V0, ZERO, -8
9D006FF0  A3C20011   SB V0, 17(S8)
3725:                        }
3726:                    }
3727:                
3728:                    /* Create BPB in the VBR */
3729:                    tbl = fs->win; /* Clear sector */
9D006FF4  8FC2002C   LW V0, 44(S8)
9D006FF8  24420034   ADDIU V0, V0, 52
9D006FFC  AFC20048   SW V0, 72(S8)
3730:                    mem_set(tbl, 0, SS(fs));
9D007000  8FC40048   LW A0, 72(S8)
9D007004  00002821   ADDU A1, ZERO, ZERO
9D007008  24060200   ADDIU A2, ZERO, 512
9D00700C  0F40002B   JAL 0x9D0000AC
9D007010  00000000   NOP
3731:                    mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11); /* Boot jump code, OEM name */
9D007014  8FC40048   LW A0, 72(S8)
9D007018  3C029D01   LUI V0, -25343
9D00701C  2445CD10   ADDIU A1, V0, -13040
9D007020  2406000B   ADDIU A2, ZERO, 11
9D007024  0F400008   JAL 0x9D000020
9D007028  00000000   NOP
3732:                    i = SS(fs); /* Sector size */
9D00702C  24020200   ADDIU V0, ZERO, 512
9D007030  AFC20018   SW V0, 24(S8)
3733:                    ST_WORD(tbl + BPB_BytsPerSec, i);
9D007034  8FC20048   LW V0, 72(S8)
9D007038  2442000B   ADDIU V0, V0, 11
9D00703C  8FC30018   LW V1, 24(S8)
9D007040  306300FF   ANDI V1, V1, 255
9D007044  A0430000   SB V1, 0(V0)
9D007048  8FC20048   LW V0, 72(S8)
9D00704C  2442000C   ADDIU V0, V0, 12
9D007050  8FC30018   LW V1, 24(S8)
9D007054  3063FFFF   ANDI V1, V1, -1
9D007058  00031A02   SRL V1, V1, 8
9D00705C  3063FFFF   ANDI V1, V1, -1
9D007060  306300FF   ANDI V1, V1, 255
9D007064  A0430000   SB V1, 0(V0)
3734:                    tbl[BPB_SecPerClus] = (BYTE) au; /* Sectors per cluster */
9D007068  8FC20048   LW V0, 72(S8)
9D00706C  2442000D   ADDIU V0, V0, 13
9D007070  8FC30068   LW V1, 104(S8)
9D007074  306300FF   ANDI V1, V1, 255
9D007078  A0430000   SB V1, 0(V0)
3735:                    ST_WORD(tbl + BPB_RsvdSecCnt, n_rsv); /* Reserved sectors */
9D00707C  8FC20048   LW V0, 72(S8)
9D007080  2442000E   ADDIU V0, V0, 14
9D007084  8FC30020   LW V1, 32(S8)
9D007088  306300FF   ANDI V1, V1, 255
9D00708C  A0430000   SB V1, 0(V0)
9D007090  8FC20048   LW V0, 72(S8)
9D007094  2442000F   ADDIU V0, V0, 15
9D007098  8FC30020   LW V1, 32(S8)
9D00709C  3063FFFF   ANDI V1, V1, -1
9D0070A0  00031A02   SRL V1, V1, 8
9D0070A4  3063FFFF   ANDI V1, V1, -1
9D0070A8  306300FF   ANDI V1, V1, 255
9D0070AC  A0430000   SB V1, 0(V0)
3736:                    tbl[BPB_NumFATs] = N_FATS; /* Number of FATs */
9D0070B0  8FC20048   LW V0, 72(S8)
9D0070B4  24420010   ADDIU V0, V0, 16
9D0070B8  24030001   ADDIU V1, ZERO, 1
9D0070BC  A0430000   SB V1, 0(V0)
3737:                    i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR; /* Number of rootdir entries */
9D0070C0  93C30010   LBU V1, 16(S8)
9D0070C4  24020003   ADDIU V0, ZERO, 3
9D0070C8  14620004   BNE V1, V0, 0x9D0070DC
9D0070CC  00000000   NOP
9D0070D0  00001021   ADDU V0, ZERO, ZERO
9D0070D4  0B401C38   J 0x9D0070E0
9D0070D8  00000000   NOP
9D0070DC  24020200   ADDIU V0, ZERO, 512
9D0070E0  AFC20018   SW V0, 24(S8)
3738:                    ST_WORD(tbl + BPB_RootEntCnt, i);
9D0070E4  8FC20048   LW V0, 72(S8)
9D0070E8  24420011   ADDIU V0, V0, 17
9D0070EC  8FC30018   LW V1, 24(S8)
9D0070F0  306300FF   ANDI V1, V1, 255
9D0070F4  A0430000   SB V1, 0(V0)
9D0070F8  8FC20048   LW V0, 72(S8)
9D0070FC  24420012   ADDIU V0, V0, 18
9D007100  8FC30018   LW V1, 24(S8)
9D007104  3063FFFF   ANDI V1, V1, -1
9D007108  00031A02   SRL V1, V1, 8
9D00710C  3063FFFF   ANDI V1, V1, -1
9D007110  306300FF   ANDI V1, V1, 255
9D007114  A0430000   SB V1, 0(V0)
3739:                    if (n_vol < 0x10000) { /* Number of total sectors */
9D007118  8FC30050   LW V1, 80(S8)
9D00711C  3C020001   LUI V0, 1
9D007120  0062102B   SLTU V0, V1, V0
9D007124  10400010   BEQ V0, ZERO, 0x9D007168
9D007128  00000000   NOP
3740:                        ST_WORD(tbl + BPB_TotSec16, n_vol);
9D00712C  8FC20048   LW V0, 72(S8)
9D007130  24420013   ADDIU V0, V0, 19
9D007134  8FC30050   LW V1, 80(S8)
9D007138  306300FF   ANDI V1, V1, 255
9D00713C  A0430000   SB V1, 0(V0)
9D007140  8FC20048   LW V0, 72(S8)
9D007144  24420014   ADDIU V0, V0, 20
9D007148  8FC30050   LW V1, 80(S8)
9D00714C  3063FFFF   ANDI V1, V1, -1
9D007150  00031A02   SRL V1, V1, 8
9D007154  3063FFFF   ANDI V1, V1, -1
9D007158  306300FF   ANDI V1, V1, 255
9D00715C  A0430000   SB V1, 0(V0)
9D007160  0B401C73   J 0x9D0071CC
9D007164  00000000   NOP
3741:                    } else {
3742:                        ST_DWORD(tbl + BPB_TotSec32, n_vol);
9D007168  8FC20048   LW V0, 72(S8)
9D00716C  24420020   ADDIU V0, V0, 32
9D007170  8FC30050   LW V1, 80(S8)
9D007174  306300FF   ANDI V1, V1, 255
9D007178  A0430000   SB V1, 0(V0)
9D00717C  8FC20048   LW V0, 72(S8)
9D007180  24420021   ADDIU V0, V0, 33
9D007184  8FC30050   LW V1, 80(S8)
9D007188  3063FFFF   ANDI V1, V1, -1
9D00718C  00031A02   SRL V1, V1, 8
9D007190  3063FFFF   ANDI V1, V1, -1
9D007194  306300FF   ANDI V1, V1, 255
9D007198  A0430000   SB V1, 0(V0)
9D00719C  8FC20048   LW V0, 72(S8)
9D0071A0  24420022   ADDIU V0, V0, 34
9D0071A4  8FC30050   LW V1, 80(S8)
9D0071A8  00031C02   SRL V1, V1, 16
9D0071AC  306300FF   ANDI V1, V1, 255
9D0071B0  A0430000   SB V1, 0(V0)
9D0071B4  8FC20048   LW V0, 72(S8)
9D0071B8  24420023   ADDIU V0, V0, 35
9D0071BC  8FC30050   LW V1, 80(S8)
9D0071C0  00031E02   SRL V1, V1, 24
9D0071C4  306300FF   ANDI V1, V1, 255
9D0071C8  A0430000   SB V1, 0(V0)
3743:                    }
3744:                    tbl[BPB_Media] = md; /* Media descriptor */
9D0071CC  8FC20048   LW V0, 72(S8)
9D0071D0  24420015   ADDIU V0, V0, 21
9D0071D4  93C30011   LBU V1, 17(S8)
9D0071D8  A0430000   SB V1, 0(V0)
3745:                    ST_WORD(tbl + BPB_SecPerTrk, 63); /* Number of sectors per track */
9D0071DC  8FC20048   LW V0, 72(S8)
9D0071E0  24420018   ADDIU V0, V0, 24
9D0071E4  2403003F   ADDIU V1, ZERO, 63
9D0071E8  A0430000   SB V1, 0(V0)
9D0071EC  8FC20048   LW V0, 72(S8)
9D0071F0  24420019   ADDIU V0, V0, 25
9D0071F4  A0400000   SB ZERO, 0(V0)
3746:                    ST_WORD(tbl + BPB_NumHeads, 255); /* Number of heads */
9D0071F8  8FC20048   LW V0, 72(S8)
9D0071FC  2442001A   ADDIU V0, V0, 26
9D007200  2403FFFF   ADDIU V1, ZERO, -1
9D007204  A0430000   SB V1, 0(V0)
9D007208  8FC20048   LW V0, 72(S8)
9D00720C  2442001B   ADDIU V0, V0, 27
9D007210  A0400000   SB ZERO, 0(V0)
3747:                    ST_DWORD(tbl + BPB_HiddSec, b_vol); /* Hidden sectors */
9D007214  8FC20048   LW V0, 72(S8)
9D007218  2442001C   ADDIU V0, V0, 28
9D00721C  8FC30034   LW V1, 52(S8)
9D007220  306300FF   ANDI V1, V1, 255
9D007224  A0430000   SB V1, 0(V0)
9D007228  8FC20048   LW V0, 72(S8)
9D00722C  2442001D   ADDIU V0, V0, 29
9D007230  8FC30034   LW V1, 52(S8)
9D007234  3063FFFF   ANDI V1, V1, -1
9D007238  00031A02   SRL V1, V1, 8
9D00723C  3063FFFF   ANDI V1, V1, -1
9D007240  306300FF   ANDI V1, V1, 255
9D007244  A0430000   SB V1, 0(V0)
9D007248  8FC20048   LW V0, 72(S8)
9D00724C  2442001E   ADDIU V0, V0, 30
9D007250  8FC30034   LW V1, 52(S8)
9D007254  00031C02   SRL V1, V1, 16
9D007258  306300FF   ANDI V1, V1, 255
9D00725C  A0430000   SB V1, 0(V0)
9D007260  8FC20048   LW V0, 72(S8)
9D007264  2442001F   ADDIU V0, V0, 31
9D007268  8FC30034   LW V1, 52(S8)
9D00726C  00031E02   SRL V1, V1, 24
9D007270  306300FF   ANDI V1, V1, 255
9D007274  A0430000   SB V1, 0(V0)
3748:                    n = get_fattime(); /* Use current time as VSN */
9D007278  0F402C66   JAL get_fattime
9D00727C  00000000   NOP
9D007280  AFC2004C   SW V0, 76(S8)
3749:                    if (fmt == FS_FAT32) {
9D007284  93C30010   LBU V1, 16(S8)
9D007288  24020003   ADDIU V0, ZERO, 3
9D00728C  14620060   BNE V1, V0, 0x9D007410
9D007290  00000000   NOP
3750:                        ST_DWORD(tbl + BS_VolID32, n); /* VSN */
9D007294  8FC20048   LW V0, 72(S8)
9D007298  24420043   ADDIU V0, V0, 67
9D00729C  8FC3004C   LW V1, 76(S8)
9D0072A0  306300FF   ANDI V1, V1, 255
9D0072A4  A0430000   SB V1, 0(V0)
9D0072A8  8FC20048   LW V0, 72(S8)
9D0072AC  24420044   ADDIU V0, V0, 68
9D0072B0  8FC3004C   LW V1, 76(S8)
9D0072B4  3063FFFF   ANDI V1, V1, -1
9D0072B8  00031A02   SRL V1, V1, 8
9D0072BC  3063FFFF   ANDI V1, V1, -1
9D0072C0  306300FF   ANDI V1, V1, 255
9D0072C4  A0430000   SB V1, 0(V0)
9D0072C8  8FC20048   LW V0, 72(S8)
9D0072CC  24420045   ADDIU V0, V0, 69
9D0072D0  8FC3004C   LW V1, 76(S8)
9D0072D4  00031C02   SRL V1, V1, 16
9D0072D8  306300FF   ANDI V1, V1, 255
9D0072DC  A0430000   SB V1, 0(V0)
9D0072E0  8FC20048   LW V0, 72(S8)
9D0072E4  24420046   ADDIU V0, V0, 70
9D0072E8  8FC3004C   LW V1, 76(S8)
9D0072EC  00031E02   SRL V1, V1, 24
9D0072F0  306300FF   ANDI V1, V1, 255
9D0072F4  A0430000   SB V1, 0(V0)
3751:                        ST_DWORD(tbl + BPB_FATSz32, n_fat); /* Number of sectors per FAT */
9D0072F8  8FC20048   LW V0, 72(S8)
9D0072FC  24420024   ADDIU V0, V0, 36
9D007300  8FC30024   LW V1, 36(S8)
9D007304  306300FF   ANDI V1, V1, 255
9D007308  A0430000   SB V1, 0(V0)
9D00730C  8FC20048   LW V0, 72(S8)
9D007310  24420025   ADDIU V0, V0, 37
9D007314  8FC30024   LW V1, 36(S8)
9D007318  3063FFFF   ANDI V1, V1, -1
9D00731C  00031A02   SRL V1, V1, 8
9D007320  3063FFFF   ANDI V1, V1, -1
9D007324  306300FF   ANDI V1, V1, 255
9D007328  A0430000   SB V1, 0(V0)
9D00732C  8FC20048   LW V0, 72(S8)
9D007330  24420026   ADDIU V0, V0, 38
9D007334  8FC30024   LW V1, 36(S8)
9D007338  00031C02   SRL V1, V1, 16
9D00733C  306300FF   ANDI V1, V1, 255
9D007340  A0430000   SB V1, 0(V0)
9D007344  8FC20048   LW V0, 72(S8)
9D007348  24420027   ADDIU V0, V0, 39
9D00734C  8FC30024   LW V1, 36(S8)
9D007350  00031E02   SRL V1, V1, 24
9D007354  306300FF   ANDI V1, V1, 255
9D007358  A0430000   SB V1, 0(V0)
3752:                        ST_DWORD(tbl + BPB_RootClus, 2); /* Root directory start cluster (2) */
9D00735C  8FC20048   LW V0, 72(S8)
9D007360  2442002C   ADDIU V0, V0, 44
9D007364  24030002   ADDIU V1, ZERO, 2
9D007368  A0430000   SB V1, 0(V0)
9D00736C  8FC20048   LW V0, 72(S8)
9D007370  2442002D   ADDIU V0, V0, 45
9D007374  A0400000   SB ZERO, 0(V0)
9D007378  8FC20048   LW V0, 72(S8)
9D00737C  2442002E   ADDIU V0, V0, 46
9D007380  A0400000   SB ZERO, 0(V0)
9D007384  8FC20048   LW V0, 72(S8)
9D007388  2442002F   ADDIU V0, V0, 47
9D00738C  A0400000   SB ZERO, 0(V0)
3753:                        ST_WORD(tbl + BPB_FSInfo, 1); /* FSInfo record offset (VBR+1) */
9D007390  8FC20048   LW V0, 72(S8)
9D007394  24420030   ADDIU V0, V0, 48
9D007398  24030001   ADDIU V1, ZERO, 1
9D00739C  A0430000   SB V1, 0(V0)
9D0073A0  8FC20048   LW V0, 72(S8)
9D0073A4  24420031   ADDIU V0, V0, 49
9D0073A8  A0400000   SB ZERO, 0(V0)
3754:                        ST_WORD(tbl + BPB_BkBootSec, 6); /* Backup boot record offset (VBR+6) */
9D0073AC  8FC20048   LW V0, 72(S8)
9D0073B0  24420032   ADDIU V0, V0, 50
9D0073B4  24030006   ADDIU V1, ZERO, 6
9D0073B8  A0430000   SB V1, 0(V0)
9D0073BC  8FC20048   LW V0, 72(S8)
9D0073C0  24420033   ADDIU V0, V0, 51
9D0073C4  A0400000   SB ZERO, 0(V0)
3755:                        tbl[BS_DrvNum32] = 0x80; /* Drive number */
9D0073C8  8FC20048   LW V0, 72(S8)
9D0073CC  24420040   ADDIU V0, V0, 64
9D0073D0  2403FF80   ADDIU V1, ZERO, -128
9D0073D4  A0430000   SB V1, 0(V0)
3756:                        tbl[BS_BootSig32] = 0x29; /* Extended boot signature */
9D0073D8  8FC20048   LW V0, 72(S8)
9D0073DC  24420042   ADDIU V0, V0, 66
9D0073E0  24030029   ADDIU V1, ZERO, 41
9D0073E4  A0430000   SB V1, 0(V0)
3757:                        mem_cpy(tbl + BS_VolLab32, "NO NAME    " "FAT32   ", 19); /* Volume label, FAT signature */
9D0073E8  8FC20048   LW V0, 72(S8)
9D0073EC  24420047   ADDIU V0, V0, 71
9D0073F0  00402021   ADDU A0, V0, ZERO
9D0073F4  3C029D01   LUI V0, -25343
9D0073F8  2445CD1C   ADDIU A1, V0, -13028
9D0073FC  24060013   ADDIU A2, ZERO, 19
9D007400  0F400008   JAL 0x9D000020
9D007404  00000000   NOP
9D007408  0B401D3A   J 0x9D0074E8
9D00740C  00000000   NOP
3758:                    } else {
3759:                        ST_DWORD(tbl + BS_VolID, n); /* VSN */
9D007410  8FC20048   LW V0, 72(S8)
9D007414  24420027   ADDIU V0, V0, 39
9D007418  8FC3004C   LW V1, 76(S8)
9D00741C  306300FF   ANDI V1, V1, 255
9D007420  A0430000   SB V1, 0(V0)
9D007424  8FC20048   LW V0, 72(S8)
9D007428  24420028   ADDIU V0, V0, 40
9D00742C  8FC3004C   LW V1, 76(S8)
9D007430  3063FFFF   ANDI V1, V1, -1
9D007434  00031A02   SRL V1, V1, 8
9D007438  3063FFFF   ANDI V1, V1, -1
9D00743C  306300FF   ANDI V1, V1, 255
9D007440  A0430000   SB V1, 0(V0)
9D007444  8FC20048   LW V0, 72(S8)
9D007448  24420029   ADDIU V0, V0, 41
9D00744C  8FC3004C   LW V1, 76(S8)
9D007450  00031C02   SRL V1, V1, 16
9D007454  306300FF   ANDI V1, V1, 255
9D007458  A0430000   SB V1, 0(V0)
9D00745C  8FC20048   LW V0, 72(S8)
9D007460  2442002A   ADDIU V0, V0, 42
9D007464  8FC3004C   LW V1, 76(S8)
9D007468  00031E02   SRL V1, V1, 24
9D00746C  306300FF   ANDI V1, V1, 255
9D007470  A0430000   SB V1, 0(V0)
3760:                        ST_WORD(tbl + BPB_FATSz16, n_fat); /* Number of sectors per FAT */
9D007474  8FC20048   LW V0, 72(S8)
9D007478  24420016   ADDIU V0, V0, 22
9D00747C  8FC30024   LW V1, 36(S8)
9D007480  306300FF   ANDI V1, V1, 255
9D007484  A0430000   SB V1, 0(V0)
9D007488  8FC20048   LW V0, 72(S8)
9D00748C  24420017   ADDIU V0, V0, 23
9D007490  8FC30024   LW V1, 36(S8)
9D007494  3063FFFF   ANDI V1, V1, -1
9D007498  00031A02   SRL V1, V1, 8
9D00749C  3063FFFF   ANDI V1, V1, -1
9D0074A0  306300FF   ANDI V1, V1, 255
9D0074A4  A0430000   SB V1, 0(V0)
3761:                        tbl[BS_DrvNum] = 0x80; /* Drive number */
9D0074A8  8FC20048   LW V0, 72(S8)
9D0074AC  24420024   ADDIU V0, V0, 36
9D0074B0  2403FF80   ADDIU V1, ZERO, -128
9D0074B4  A0430000   SB V1, 0(V0)
3762:                        tbl[BS_BootSig] = 0x29; /* Extended boot signature */
9D0074B8  8FC20048   LW V0, 72(S8)
9D0074BC  24420026   ADDIU V0, V0, 38
9D0074C0  24030029   ADDIU V1, ZERO, 41
9D0074C4  A0430000   SB V1, 0(V0)
3763:                        mem_cpy(tbl + BS_VolLab, "NO NAME    " "FAT     ", 19); /* Volume label, FAT signature */
9D0074C8  8FC20048   LW V0, 72(S8)
9D0074CC  2442002B   ADDIU V0, V0, 43
9D0074D0  00402021   ADDU A0, V0, ZERO
9D0074D4  3C029D01   LUI V0, -25343
9D0074D8  2445CD30   ADDIU A1, V0, -13008
9D0074DC  24060013   ADDIU A2, ZERO, 19
9D0074E0  0F400008   JAL 0x9D000020
9D0074E4  00000000   NOP
3764:                    }
3765:                    ST_WORD(tbl + BS_55AA, 0xAA55); /* Signature (Offset is fixed here regardless of sector size) */
9D0074E8  8FC20048   LW V0, 72(S8)
9D0074EC  244201FE   ADDIU V0, V0, 510
9D0074F0  24030055   ADDIU V1, ZERO, 85
9D0074F4  A0430000   SB V1, 0(V0)
9D0074F8  8FC20048   LW V0, 72(S8)
9D0074FC  244201FF   ADDIU V0, V0, 511
9D007500  2403FFAA   ADDIU V1, ZERO, -86
9D007504  A0430000   SB V1, 0(V0)
3766:                    if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK) /* Write it to the VBR sector */
9D007508  93C20030   LBU V0, 48(S8)
9D00750C  00402021   ADDU A0, V0, ZERO
9D007510  8FC50048   LW A1, 72(S8)
9D007514  8FC60034   LW A2, 52(S8)
9D007518  24070001   ADDIU A3, ZERO, 1
9D00751C  0F40218C   JAL disk_write
9D007520  00000000   NOP
9D007524  10400004   BEQ V0, ZERO, 0x9D007538
9D007528  00000000   NOP
3767:                        return FR_DISK_ERR;
9D00752C  24020001   ADDIU V0, ZERO, 1
9D007530  0B401E93   J 0x9D007A4C
9D007534  00000000   NOP
3768:                    if (fmt == FS_FAT32) /* Write backup VBR if needed (VBR+6) */
9D007538  93C30010   LBU V1, 16(S8)
9D00753C  24020003   ADDIU V0, ZERO, 3
9D007540  1462000A   BNE V1, V0, 0x9D00756C
9D007544  00000000   NOP
3769:                        disk_write(pdrv, tbl, b_vol + 6, 1);
9D007548  93C30030   LBU V1, 48(S8)
9D00754C  8FC20034   LW V0, 52(S8)
9D007550  24420006   ADDIU V0, V0, 6
9D007554  00602021   ADDU A0, V1, ZERO
9D007558  8FC50048   LW A1, 72(S8)
9D00755C  00403021   ADDU A2, V0, ZERO
9D007560  24070001   ADDIU A3, ZERO, 1
9D007564  0F40218C   JAL disk_write
9D007568  00000000   NOP
3770:                
3771:                    /* Initialize FAT area */
3772:                    wsect = b_fat;
9D00756C  8FC2001C   LW V0, 28(S8)
9D007570  AFC20014   SW V0, 20(S8)
3773:                    for (i = 0; i < N_FATS; i++) { /* Initialize each FAT copy */
9D007574  AFC00018   SW ZERO, 24(S8)
9D007578  0B401E01   J 0x9D007804
9D00757C  00000000   NOP
9D0077F8  8FC20018   LW V0, 24(S8)
9D0077FC  24420001   ADDIU V0, V0, 1
9D007800  AFC20018   SW V0, 24(S8)
9D007804  8FC20018   LW V0, 24(S8)
9D007808  1040FF5D   BEQ V0, ZERO, 0x9D007580
9D00780C  00000000   NOP
3774:                        mem_set(tbl, 0, SS(fs)); /* 1st sector of the FAT  */
9D007580  8FC40048   LW A0, 72(S8)
9D007584  00002821   ADDU A1, ZERO, ZERO
9D007588  24060200   ADDIU A2, ZERO, 512
9D00758C  0F40002B   JAL 0x9D0000AC
9D007590  00000000   NOP
3775:                        n = md; /* Media descriptor byte */
9D007594  93C20011   LBU V0, 17(S8)
9D007598  AFC2004C   SW V0, 76(S8)
3776:                        if (fmt != FS_FAT32) {
9D00759C  93C30010   LBU V1, 16(S8)
9D0075A0  24020003   ADDIU V0, ZERO, 3
9D0075A4  10620027   BEQ V1, V0, 0x9D007644
9D0075A8  00000000   NOP
3777:                            n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
9D0075AC  93C30010   LBU V1, 16(S8)
9D0075B0  24020001   ADDIU V0, ZERO, 1
9D0075B4  14620005   BNE V1, V0, 0x9D0075CC
9D0075B8  00000000   NOP
9D0075BC  3C0200FF   LUI V0, 255
9D0075C0  3442FF00   ORI V0, V0, -256
9D0075C4  0B401D74   J 0x9D0075D0
9D0075C8  00000000   NOP
9D0075CC  2402FF00   ADDIU V0, ZERO, -256
9D0075D0  8FC3004C   LW V1, 76(S8)
9D0075D4  00431025   OR V0, V0, V1
9D0075D8  AFC2004C   SW V0, 76(S8)
3778:                            ST_DWORD(tbl + 0, n); /* Reserve cluster #0-1 (FAT12/16) */
9D0075DC  8FC2004C   LW V0, 76(S8)
9D0075E0  304300FF   ANDI V1, V0, 255
9D0075E4  8FC20048   LW V0, 72(S8)
9D0075E8  A0430000   SB V1, 0(V0)
9D0075EC  8FC20048   LW V0, 72(S8)
9D0075F0  24420001   ADDIU V0, V0, 1
9D0075F4  8FC3004C   LW V1, 76(S8)
9D0075F8  3063FFFF   ANDI V1, V1, -1
9D0075FC  00031A02   SRL V1, V1, 8
9D007600  3063FFFF   ANDI V1, V1, -1
9D007604  306300FF   ANDI V1, V1, 255
9D007608  A0430000   SB V1, 0(V0)
9D00760C  8FC20048   LW V0, 72(S8)
9D007610  24420002   ADDIU V0, V0, 2
9D007614  8FC3004C   LW V1, 76(S8)
9D007618  00031C02   SRL V1, V1, 16
9D00761C  306300FF   ANDI V1, V1, 255
9D007620  A0430000   SB V1, 0(V0)
9D007624  8FC20048   LW V0, 72(S8)
9D007628  24420003   ADDIU V0, V0, 3
9D00762C  8FC3004C   LW V1, 76(S8)
9D007630  00031E02   SRL V1, V1, 24
9D007634  306300FF   ANDI V1, V1, 255
9D007638  A0430000   SB V1, 0(V0)
9D00763C  0B401DCD   J 0x9D007734
9D007640  00000000   NOP
3779:                        } else {
3780:                            n |= 0xFFFFFF00;
9D007644  8FC3004C   LW V1, 76(S8)
9D007648  2402FF00   ADDIU V0, ZERO, -256
9D00764C  00621025   OR V0, V1, V0
9D007650  AFC2004C   SW V0, 76(S8)
3781:                            ST_DWORD(tbl + 0, n); /* Reserve cluster #0-1 (FAT32) */
9D007654  8FC2004C   LW V0, 76(S8)
9D007658  304300FF   ANDI V1, V0, 255
9D00765C  8FC20048   LW V0, 72(S8)
9D007660  A0430000   SB V1, 0(V0)
9D007664  8FC20048   LW V0, 72(S8)
9D007668  24420001   ADDIU V0, V0, 1
9D00766C  8FC3004C   LW V1, 76(S8)
9D007670  3063FFFF   ANDI V1, V1, -1
9D007674  00031A02   SRL V1, V1, 8
9D007678  3063FFFF   ANDI V1, V1, -1
9D00767C  306300FF   ANDI V1, V1, 255
9D007680  A0430000   SB V1, 0(V0)
9D007684  8FC20048   LW V0, 72(S8)
9D007688  24420002   ADDIU V0, V0, 2
9D00768C  8FC3004C   LW V1, 76(S8)
9D007690  00031C02   SRL V1, V1, 16
9D007694  306300FF   ANDI V1, V1, 255
9D007698  A0430000   SB V1, 0(V0)
9D00769C  8FC20048   LW V0, 72(S8)
9D0076A0  24420003   ADDIU V0, V0, 3
9D0076A4  8FC3004C   LW V1, 76(S8)
9D0076A8  00031E02   SRL V1, V1, 24
9D0076AC  306300FF   ANDI V1, V1, 255
9D0076B0  A0430000   SB V1, 0(V0)
3782:                            ST_DWORD(tbl + 4, 0xFFFFFFFF);
9D0076B4  8FC20048   LW V0, 72(S8)
9D0076B8  24420004   ADDIU V0, V0, 4
9D0076BC  2403FFFF   ADDIU V1, ZERO, -1
9D0076C0  A0430000   SB V1, 0(V0)
9D0076C4  8FC20048   LW V0, 72(S8)
9D0076C8  24420005   ADDIU V0, V0, 5
9D0076CC  2403FFFF   ADDIU V1, ZERO, -1
9D0076D0  A0430000   SB V1, 0(V0)
9D0076D4  8FC20048   LW V0, 72(S8)
9D0076D8  24420006   ADDIU V0, V0, 6
9D0076DC  2403FFFF   ADDIU V1, ZERO, -1
9D0076E0  A0430000   SB V1, 0(V0)
9D0076E4  8FC20048   LW V0, 72(S8)
9D0076E8  24420007   ADDIU V0, V0, 7
9D0076EC  2403FFFF   ADDIU V1, ZERO, -1
9D0076F0  A0430000   SB V1, 0(V0)
3783:                            ST_DWORD(tbl + 8, 0x0FFFFFFF); /* Reserve cluster #2 for root dir */
9D0076F4  8FC20048   LW V0, 72(S8)
9D0076F8  24420008   ADDIU V0, V0, 8
9D0076FC  2403FFFF   ADDIU V1, ZERO, -1
9D007700  A0430000   SB V1, 0(V0)
9D007704  8FC20048   LW V0, 72(S8)
9D007708  24420009   ADDIU V0, V0, 9
9D00770C  2403FFFF   ADDIU V1, ZERO, -1
9D007710  A0430000   SB V1, 0(V0)
9D007714  8FC20048   LW V0, 72(S8)
9D007718  2442000A   ADDIU V0, V0, 10
9D00771C  2403FFFF   ADDIU V1, ZERO, -1
9D007720  A0430000   SB V1, 0(V0)
9D007724  8FC20048   LW V0, 72(S8)
9D007728  2442000B   ADDIU V0, V0, 11
9D00772C  2403000F   ADDIU V1, ZERO, 15
9D007730  A0430000   SB V1, 0(V0)
3784:                        }
3785:                        if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
9D007734  93C30030   LBU V1, 48(S8)
9D007738  8FC20014   LW V0, 20(S8)
9D00773C  8FC40014   LW A0, 20(S8)
9D007740  24840001   ADDIU A0, A0, 1
9D007744  AFC40014   SW A0, 20(S8)
9D007748  00602021   ADDU A0, V1, ZERO
9D00774C  8FC50048   LW A1, 72(S8)
9D007750  00403021   ADDU A2, V0, ZERO
9D007754  24070001   ADDIU A3, ZERO, 1
9D007758  0F40218C   JAL disk_write
9D00775C  00000000   NOP
9D007760  10400004   BEQ V0, ZERO, 0x9D007774
9D007764  00000000   NOP
3786:                            return FR_DISK_ERR;
9D007768  24020001   ADDIU V0, ZERO, 1
9D00776C  0B401E93   J 0x9D007A4C
9D007770  00000000   NOP
3787:                        mem_set(tbl, 0, SS(fs)); /* Fill following FAT entries with zero */
9D007774  8FC40048   LW A0, 72(S8)
9D007778  00002821   ADDU A1, ZERO, ZERO
9D00777C  24060200   ADDIU A2, ZERO, 512
9D007780  0F40002B   JAL 0x9D0000AC
9D007784  00000000   NOP
3788:                        for (n = 1; n < n_fat; n++) { /* This loop may take a time on FAT32 volume due to many single sector writes */
9D007788  24020001   ADDIU V0, ZERO, 1
9D00778C  AFC2004C   SW V0, 76(S8)
9D007790  0B401DF9   J 0x9D0077E4
9D007794  00000000   NOP
9D0077D8  8FC2004C   LW V0, 76(S8)
9D0077DC  24420001   ADDIU V0, V0, 1
9D0077E0  AFC2004C   SW V0, 76(S8)
9D0077E4  8FC3004C   LW V1, 76(S8)
9D0077E8  8FC20024   LW V0, 36(S8)
9D0077EC  0062102B   SLTU V0, V1, V0
9D0077F0  1440FFE9   BNE V0, ZERO, 0x9D007798
9D0077F4  00000000   NOP
3789:                            if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
9D007798  93C30030   LBU V1, 48(S8)
9D00779C  8FC20014   LW V0, 20(S8)
9D0077A0  8FC40014   LW A0, 20(S8)
9D0077A4  24840001   ADDIU A0, A0, 1
9D0077A8  AFC40014   SW A0, 20(S8)
9D0077AC  00602021   ADDU A0, V1, ZERO
9D0077B0  8FC50048   LW A1, 72(S8)
9D0077B4  00403021   ADDU A2, V0, ZERO
9D0077B8  24070001   ADDIU A3, ZERO, 1
9D0077BC  0F40218C   JAL disk_write
9D0077C0  00000000   NOP
9D0077C4  10400004   BEQ V0, ZERO, 0x9D0077D8
9D0077C8  00000000   NOP
3790:                                return FR_DISK_ERR;
9D0077CC  24020001   ADDIU V0, ZERO, 1
9D0077D0  0B401E93   J 0x9D007A4C
9D0077D4  00000000   NOP
3791:                        }
3792:                    }
3793:                
3794:                    /* Initialize root directory */
3795:                    i = (fmt == FS_FAT32) ? au : n_dir;
9D007810  93C30010   LBU V1, 16(S8)
9D007814  24020003   ADDIU V0, ZERO, 3
9D007818  14620004   BNE V1, V0, 0x9D00782C
9D00781C  00000000   NOP
9D007820  8FC20068   LW V0, 104(S8)
9D007824  0B401E0C   J 0x9D007830
9D007828  00000000   NOP
9D00782C  8FC20028   LW V0, 40(S8)
9D007830  AFC20018   SW V0, 24(S8)
3796:                    do {
3797:                        if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
9D007834  93C30030   LBU V1, 48(S8)
9D007838  8FC20014   LW V0, 20(S8)
9D00783C  8FC40014   LW A0, 20(S8)
9D007840  24840001   ADDIU A0, A0, 1
9D007844  AFC40014   SW A0, 20(S8)
9D007848  00602021   ADDU A0, V1, ZERO
9D00784C  8FC50048   LW A1, 72(S8)
9D007850  00403021   ADDU A2, V0, ZERO
9D007854  24070001   ADDIU A3, ZERO, 1
9D007858  0F40218C   JAL disk_write
9D00785C  00000000   NOP
9D007860  10400004   BEQ V0, ZERO, 0x9D007874
9D007864  00000000   NOP
3798:                            return FR_DISK_ERR;
9D007868  24020001   ADDIU V0, ZERO, 1
9D00786C  0B401E93   J 0x9D007A4C
9D007870  00000000   NOP
3799:                    } while (--i);
9D007874  8FC20018   LW V0, 24(S8)
9D007878  2442FFFF   ADDIU V0, V0, -1
9D00787C  AFC20018   SW V0, 24(S8)
9D007880  8FC20018   LW V0, 24(S8)
9D007884  1440FFEB   BNE V0, ZERO, 0x9D007834
9D007888  00000000   NOP
3800:                
3801:                #if _USE_ERASE	/* Erase data area if needed */
3802:                    {
3803:                        DWORD eb[2];
3804:                
3805:                        eb[0] = wsect;
3806:                        eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
3807:                        disk_ioctl(pdrv, CTRL_ERASE_SECTOR, eb);
3808:                    }
3809:                #endif
3810:                
3811:                    /* Create FSInfo if needed */
3812:                    if (fmt == FS_FAT32) {
9D00788C  93C30010   LBU V1, 16(S8)
9D007890  24020003   ADDIU V0, ZERO, 3
9D007894  14620066   BNE V1, V0, 0x9D007A30
9D007898  00000000   NOP
3813:                        ST_DWORD(tbl + FSI_LeadSig, 0x41615252);
9D00789C  8FC20048   LW V0, 72(S8)
9D0078A0  24030052   ADDIU V1, ZERO, 82
9D0078A4  A0430000   SB V1, 0(V0)
9D0078A8  8FC20048   LW V0, 72(S8)
9D0078AC  24420001   ADDIU V0, V0, 1
9D0078B0  24030052   ADDIU V1, ZERO, 82
9D0078B4  A0430000   SB V1, 0(V0)
9D0078B8  8FC20048   LW V0, 72(S8)
9D0078BC  24420002   ADDIU V0, V0, 2
9D0078C0  24030061   ADDIU V1, ZERO, 97
9D0078C4  A0430000   SB V1, 0(V0)
9D0078C8  8FC20048   LW V0, 72(S8)
9D0078CC  24420003   ADDIU V0, V0, 3
9D0078D0  24030041   ADDIU V1, ZERO, 65
9D0078D4  A0430000   SB V1, 0(V0)
3814:                        ST_DWORD(tbl + FSI_StrucSig, 0x61417272);
9D0078D8  8FC20048   LW V0, 72(S8)
9D0078DC  244201E4   ADDIU V0, V0, 484
9D0078E0  24030072   ADDIU V1, ZERO, 114
9D0078E4  A0430000   SB V1, 0(V0)
9D0078E8  8FC20048   LW V0, 72(S8)
9D0078EC  244201E5   ADDIU V0, V0, 485
9D0078F0  24030072   ADDIU V1, ZERO, 114
9D0078F4  A0430000   SB V1, 0(V0)
9D0078F8  8FC20048   LW V0, 72(S8)
9D0078FC  244201E6   ADDIU V0, V0, 486
9D007900  24030041   ADDIU V1, ZERO, 65
9D007904  A0430000   SB V1, 0(V0)
9D007908  8FC20048   LW V0, 72(S8)
9D00790C  244201E7   ADDIU V0, V0, 487
9D007910  24030061   ADDIU V1, ZERO, 97
9D007914  A0430000   SB V1, 0(V0)
3815:                        ST_DWORD(tbl + FSI_Free_Count, n_clst - 1); /* Number of free clusters */
9D007918  8FC20048   LW V0, 72(S8)
9D00791C  244201E8   ADDIU V0, V0, 488
9D007920  8FC3003C   LW V1, 60(S8)
9D007924  306300FF   ANDI V1, V1, 255
9D007928  2463FFFF   ADDIU V1, V1, -1
9D00792C  306300FF   ANDI V1, V1, 255
9D007930  A0430000   SB V1, 0(V0)
9D007934  8FC20048   LW V0, 72(S8)
9D007938  244201E9   ADDIU V0, V0, 489
9D00793C  8FC3003C   LW V1, 60(S8)
9D007940  3063FFFF   ANDI V1, V1, -1
9D007944  2463FFFF   ADDIU V1, V1, -1
9D007948  3063FFFF   ANDI V1, V1, -1
9D00794C  00031A02   SRL V1, V1, 8
9D007950  3063FFFF   ANDI V1, V1, -1
9D007954  306300FF   ANDI V1, V1, 255
9D007958  A0430000   SB V1, 0(V0)
9D00795C  8FC20048   LW V0, 72(S8)
9D007960  244201EA   ADDIU V0, V0, 490
9D007964  8FC3003C   LW V1, 60(S8)
9D007968  2463FFFF   ADDIU V1, V1, -1
9D00796C  00031C02   SRL V1, V1, 16
9D007970  306300FF   ANDI V1, V1, 255
9D007974  A0430000   SB V1, 0(V0)
9D007978  8FC20048   LW V0, 72(S8)
9D00797C  244201EB   ADDIU V0, V0, 491
9D007980  8FC3003C   LW V1, 60(S8)
9D007984  2463FFFF   ADDIU V1, V1, -1
9D007988  00031E02   SRL V1, V1, 24
9D00798C  306300FF   ANDI V1, V1, 255
9D007990  A0430000   SB V1, 0(V0)
3816:                        ST_DWORD(tbl + FSI_Nxt_Free, 2); /* Last allocated cluster# */
9D007994  8FC20048   LW V0, 72(S8)
9D007998  244201EC   ADDIU V0, V0, 492
9D00799C  24030002   ADDIU V1, ZERO, 2
9D0079A0  A0430000   SB V1, 0(V0)
9D0079A4  8FC20048   LW V0, 72(S8)
9D0079A8  244201ED   ADDIU V0, V0, 493
9D0079AC  A0400000   SB ZERO, 0(V0)
9D0079B0  8FC20048   LW V0, 72(S8)
9D0079B4  244201EE   ADDIU V0, V0, 494
9D0079B8  A0400000   SB ZERO, 0(V0)
9D0079BC  8FC20048   LW V0, 72(S8)
9D0079C0  244201EF   ADDIU V0, V0, 495
9D0079C4  A0400000   SB ZERO, 0(V0)
3817:                        ST_WORD(tbl + BS_55AA, 0xAA55);
9D0079C8  8FC20048   LW V0, 72(S8)
9D0079CC  244201FE   ADDIU V0, V0, 510
9D0079D0  24030055   ADDIU V1, ZERO, 85
9D0079D4  A0430000   SB V1, 0(V0)
9D0079D8  8FC20048   LW V0, 72(S8)
9D0079DC  244201FF   ADDIU V0, V0, 511
9D0079E0  2403FFAA   ADDIU V1, ZERO, -86
9D0079E4  A0430000   SB V1, 0(V0)
3818:                        disk_write(pdrv, tbl, b_vol + 1, 1); /* Write original (VBR+1) */
9D0079E8  93C30030   LBU V1, 48(S8)
9D0079EC  8FC20034   LW V0, 52(S8)
9D0079F0  24420001   ADDIU V0, V0, 1
9D0079F4  00602021   ADDU A0, V1, ZERO
9D0079F8  8FC50048   LW A1, 72(S8)
9D0079FC  00403021   ADDU A2, V0, ZERO
9D007A00  24070001   ADDIU A3, ZERO, 1
9D007A04  0F40218C   JAL disk_write
9D007A08  00000000   NOP
3819:                        disk_write(pdrv, tbl, b_vol + 7, 1); /* Write backup (VBR+7) */
9D007A0C  93C30030   LBU V1, 48(S8)
9D007A10  8FC20034   LW V0, 52(S8)
9D007A14  24420007   ADDIU V0, V0, 7
9D007A18  00602021   ADDU A0, V1, ZERO
9D007A1C  8FC50048   LW A1, 72(S8)
9D007A20  00403021   ADDU A2, V0, ZERO
9D007A24  24070001   ADDIU A3, ZERO, 1
9D007A28  0F40218C   JAL disk_write
9D007A2C  00000000   NOP
3820:                    }
3821:                
3822:                    return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
9D007A30  93C20030   LBU V0, 48(S8)
9D007A34  00402021   ADDU A0, V0, ZERO
9D007A38  00002821   ADDU A1, ZERO, ZERO
9D007A3C  00003021   ADDU A2, ZERO, ZERO
9D007A40  0F4021FD   JAL disk_ioctl
9D007A44  00000000   NOP
9D007A48  0002102B   SLTU V0, ZERO, V0
3823:                }
9D007A4C  03C0E821   ADDU SP, S8, ZERO
9D007A50  8FBF005C   LW RA, 92(SP)
9D007A54  8FBE0058   LW S8, 88(SP)
9D007A58  27BD0060   ADDIU SP, SP, 96
9D007A5C  03E00008   JR RA
9D007A60  00000000   NOP
3824:                
3825:                
3826:                #if _MULTI_PARTITION == 2
3827:                /*-----------------------------------------------------------------------*/
3828:                /* Divide Physical Drive                                                 */
3829:                
3830:                /*-----------------------------------------------------------------------*/
3831:                
3832:                FRESULT f_fdisk(
3833:                        BYTE pdrv, /* Physical drive number */
3834:                        const DWORD szt[], /* Pointer to the size table for each partitions */
3835:                        void* work /* Pointer to the working buffer */
3836:                        ) {
3837:                    UINT i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;
3838:                    BYTE s_hd, e_hd, *p, *buf = (BYTE*) work;
3839:                    DSTATUS stat;
3840:                    DWORD sz_disk, sz_part, s_part;
3841:                
3842:                
3843:                    stat = disk_initialize(pdrv);
3844:                    if (stat & STA_NOINIT) return FR_NOT_READY;
3845:                    if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
3846:                    if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
3847:                
3848:                    /* Determine CHS in the table regardless of the drive geometry */
3849:                    for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2);
3850:                    if (n == 256) n--;
3851:                    e_hd = n - 1;
3852:                    sz_cyl = 63 * n;
3853:                    tot_cyl = sz_disk / sz_cyl;
3854:                
3855:                    /* Create partition table */
3856:                    mem_set(buf, 0, _MAX_SS);
3857:                    p = buf + MBR_Table;
3858:                    b_cyl = 0;
3859:                    for (i = 0; i < 4; i++, p += SZ_PTE) {
3860:                        p_cyl = (szt[i] <= 100) ? (DWORD) tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;
3861:                        if (!p_cyl) continue;
3862:                        s_part = (DWORD) sz_cyl * b_cyl;
3863:                        sz_part = (DWORD) sz_cyl * p_cyl;
3864:                        if (i == 0) { /* Exclude first track of cylinder 0 */
3865:                            s_hd = 1;
3866:                            s_part += 63;
3867:                            sz_part -= 63;
3868:                        } else {
3869:                            s_hd = 0;
3870:                        }
3871:                        e_cyl = b_cyl + p_cyl - 1;
3872:                        if (e_cyl >= tot_cyl) return FR_INVALID_PARAMETER;
3873:                
3874:                        /* Set partition table */
3875:                        p[1] = s_hd; /* Start head */
3876:                        p[2] = (BYTE) ((b_cyl >> 2) + 1); /* Start sector */
3877:                        p[3] = (BYTE) b_cyl; /* Start cylinder */
3878:                        p[4] = 0x06; /* System type (temporary setting) */
3879:                        p[5] = e_hd; /* End head */
3880:                        p[6] = (BYTE) ((e_cyl >> 2) + 63); /* End sector */
3881:                        p[7] = (BYTE) e_cyl; /* End cylinder */
3882:                        ST_DWORD(p + 8, s_part); /* Start sector in LBA */
3883:                        ST_DWORD(p + 12, sz_part); /* Partition size */
3884:                
3885:                        /* Next partition */
3886:                        b_cyl += p_cyl;
3887:                    }
3888:                    ST_WORD(p, 0xAA55);
3889:                
3890:                    /* Write it to the MBR */
3891:                    return (disk_write(pdrv, buf, 0, 1) || disk_ioctl(pdrv, CTRL_SYNC, 0)) ? FR_DISK_ERR : FR_OK;
3892:                }
3893:                
3894:                
3895:                #endif /* _MULTI_PARTITION == 2 */
3896:                #endif /* _USE_MKFS && !_FS_READONLY */
3897:                
3898:                
3899:                
3900:                
3901:                #if _USE_STRFUNC
3902:                /*-----------------------------------------------------------------------*/
3903:                /* Get a string from the file                                            */
3904:                
3905:                /*-----------------------------------------------------------------------*/
3906:                TCHAR* f_gets(
3907:                        TCHAR* buff, /* Pointer to the string buffer to read */
3908:                        int len, /* Size of string buffer (characters) */
3909:                        FIL* fil /* Pointer to the file object */
3910:                        ) {
3911:                    int n = 0;
3912:                    TCHAR c, *p = buff;
3913:                    BYTE s[2];
3914:                    UINT rc;
3915:                
3916:                
3917:                    while (n < len - 1) { /* Read bytes until buffer gets filled */
3918:                        f_read(fil, s, 1, &rc);
3919:                        if (rc != 1) break; /* Break on EOF or error */
3920:                        c = s[0];
3921:                #if _LFN_UNICODE					/* Read a character in UTF-8 encoding */
3922:                        if (c >= 0x80) {
3923:                            if (c < 0xC0) continue; /* Skip stray trailer */
3924:                            if (c < 0xE0) { /* Two-byte sequense */
3925:                                f_read(fil, s, 1, &rc);
3926:                                if (rc != 1) break;
3927:                                c = ((c & 0x1F) << 6) | (s[0] & 0x3F);
3928:                                if (c < 0x80) c = '?';
3929:                            } else {
3930:                                if (c < 0xF0) { /* Three-byte sequense */
3931:                                    f_read(fil, s, 2, &rc);
3932:                                    if (rc != 2) break;
3933:                                    c = (c << 12) | ((s[0] & 0x3F) << 6) | (s[1] & 0x3F);
3934:                                    if (c < 0x800) c = '?';
3935:                                } else { /* Reject four-byte sequense */
3936:                                    c = '?';
3937:                                }
3938:                            }
3939:                        }
3940:                #endif
3941:                #if _USE_STRFUNC >= 2
3942:                        if (c == '\r') continue; /* Strip '\r' */
3943:                #endif
3944:                        *p++ = c;
3945:                        n++;
3946:                        if (c == '\n') break; /* Break on EOL */
3947:                    }
3948:                    *p = 0;
3949:                    return n ? buff : 0; /* When no data read (eof or error), return with error. */
3950:                }
3951:                
3952:                
3953:                
3954:                #if !_FS_READONLY
3955:                #include <stdarg.h>
3956:                /*-----------------------------------------------------------------------*/
3957:                /* Put a character to the file                                           */
3958:                
3959:                /*-----------------------------------------------------------------------*/
3960:                int f_putc(
3961:                        TCHAR c, /* A character to be output */
3962:                        FIL* fil /* Pointer to the file object */
3963:                        ) {
3964:                    UINT bw, btw;
3965:                    BYTE s[3];
3966:                
3967:                
3968:                #if _USE_STRFUNC >= 2
3969:                    if (c == '\n') f_putc('\r', fil); /* LF -> CRLF conversion */
3970:                #endif
3971:                
3972:                #if _LFN_UNICODE	/* Write the character in UTF-8 encoding */
3973:                    if (c < 0x80) { /* 7-bit */
3974:                        s[0] = (BYTE) c;
3975:                        btw = 1;
3976:                    } else {
3977:                        if (c < 0x800) { /* 11-bit */
3978:                            s[0] = (BYTE) (0xC0 | (c >> 6));
3979:                            s[1] = (BYTE) (0x80 | (c & 0x3F));
3980:                            btw = 2;
3981:                        } else { /* 16-bit */
3982:                            s[0] = (BYTE) (0xE0 | (c >> 12));
3983:                            s[1] = (BYTE) (0x80 | ((c >> 6) & 0x3F));
3984:                            s[2] = (BYTE) (0x80 | (c & 0x3F));
3985:                            btw = 3;
3986:                        }
3987:                    }
3988:                #else				/* Write the character without conversion */
3989:                    s[0] = (BYTE) c;
3990:                    btw = 1;
3991:                #endif
3992:                    f_write(fil, s, btw, &bw); /* Write the char to the file */
3993:                    return (bw == btw) ? 1 : EOF; /* Return the result */
3994:                }
3995:                
3996:                
3997:                
3998:                
3999:                /*-----------------------------------------------------------------------*/
4000:                /* Put a string to the file                                              */
4001:                
4002:                /*-----------------------------------------------------------------------*/
4003:                int f_puts(
4004:                        const TCHAR* str, /* Pointer to the string to be output */
4005:                        FIL* fil /* Pointer to the file object */
4006:                        ) {
4007:                    int n;
4008:                
4009:                
4010:                    for (n = 0; *str; str++, n++) {
4011:                        if (f_putc(*str, fil) == EOF) return EOF;
4012:                    }
4013:                    return n;
4014:                }
4015:                
4016:                
4017:                
4018:                
4019:                /*-----------------------------------------------------------------------*/
4020:                /* Put a formatted string to the file                                    */
4021:                
4022:                /*-----------------------------------------------------------------------*/
4023:                int f_printf(
4024:                        FIL* fil, /* Pointer to the file object */
4025:                        const TCHAR* str, /* Pointer to the format string */
4026:                        ... /* Optional arguments... */
4027:                        ) {
4028:                    va_list arp;
4029:                    BYTE f, r;
4030:                    UINT i, j, w;
4031:                    ULONG v;
4032:                    TCHAR c, d, s[16], *p;
4033:                    int res, chc, cc;
4034:                
4035:                
4036:                    va_start(arp, str);
4037:                
4038:                    for (cc = res = 0; cc != EOF; res += cc) {
4039:                        c = *str++;
4040:                        if (c == 0) break; /* End of string */
4041:                        if (c != '%') { /* Non escape character */
4042:                            cc = f_putc(c, fil);
4043:                            if (cc != EOF) cc = 1;
4044:                            continue;
4045:                        }
4046:                        w = f = 0;
4047:                        c = *str++;
4048:                        if (c == '0') { /* Flag: '0' padding */
4049:                            f = 1;
4050:                            c = *str++;
4051:                        } else {
4052:                            if (c == '-') { /* Flag: left justified */
4053:                                f = 2;
4054:                                c = *str++;
4055:                            }
4056:                        }
4057:                        while (IsDigit(c)) { /* Precision */
4058:                            w = w * 10 + c - '0';
4059:                            c = *str++;
4060:                        }
4061:                        if (c == 'l' || c == 'L') { /* Prefix: Size is long int */
4062:                            f |= 4;
4063:                            c = *str++;
4064:                        }
4065:                        if (!c) break;
4066:                        d = c;
4067:                        if (IsLower(d)) d -= 0x20;
4068:                        switch (d) { /* Type is... */
4069:                            case 'S': /* String */
4070:                                p = va_arg(arp, TCHAR*);
4071:                                for (j = 0; p[j]; j++);
4072:                                chc = 0;
4073:                                if (!(f & 2)) {
4074:                                    while (j++ < w) chc += (cc = f_putc(' ', fil));
4075:                                }
4076:                                chc += (cc = f_puts(p, fil));
4077:                                while (j++ < w) chc += (cc = f_putc(' ', fil));
4078:                                if (cc != EOF) cc = chc;
4079:                                continue;
4080:                            case 'C': /* Character */
4081:                                cc = f_putc((TCHAR) va_arg(arp, int), fil);
4082:                                continue;
4083:                            case 'B': /* Binary */
4084:                                r = 2;
4085:                                break;
4086:                            case 'O': /* Octal */
4087:                                r = 8;
4088:                                break;
4089:                            case 'D': /* Signed decimal */
4090:                            case 'U': /* Unsigned decimal */
4091:                                r = 10;
4092:                                break;
4093:                            case 'X': /* Hexdecimal */
4094:                                r = 16;
4095:                                break;
4096:                            default: /* Unknown type (passthrough) */
4097:                                cc = f_putc(c, fil);
4098:                                continue;
4099:                        }
4100:                
4101:                        /* Get an argument and put it in numeral */
4102:                        v = (f & 4) ? (ULONG) va_arg(arp, long) : ((d == 'D') ? (ULONG) (long) va_arg(arp, int) : (ULONG) va_arg(arp, unsigned int));
4103:                        if (d == 'D' && (v & 0x80000000)) {
4104:                            v = 0 - v;
4105:                            f |= 8;
4106:                        }
4107:                        i = 0;
4108:                        do {
4109:                            d = (TCHAR) (v % r);
4110:                            v /= r;
4111:                            if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
4112:                            s[i++] = d + '0';
4113:                        } while (v && i < sizeof (s) / sizeof (s[0]));
4114:                        if (f & 8) s[i++] = '-';
4115:                        j = i;
4116:                        d = (f & 1) ? '0' : ' ';
4117:                        res = 0;
4118:                        while (!(f & 2) && j++ < w) res += (cc = f_putc(d, fil));
4119:                        do res += (cc = f_putc(s[--i], fil)); while (i);
4120:                        while (j++ < w) res += (cc = f_putc(' ', fil));
4121:                        if (cc != EOF) cc = res;
4122:                    }
4123:                
4124:                    va_end(arp);
4125:                    return (cc == EOF) ? cc : res;
4126:                }
4127:                
4128:                #endif /* !_FS_READONLY */
4129:                #endif /* _USE_STRFUNC */
---  /Users/mikechi/Dropbox/Cognionics/Projects/EEG 64/Firmware/PIC32 DAQ/EEG64-PIC32.X/fatfs/IOFunc_mike.c
1:                   /*
2:                   Mike Chi 5-25-12
3:                   Steps to port SD Card Functions
4:                   1. Follow instructions in mmc.c to configure fatfs's spi functions
5:                   2. Modify SDPowerUp to correct spi pins
6:                   3. Don't forget pull-ups!
7:                   4. Fatfs occupies timer1, don't use it elsewhere
8:                    */
9:                   
10:                  #include <xc.h>
11:                  #include <plib.h>
12:                  #include "../port_defs.h"
13:                  #include "integer.h"
14:                  #include "ff.h"
15:                  #include "diskio.h"
16:                  #include "IOFunc.h"
17:                  #include "../memory_buffer.h"
18:                  
19:                  //THESE TWO LIBRAIES NEED A HEAP TO WORK. DONT FORGET ABOUT ALLOCATING A HEAP!
20:                  #include <string.h>
21:                  #include <stdio.h>
22:                  
23:                  #define BUFFERSIZE	MEMBUFLEN/2 //size of each ping-pong buffer, half of the total memory buffer
24:                  #define TIMEOUT		100   //times to try file system operation before fail
25:                  #define PREALLOCATE     576000000/32
26:                  
27:                  char* SDBUF0;
28:                  char* SDBUF1;
29:                  
30:                  //IOFunc internal variables for file system handles
31:                  unsigned int ByteWritten;
32:                  FIL fil_obj;
33:                  FATFS FATFS_Obj;
34:                  
35:                  //filename defs
36:                  char EEG[] = "exg_";
37:                  char COG[] = ".cog";
38:                  
39:                  
40:                  //Buffer Status Variables
41:                  volatile int current_buffer = 0; //current buffer that is receving data
42:                  volatile int buf0_write = 0; //buffer 0 needs to be written out
43:                  volatile int buf1_write = 0; //buffer 1 needs to be written out
44:                  volatile int buf0_ptr = 0; //buffer 0 index
45:                  volatile int buf1_ptr = 0; //buffer 1 index
46:                  
47:                  //0 - card is not ready for writing
48:                  //1 - card is good to go with valid file open
49:                  volatile int SD_ready_to_write = 0;
50:                  
51:                  
52:                  /*---------------------------------------------------------*/
53:                  /* User Provided RTC Function for FatFs module             */
54:                  /*---------------------------------------------------------*/
55:                  /* This is a real time clock service to be called from     */
56:                  /* FatFs module. Any valid time must be returned even if   */
57:                  /* the system does not support an RTC.                     */
58:                  /* This function is not required in read-only cfg.         */
59:                  
60:                  //return dummy time
61:                  DWORD get_fattime(void);
62:                  
63:                  DWORD get_fattime(void) {
9D00B198  27BDFFF8   ADDIU SP, SP, -8
9D00B19C  AFBE0004   SW S8, 4(SP)
9D00B1A0  03A0F021   ADDU S8, SP, ZERO
64:                      return 0;
9D00B1A4  00001021   ADDU V0, ZERO, ZERO
65:                  }
9D00B1A8  03C0E821   ADDU SP, S8, ZERO
9D00B1AC  8FBE0004   LW S8, 4(SP)
9D00B1B0  27BD0008   ADDIU SP, SP, 8
9D00B1B4  03E00008   JR RA
9D00B1B8  00000000   NOP
66:                  
67:                  /*
68:                  Inits spi ports, FatFs and Timer Interrupt and turns on power for card
69:                  0 - success
70:                  1- failure
71:                   */
72:                  void SDPortInit() {
9D00B1BC  27BDFFE8   ADDIU SP, SP, -24
9D00B1C0  AFBF0014   SW RA, 20(SP)
9D00B1C4  AFBE0010   SW S8, 16(SP)
9D00B1C8  03A0F021   ADDU S8, SP, ZERO
73:                      
74:                      //Assign I/O directions to pins
75:                      TRISFbits.TRISF5 = 0; //SD DI
9D00B1CC  3C03BF88   LUI V1, -16504
9D00B1D0  8C626140   LW V0, 24896(V1)
9D00B1D4  7C022944   INS V0, ZERO, 5, 1
9D00B1D8  AC626140   SW V0, 24896(V1)
76:                      TRISFbits.TRISF4 = 1; //SD DO
9D00B1DC  3C03BF88   LUI V1, -16504
9D00B1E0  8C626140   LW V0, 24896(V1)
9D00B1E4  24040001   ADDIU A0, ZERO, 1
9D00B1E8  7C822104   INS V0, A0, 4, 1
9D00B1EC  AC626140   SW V0, 24896(V1)
77:                      TRISBbits.TRISB14 = 0; //SD SCK
9D00B1F0  3C03BF88   LUI V1, -16504
9D00B1F4  8C626040   LW V0, 24640(V1)
9D00B1F8  7C027384   INS V0, ZERO, 14, 1
9D00B1FC  AC626040   SW V0, 24640(V1)
78:                      TRISBbits.TRISB3 = 0; //SD CS
9D00B200  3C03BF88   LUI V1, -16504
9D00B204  8C626040   LW V0, 24640(V1)
9D00B208  7C0218C4   INS V0, ZERO, 3, 1
9D00B20C  AC626040   SW V0, 24640(V1)
79:                  
80:                      //weak PU on SD SPIIN (PIC)
81:                      CNPUEbits.CNPUE17 = 1;
9D00B210  3C03BF88   LUI V1, -16504
9D00B214  8C6261E0   LW V0, 25056(V1)
9D00B218  24040001   ADDIU A0, ZERO, 1
9D00B21C  7C828C44   INS V0, A0, 17, 1
9D00B220  AC6261E0   SW V0, 25056(V1)
82:                  
83:                      //assign buffer pointers
84:                      SDBUF0 = Buf0Ptr(); //ping pong buffer 1
9D00B224  0F4034CB   JAL Buf0Ptr
9D00B228  00000000   NOP
9D00B22C  AF828070   SW V0, -32656(GP)
85:                      SDBUF1 = Buf1Ptr(); //ping pong buffer 1
9D00B230  0F4034D5   JAL Buf1Ptr
9D00B234  00000000   NOP
9D00B238  AF82806C   SW V0, -32660(GP)
86:                  
87:                      //mount FatFs
88:                      f_mount(0, &FATFS_Obj);
9D00B23C  00002021   ADDU A0, ZERO, ZERO
9D00B240  3C02A001   LUI V0, -24575
9D00B244  2445EAB8   ADDIU A1, V0, -5448
9D00B248  0F400C4E   JAL f_mount
9D00B24C  00000000   NOP
89:                  }
9D00B250  03C0E821   ADDU SP, S8, ZERO
9D00B254  8FBF0014   LW RA, 20(SP)
9D00B258  8FBE0010   LW S8, 16(SP)
9D00B25C  27BD0018   ADDIU SP, SP, 24
9D00B260  03E00008   JR RA
9D00B264  00000000   NOP
90:                  
91:                  /*
92:                  Attempts to initalize SD card
93:                  0 - success
94:                  1- failure
95:                  6-12-12, calling this from the main function is flakey
96:                  will not init disk if it is already inserted on power up
97:                  calling disk_initalize directly from main function seems OK
98:                   */
99:                  
100:                 int SDInitDisk() {
9D00B268  27BDFFE0   ADDIU SP, SP, -32
9D00B26C  AFBF001C   SW RA, 28(SP)
9D00B270  AFBE0018   SW S8, 24(SP)
9D00B274  03A0F021   ADDU S8, SP, ZERO
101:                     //attempt to power up SD Card TIMEOUT times
102:                     int c;
103:                     for (c = 0; c < TIMEOUT; c++) {
9D00B278  AFC00010   SW ZERO, 16(S8)
9D00B27C  0B402CAC   J 0x9D00B2B0
9D00B280  00000000   NOP
9D00B2A4  8FC20010   LW V0, 16(S8)
9D00B2A8  24420001   ADDIU V0, V0, 1
9D00B2AC  AFC20010   SW V0, 16(S8)
9D00B2B0  8FC20010   LW V0, 16(S8)
9D00B2B4  28420064   SLTI V0, V0, 100
9D00B2B8  1440FFF2   BNE V0, ZERO, 0x9D00B284
9D00B2BC  00000000   NOP
104:                         if (disk_initialize(0) == FR_OK) {
9D00B284  00002021   ADDU A0, ZERO, ZERO
9D00B288  0F402045   JAL disk_initialize
9D00B28C  00000000   NOP
9D00B290  14400004   BNE V0, ZERO, 0x9D00B2A4
9D00B294  00000000   NOP
105:                             return 0;
9D00B298  00001021   ADDU V0, ZERO, ZERO
9D00B29C  0B402CB1   J 0x9D00B2C4
9D00B2A0  00000000   NOP
106:                 
107:                         }
108:                     }
109:                     return -1;
9D00B2C0  2402FFFF   ADDIU V0, ZERO, -1
110:                 }
9D00B2C4  03C0E821   ADDU SP, S8, ZERO
9D00B2C8  8FBF001C   LW RA, 28(SP)
9D00B2CC  8FBE0018   LW S8, 24(SP)
9D00B2D0  27BD0020   ADDIU SP, SP, 32
9D00B2D4  03E00008   JR RA
9D00B2D8  00000000   NOP
111:                 
112:                 /*
113:                 Creates new file. Searches for previous file with the same filename heading and creates the next filename in the sequence
114:                 0 - success
115:                 1 - failure
116:                  */
117:                 int SDNewFile() {
9D00B2DC  27BDFFC0   ADDIU SP, SP, -64
9D00B2E0  AFBF003C   SW RA, 60(SP)
9D00B2E4  AFBE0038   SW S8, 56(SP)
9D00B2E8  03A0F021   ADDU S8, SP, ZERO
118:                 
119:                 
120:                     int count = 0;
9D00B2EC  AFC00018   SW ZERO, 24(S8)
121:                     int FileNumber = 0;
9D00B2F0  AFC0001C   SW ZERO, 28(S8)
122:                     FRESULT response;
123:                     char FileName[20];
124:                 
125:                     //reset buffer status variables
126:                     current_buffer = 0;
9D00B2F4  AF808034   SW ZERO, -32716(GP)
127:                     buf0_write = 0;
9D00B2F8  AF808038   SW ZERO, -32712(GP)
128:                     buf1_write = 0;
9D00B2FC  AF80803C   SW ZERO, -32708(GP)
129:                     buf0_ptr = 0;
9D00B300  AF808040   SW ZERO, -32704(GP)
130:                     buf1_ptr = 0;
9D00B304  AF808044   SW ZERO, -32700(GP)
131:                 
132:                     do {
133:                 
134:                         sprintf(FileName, "%s%d%s", EEG, FileNumber, COG);
9D00B308  27C20024   ADDIU V0, S8, 36
9D00B30C  27838018   ADDIU V1, GP, -32744
9D00B310  AFA30010   SW V1, 16(SP)
9D00B314  00402021   ADDU A0, V0, ZERO
9D00B318  3C029D01   LUI V0, -25343
9D00B31C  2445D884   ADDIU A1, V0, -10108
9D00B320  27868010   ADDIU A2, GP, -32752
9D00B324  8FC7001C   LW A3, 28(S8)
9D00B328  0F40349A   JAL _sprintf_cdnopsuxX
9D00B32C  00000000   NOP
135:                 
136:                         response = f_open(&fil_obj, FileName, FA_CREATE_NEW | FA_READ | FA_WRITE);
9D00B330  27C20024   ADDIU V0, S8, 36
9D00B334  3C03A001   LUI V1, -24575
9D00B338  2464E894   ADDIU A0, V1, -5996
9D00B33C  00402821   ADDU A1, V0, ZERO
9D00B340  24060007   ADDIU A2, ZERO, 7
9D00B344  0F400C76   JAL f_open
9D00B348  00000000   NOP
9D00B34C  AFC20020   SW V0, 32(S8)
137:                 
138:                         if (response == FR_EXIST) {
9D00B350  8FC30020   LW V1, 32(S8)
9D00B354  24020008   ADDIU V0, ZERO, 8
9D00B358  14620008   BNE V1, V0, 0x9D00B37C
9D00B35C  00000000   NOP
139:                             f_close(&fil_obj);
9D00B360  3C02A001   LUI V0, -24575
9D00B364  2444E894   ADDIU A0, V0, -5996
9D00B368  0F401161   JAL f_close
9D00B36C  00000000   NOP
140:                             FileNumber += 1;
9D00B370  8FC2001C   LW V0, 28(S8)
9D00B374  24420001   ADDIU V0, V0, 1
9D00B378  AFC2001C   SW V0, 28(S8)
141:                         }
142:                         
143:                         count++;
9D00B37C  8FC20018   LW V0, 24(S8)
9D00B380  24420001   ADDIU V0, V0, 1
9D00B384  AFC20018   SW V0, 24(S8)
144:                         
145:                         if(count==TIMEOUT)
9D00B388  8FC30018   LW V1, 24(S8)
9D00B38C  24020064   ADDIU V0, ZERO, 100
9D00B390  14620004   BNE V1, V0, 0x9D00B3A4
9D00B394  00000000   NOP
146:                         {
147:                             return -1;
9D00B398  2402FFFF   ADDIU V0, ZERO, -1
9D00B39C  0B402CF3   J 0x9D00B3CC
9D00B3A0  00000000   NOP
148:                         }
149:                 
150:                     } while (!(response == FR_OK && response != FR_EXIST));
9D00B3A4  8FC20020   LW V0, 32(S8)
9D00B3A8  1440FFD7   BNE V0, ZERO, 0x9D00B308
9D00B3AC  00000000   NOP
9D00B3B0  8FC30020   LW V1, 32(S8)
9D00B3B4  24020008   ADDIU V0, ZERO, 8
9D00B3B8  1062FFD3   BEQ V1, V0, 0x9D00B308
9D00B3BC  00000000   NOP
151:                 
152:                     /*
153:                     DWORD pre = PREALLOCATE;
154:                 
155:                     f_lseek(&fil_obj, pre);
156:                     f_lseek(&fil_obj, 0);
157:                     */
158:                 
159:                     //flag for sd card and file ready for writing
160:                     SD_ready_to_write = 1;
9D00B3C0  24020001   ADDIU V0, ZERO, 1
9D00B3C4  AF828048   SW V0, -32696(GP)
161:                 
162:                     return 0;
9D00B3C8  00001021   ADDU V0, ZERO, ZERO
163:                 }
9D00B3CC  03C0E821   ADDU SP, S8, ZERO
9D00B3D0  8FBF003C   LW RA, 60(SP)
9D00B3D4  8FBE0038   LW S8, 56(SP)
9D00B3D8  27BD0040   ADDIU SP, SP, 64
9D00B3DC  03E00008   JR RA
9D00B3E0  00000000   NOP
164:                 
165:                 /*
166:                 Closes file, flushes all data in buffer
167:                 0 - success
168:                 1- failure
169:                  */
170:                 int SDCloseFile() {
9D00B3E4  27BDFFE8   ADDIU SP, SP, -24
9D00B3E8  AFBF0014   SW RA, 20(SP)
9D00B3EC  AFBE0010   SW S8, 16(SP)
9D00B3F0  03A0F021   ADDU S8, SP, ZERO
171:                     if (SD_ready_to_write == 1) {
9D00B3F4  8F838048   LW V1, -32696(GP)
9D00B3F8  24020001   ADDIU V0, ZERO, 1
9D00B3FC  1462000E   BNE V1, V0, 0x9D00B438
9D00B400  00000000   NOP
172:                         //flag for sd card and file not ready for writing
173:                         SD_ready_to_write = 0;
9D00B404  AF808048   SW ZERO, -32696(GP)
174:                 
175:                         if (f_close(&fil_obj) != FR_OK)
9D00B408  3C02A001   LUI V0, -24575
9D00B40C  2444E894   ADDIU A0, V0, -5996
9D00B410  0F401161   JAL f_close
9D00B414  00000000   NOP
9D00B418  10400004   BEQ V0, ZERO, 0x9D00B42C
9D00B41C  00000000   NOP
176:                             return -1;
9D00B420  2402FFFF   ADDIU V0, ZERO, -1
9D00B424  0B402D0F   J 0x9D00B43C
9D00B428  00000000   NOP
177:                         else
178:                             return 0;
9D00B42C  00001021   ADDU V0, ZERO, ZERO
9D00B430  0B402D0F   J 0x9D00B43C
9D00B434  00000000   NOP
179:                     } else
180:                         return 0;
9D00B438  00001021   ADDU V0, ZERO, ZERO
181:                 }
9D00B43C  03C0E821   ADDU SP, S8, ZERO
9D00B440  8FBF0014   LW RA, 20(SP)
9D00B444  8FBE0010   LW S8, 16(SP)
9D00B448  27BD0018   ADDIU SP, SP, 24
9D00B44C  03E00008   JR RA
9D00B450  00000000   NOP
182:                 
183:                 /*
184:                 Unmount FatFs
185:                 Power down SD Card
186:                  */
187:                 void SDPowerDown() {
9D00B454  27BDFFE8   ADDIU SP, SP, -24
9D00B458  AFBF0014   SW RA, 20(SP)
9D00B45C  AFBE0010   SW S8, 16(SP)
9D00B460  03A0F021   ADDU S8, SP, ZERO
188:                     //unmount FatFs
189:                     f_mount(0, NULL);
9D00B464  00002021   ADDU A0, ZERO, ZERO
9D00B468  00002821   ADDU A1, ZERO, ZERO
9D00B46C  0F400C4E   JAL f_mount
9D00B470  00000000   NOP
190:                 
191:                 }
9D00B474  03C0E821   ADDU SP, S8, ZERO
9D00B478  8FBF0014   LW RA, 20(SP)
9D00B47C  8FBE0010   LW S8, 16(SP)
9D00B480  27BD0018   ADDIU SP, SP, 24
9D00B484  03E00008   JR RA
9D00B488  00000000   NOP
192:                 
193:                 void SDTest() {
9D00B48C  27BDFFD8   ADDIU SP, SP, -40
9D00B490  AFBF0024   SW RA, 36(SP)
9D00B494  AFBE0020   SW S8, 32(SP)
9D00B498  03A0F021   ADDU S8, SP, ZERO
194:                 
195:                 
196:                     char t1[4];
197:                     int c;
198:                 
199:                     int d;
200:                     for (d=0; d<2000; d++)
9D00B49C  AFC00014   SW ZERO, 20(S8)
9D00B4A0  0B402D47   J 0x9D00B51C
9D00B4A4  00000000   NOP
9D00B510  8FC20014   LW V0, 20(S8)
9D00B514  24420001   ADDIU V0, V0, 1
9D00B518  AFC20014   SW V0, 20(S8)
9D00B51C  8FC20014   LW V0, 20(S8)
9D00B520  284207D0   SLTI V0, V0, 2000
9D00B524  1440FFE0   BNE V0, ZERO, 0x9D00B4A8
9D00B528  00000000   NOP
201:                     for (c = 0; c < 2000; c++) {
9D00B4A8  AFC00010   SW ZERO, 16(S8)
9D00B4AC  0B402D40   J 0x9D00B500
9D00B4B0  00000000   NOP
9D00B4F4  8FC20010   LW V0, 16(S8)
9D00B4F8  24420001   ADDIU V0, V0, 1
9D00B4FC  AFC20010   SW V0, 16(S8)
9D00B500  8FC20010   LW V0, 16(S8)
9D00B504  284207D0   SLTI V0, V0, 2000
9D00B508  1440FFEA   BNE V0, ZERO, 0x9D00B4B4
9D00B50C  00000000   NOP
202:                 
203:                         t1[0] = 'H';
9D00B4B4  24020048   ADDIU V0, ZERO, 72
9D00B4B8  A3C20018   SB V0, 24(S8)
204:                         t1[1] = 'I';
9D00B4BC  24020049   ADDIU V0, ZERO, 73
9D00B4C0  A3C20019   SB V0, 25(S8)
205:                         t1[2] = c;
9D00B4C4  8FC20010   LW V0, 16(S8)
9D00B4C8  7C021420   SEB V0, V0
9D00B4CC  A3C2001A   SB V0, 26(S8)
206:                         t1[3] = '\n';
9D00B4D0  2402000A   ADDIU V0, ZERO, 10
9D00B4D4  A3C2001B   SB V0, 27(S8)
207:                 
208:                         SDWriteBytes(t1, 4);
9D00B4D8  27C20018   ADDIU V0, S8, 24
9D00B4DC  00402021   ADDU A0, V0, ZERO
9D00B4E0  24050004   ADDIU A1, ZERO, 4
9D00B4E4  0F402D9D   JAL SDWriteBytes
9D00B4E8  00000000   NOP
209:                 
210:                         SDUpdate();
9D00B4EC  0F402D59   JAL SDUpdate
9D00B4F0  00000000   NOP
211:                 
212:                     }
213:                 
214:                     f_truncate(&fil_obj);
9D00B52C  3C02A001   LUI V0, -24575
9D00B530  2444E894   ADDIU A0, V0, -5996
9D00B534  0F4015FE   JAL f_truncate
9D00B538  00000000   NOP
215:                     f_close(&fil_obj);
9D00B53C  3C02A001   LUI V0, -24575
9D00B540  2444E894   ADDIU A0, V0, -5996
9D00B544  0F401161   JAL f_close
9D00B548  00000000   NOP
216:                 
217:                 
218:                 }
9D00B54C  03C0E821   ADDU SP, S8, ZERO
9D00B550  8FBF0024   LW RA, 36(SP)
9D00B554  8FBE0020   LW S8, 32(SP)
9D00B558  27BD0028   ADDIU SP, SP, 40
9D00B55C  03E00008   JR RA
9D00B560  00000000   NOP
219:                 
220:                 void SDUpdate() {
9D00B564  27BDFFE8   ADDIU SP, SP, -24
9D00B568  AFBF0014   SW RA, 20(SP)
9D00B56C  AFBE0010   SW S8, 16(SP)
9D00B570  03A0F021   ADDU S8, SP, ZERO
221:                 
222:                     //only execute write function if the SD card and file is ready
223:                     if (SD_ready_to_write == 1) {
9D00B574  8F838048   LW V1, -32696(GP)
9D00B578  24020001   ADDIU V0, ZERO, 1
9D00B57C  14620037   BNE V1, V0, 0x9D00B65C
9D00B580  00000000   NOP
224:                         if (buf0_write == 1) {
9D00B584  8F838038   LW V1, -32712(GP)
9D00B588  24020001   ADDIU V0, ZERO, 1
9D00B58C  14620018   BNE V1, V0, 0x9D00B5F0
9D00B590  00000000   NOP
225:                 
226:                 
227:                             LED_G = 0;
9D00B594  3C03BF88   LUI V1, -16504
9D00B598  8C6260E0   LW V0, 24800(V1)
9D00B59C  7C025AC4   INS V0, ZERO, 11, 1
9D00B5A0  AC6260E0   SW V0, 24800(V1)
228:                             f_write(&fil_obj, SDBUF0, BUFFERSIZE, &ByteWritten);
9D00B5A4  8F828070   LW V0, -32656(GP)
9D00B5A8  3C03A001   LUI V1, -24575
9D00B5AC  2464E894   ADDIU A0, V1, -5996
9D00B5B0  00402821   ADDU A1, V0, ZERO
9D00B5B4  24067400   ADDIU A2, ZERO, 29696
9D00B5B8  27878068   ADDIU A3, GP, -32664
9D00B5BC  0F400F14   JAL f_write
9D00B5C0  00000000   NOP
229:                             f_sync(&fil_obj);
9D00B5C4  3C02A001   LUI V0, -24575
9D00B5C8  2444E894   ADDIU A0, V0, -5996
9D00B5CC  0F4010A5   JAL f_sync
9D00B5D0  00000000   NOP
230:                             LED_G = 1;
9D00B5D4  3C03BF88   LUI V1, -16504
9D00B5D8  8C6260E0   LW V0, 24800(V1)
9D00B5DC  24040001   ADDIU A0, ZERO, 1
9D00B5E0  7C825AC4   INS V0, A0, 11, 1
9D00B5E4  AC6260E0   SW V0, 24800(V1)
231:                             buf0_write = 0;
9D00B5E8  AF808038   SW ZERO, -32712(GP)
232:                             buf0_ptr = 0;
9D00B5EC  AF808040   SW ZERO, -32704(GP)
233:                 
234:                         }
235:                 
236:                         if (buf1_write == 1) {
9D00B5F0  8F83803C   LW V1, -32708(GP)
9D00B5F4  24020001   ADDIU V0, ZERO, 1
9D00B5F8  14620018   BNE V1, V0, 0x9D00B65C
9D00B5FC  00000000   NOP
237:                 
238:                 
239:                             LED_G = 0;
9D00B600  3C03BF88   LUI V1, -16504
9D00B604  8C6260E0   LW V0, 24800(V1)
9D00B608  7C025AC4   INS V0, ZERO, 11, 1
9D00B60C  AC6260E0   SW V0, 24800(V1)
240:                             f_write(&fil_obj, SDBUF1, BUFFERSIZE, &ByteWritten);
9D00B610  8F82806C   LW V0, -32660(GP)
9D00B614  3C03A001   LUI V1, -24575
9D00B618  2464E894   ADDIU A0, V1, -5996
9D00B61C  00402821   ADDU A1, V0, ZERO
9D00B620  24067400   ADDIU A2, ZERO, 29696
9D00B624  27878068   ADDIU A3, GP, -32664
9D00B628  0F400F14   JAL f_write
9D00B62C  00000000   NOP
241:                             f_sync(&fil_obj);
9D00B630  3C02A001   LUI V0, -24575
9D00B634  2444E894   ADDIU A0, V0, -5996
9D00B638  0F4010A5   JAL f_sync
9D00B63C  00000000   NOP
242:                             LED_G = 1;
9D00B640  3C03BF88   LUI V1, -16504
9D00B644  8C6260E0   LW V0, 24800(V1)
9D00B648  24040001   ADDIU A0, ZERO, 1
9D00B64C  7C825AC4   INS V0, A0, 11, 1
9D00B650  AC6260E0   SW V0, 24800(V1)
243:                             buf1_write = 0;
9D00B654  AF80803C   SW ZERO, -32708(GP)
244:                             buf1_ptr = 0;
9D00B658  AF808044   SW ZERO, -32700(GP)
245:                         }
246:                     }
247:                 }
9D00B65C  03C0E821   ADDU SP, S8, ZERO
9D00B660  8FBF0014   LW RA, 20(SP)
9D00B664  8FBE0010   LW S8, 16(SP)
9D00B668  27BD0018   ADDIU SP, SP, 24
9D00B66C  03E00008   JR RA
9D00B670  00000000   NOP
248:                 
249:                 inline void SDWriteBytes(char * data, int byteNum) {
9D00B674  27BDFFF0   ADDIU SP, SP, -16
9D00B678  AFBE000C   SW S8, 12(SP)
9D00B67C  03A0F021   ADDU S8, SP, ZERO
9D00B680  AFC40010   SW A0, 16(S8)
9D00B684  AFC50014   SW A1, 20(S8)
250:                     if (SD_ready_to_write == 1) //update buffers only if file actually onpen
9D00B688  8F838048   LW V1, -32696(GP)
9D00B68C  24020001   ADDIU V0, ZERO, 1
9D00B690  1462003A   BNE V1, V0, 0x9D00B77C
9D00B694  00000000   NOP
251:                     {
252:                         int c;
253:                         for (c = 0; c < byteNum; c++) {
9D00B698  AFC00000   SW ZERO, 0(S8)
9D00B69C  0B402DDA   J 0x9D00B768
9D00B6A0  00000000   NOP
9D00B75C  8FC20000   LW V0, 0(S8)
9D00B760  24420001   ADDIU V0, V0, 1
9D00B764  AFC20000   SW V0, 0(S8)
9D00B768  8FC30000   LW V1, 0(S8)
9D00B76C  8FC20014   LW V0, 20(S8)
9D00B770  0062102A   SLT V0, V1, V0
9D00B774  1440FFCB   BNE V0, ZERO, 0x9D00B6A4
9D00B778  00000000   NOP
254:                             if (current_buffer == 0) {
9D00B6A4  8F828034   LW V0, -32716(GP)
9D00B6A8  14400016   BNE V0, ZERO, 0x9D00B704
9D00B6AC  00000000   NOP
255:                                 SDBUF0[buf0_ptr] = *(data + c);
9D00B6B0  8F838070   LW V1, -32656(GP)
9D00B6B4  8F828040   LW V0, -32704(GP)
9D00B6B8  00621021   ADDU V0, V1, V0
9D00B6BC  8FC30000   LW V1, 0(S8)
9D00B6C0  8FC40010   LW A0, 16(S8)
9D00B6C4  00831821   ADDU V1, A0, V1
9D00B6C8  80630000   LB V1, 0(V1)
9D00B6CC  A0430000   SB V1, 0(V0)
256:                                 buf0_ptr += 1;
9D00B6D0  8F828040   LW V0, -32704(GP)
9D00B6D4  24420001   ADDIU V0, V0, 1
9D00B6D8  AF828040   SW V0, -32704(GP)
257:                                 if (buf0_ptr == BUFFERSIZE) {
9D00B6DC  8F838040   LW V1, -32704(GP)
9D00B6E0  24027400   ADDIU V0, ZERO, 29696
9D00B6E4  1462001D   BNE V1, V0, 0x9D00B75C
9D00B6E8  00000000   NOP
258:                                     current_buffer = 1;
9D00B6EC  24020001   ADDIU V0, ZERO, 1
9D00B6F0  AF828034   SW V0, -32716(GP)
259:                                     buf0_write = 1;
9D00B6F4  24020001   ADDIU V0, ZERO, 1
9D00B6F8  AF828038   SW V0, -32712(GP)
9D00B6FC  0B402DD7   J 0x9D00B75C
9D00B700  00000000   NOP
260:                                 }
261:                             }/*
262:                                 MIKE 2/3 GODDAMN PIECE OF SHIT forgot the else if. with just a regular if, once buf0 is filled up it writes the goddamn data AGAIN to the second buf fucker!
263:                                  */
264:                             else if (current_buffer == 1) {
9D00B704  8F838034   LW V1, -32716(GP)
9D00B708  24020001   ADDIU V0, ZERO, 1
9D00B70C  14620013   BNE V1, V0, 0x9D00B75C
9D00B710  00000000   NOP
265:                                 SDBUF1[buf1_ptr] = *(data + c);
9D00B714  8F83806C   LW V1, -32660(GP)
9D00B718  8F828044   LW V0, -32700(GP)
9D00B71C  00621021   ADDU V0, V1, V0
9D00B720  8FC30000   LW V1, 0(S8)
9D00B724  8FC40010   LW A0, 16(S8)
9D00B728  00831821   ADDU V1, A0, V1
9D00B72C  80630000   LB V1, 0(V1)
9D00B730  A0430000   SB V1, 0(V0)
266:                                 buf1_ptr += 1;
9D00B734  8F828044   LW V0, -32700(GP)
9D00B738  24420001   ADDIU V0, V0, 1
9D00B73C  AF828044   SW V0, -32700(GP)
267:                                 if (buf1_ptr == BUFFERSIZE) {
9D00B740  8F838044   LW V1, -32700(GP)
9D00B744  24027400   ADDIU V0, ZERO, 29696
9D00B748  14620004   BNE V1, V0, 0x9D00B75C
9D00B74C  00000000   NOP
268:                                     current_buffer = 0;
9D00B750  AF808034   SW ZERO, -32716(GP)
269:                                     buf1_write = 1;
9D00B754  24020001   ADDIU V0, ZERO, 1
9D00B758  AF82803C   SW V0, -32708(GP)
270:                                 }
271:                             }
272:                         }
273:                     }
274:                 }
9D00B77C  03C0E821   ADDU SP, S8, ZERO
9D00B780  8FBE000C   LW S8, 12(SP)
9D00B784  27BD0010   ADDIU SP, SP, 16
9D00B788  03E00008   JR RA
9D00B78C  00000000   NOP
---  /Users/mikechi/Dropbox/Cognionics/Projects/EEG 64/Firmware/PIC32 DAQ/EEG64-PIC32.X/bt.c  -----------
1:                   #include <xc.h>
2:                   #include <plib.h>
3:                   #include "port_defs.h"
4:                   #include "pic32_delay.h"
5:                   #include "memory_buffer.h"
6:                   #include "ampedrf.h"
7:                   
8:                   void BTTestDummy();
9:                   void BTTXSeed();
10:                  int BRGGen(int baud);
11:                  
12:                  /*
13:                   * MACROS because PIC crashes on too many function calls inside an interrupt
14:                   */
15:                  #define BTrIncrement() BTrIndex++; if (BTrIndex >= BTBUFSIZE) BTrIndex = 0
16:                  #define BTGetByte() BTBuffer[BTrIndex]; BTrIncrement()
17:                  #define BTwIncrement() BTwIndex++; if (BTwIndex >= BTBUFSIZE) BTwIndex = 0;
18:                  
19:                  #define BTBUFSIZE MEMBUFLEN
20:                  
21:                  //Buffer array and pointers
22:                  volatile int BTrIndex = 0;
23:                  volatile int BTwIndex = 0;
24:                  unsigned char* BTBuffer;
25:                  
26:                  void BTInitPorts()
27:                  {
9D00C030  27BDFFE8   ADDIU SP, SP, -24
9D00C034  AFBF0014   SW RA, 20(SP)
9D00C038  AFBE0010   SW S8, 16(SP)
9D00C03C  03A0F021   ADDU S8, SP, ZERO
28:                      //BT Port Configure
29:                      //BT Reset RE7
30:                      mPORTESetPinsDigitalOut(BIT_7);
9D00C040  3C02BF88   LUI V0, -16504
9D00C044  24030080   ADDIU V1, ZERO, 128
9D00C048  AC436104   SW V1, 24836(V0)
31:                      BT_RST = 1;
9D00C04C  3C03BF88   LUI V1, -16504
9D00C050  8C626060   LW V0, 24672(V1)
9D00C054  24040001   ADDIU A0, ZERO, 1
9D00C058  7C824204   INS V0, A0, 8, 1
9D00C05C  AC626060   SW V0, 24672(V1)
32:                  
33:                      //U2RXA at RG7
34:                      mPORTGSetPinsDigitalIn(BIT_7);
9D00C060  3C02BF88   LUI V0, -16504
9D00C064  24030080   ADDIU V1, ZERO, 128
9D00C068  AC436188   SW V1, 24968(V0)
35:                      //U2TXA at RG8
36:                      mPORTGSetPinsDigitalOut(BIT_8);
9D00C06C  3C02BF88   LUI V0, -16504
9D00C070  24030100   ADDIU V1, ZERO, 256
9D00C074  AC436184   SW V1, 24964(V0)
37:                      
38:                      //U2CTSA at RG9 as input
39:                      mPORTGSetPinsDigitalIn(BIT_9);
9D00C078  3C02BF88   LUI V0, -16504
9D00C07C  24030200   ADDIU V1, ZERO, 512
9D00C080  AC436188   SW V1, 24968(V0)
40:                      //U2RTSA at RG6 as output
41:                      mPORTGSetPinsDigitalOut(BIT_6);
9D00C084  3C02BF88   LUI V0, -16504
9D00C088  24030040   ADDIU V1, ZERO, 64
9D00C08C  AC436184   SW V1, 24964(V0)
42:                  
43:                      //init UART3 for BT config
44:                      //UARTConfigure(UART3, UART_ENABLE_HIGH_SPEED|UART_ENABLE_PINS_TX_RX_ONLY);
45:                      //UARTSetFifoMode(UART3, UART_INTERRUPT_ON_TX_NOT_FULL|UART_INTERRUPT_ON_RX_NOT_EMPTY);
46:                      //UARTSetLineControl(UART3, UART_DATA_SIZE_8_BITS | UART_PARITY_NONE | UART_STOP_BITS_1);
47:                      //UARTEnable(UART3, UART_ENABLE | UART_TX);
48:                  
49:                  
50:                      UARTConfigure(UART2A, UART_ENABLE_PINS_TX_RX_ONLY);
9D00C090  24040002   ADDIU A0, ZERO, 2
9D00C094  00002821   ADDU A1, ZERO, ZERO
9D00C098  0F403545   JAL UARTConfigure
9D00C09C  00000000   NOP
51:                      UARTSetFifoMode(UART2A, UART_INTERRUPT_ON_TX_NOT_FULL | UART_INTERRUPT_ON_RX_NOT_EMPTY);
9D00C0A0  24040002   ADDIU A0, ZERO, 2
9D00C0A4  00002821   ADDU A1, ZERO, ZERO
9D00C0A8  0F4035B1   JAL UARTSetFifoMode
9D00C0AC  00000000   NOP
52:                      UARTSetLineControl(UART2A, UART_DATA_SIZE_8_BITS | UART_PARITY_NONE | UART_STOP_BITS_1);
9D00C0B0  24040002   ADDIU A0, ZERO, 2
9D00C0B4  00002821   ADDU A1, ZERO, ZERO
9D00C0B8  0F4035BB   JAL UARTSetLineControl
9D00C0BC  00000000   NOP
53:                      UARTSetDataRate(UART2A, PBCLK, 19200);
9D00C0C0  24040002   ADDIU A0, ZERO, 2
9D00C0C4  3C020151   LUI V0, 337
9D00C0C8  34458000   ORI A1, V0, -32768
9D00C0CC  24064B00   ADDIU A2, ZERO, 19200
9D00C0D0  0F4034B4   JAL UARTSetDataRate
9D00C0D4  00000000   NOP
54:                      UARTEnable(UART2A, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
9D00C0D8  24040002   ADDIU A0, ZERO, 2
9D00C0DC  24050087   ADDIU A1, ZERO, 135
9D00C0E0  0F40345C   JAL UARTEnable
9D00C0E4  00000000   NOP
55:                  
56:                      while(1)
57:                      {
58:                          U2ATXREG = 0x55;
9D00C0E8  3C02BF80   LUI V0, -16512
9D00C0EC  24030055   ADDIU V1, ZERO, 85
9D00C0F0  AC436420   SW V1, 25632(V0)
59:                      }
9D00C0F4  0B40303A   J 0x9D00C0E8
9D00C0F8  00000000   NOP
60:                  
61:                      LED_G = 1;
62:                      
63:                      //program amped RF module
64:                      AmpRFProg();
65:                  
66:                      //reset UART
67:                      CloseUART1();
68:                      //init UART1 for run
69:                      OpenUART2((UART_EN|UART_NO_PAR_8BIT|UART_MODE_SIMPLEX|UART_DIS_BCLK_CTS_RTS|UART_BRGH_FOUR), (UART_TX_ENABLE|UART_RX_ENABLE|UART_INT_TX_LAST_CH), BRGGen(BT_BAUD));
70:                  
71:                      //set buffer pointer
72:                      BTBuffer = Buf0Ptr();
73:                  
74:                  }
75:                  
76:                  //Checks to see if there is data in buffer and writes to UART if data can be accepeted
77:                  void BTUpdate()
78:                  {
9D00C0FC  27BDFFF8   ADDIU SP, SP, -8
9D00C100  AFBE0004   SW S8, 4(SP)
9D00C104  03A0F021   ADDU S8, SP, ZERO
79:                      while( (BTrIndex != BTwIndex) )
9D00C108  0B403059   J 0x9D00C164
9D00C10C  00000000   NOP
9D00C164  8F83802C   LW V1, -32724(GP)
9D00C168  8F828030   LW V0, -32720(GP)
9D00C16C  1462FFE8   BNE V1, V0, 0x9D00C110
9D00C170  00000000   NOP
80:                      {
81:                          if( U3STAbits.UTXBF==0 )
9D00C110  3C02BF80   LUI V0, -16512
9D00C114  8C426410   LW V0, 25616(V0)
9D00C118  30420200   ANDI V0, V0, 512
9D00C11C  14400011   BNE V0, ZERO, 0x9D00C164
9D00C120  00000000   NOP
82:                          {
83:                              U3TXREG = BTGetByte();
9D00C124  8F838064   LW V1, -32668(GP)
9D00C128  8F82802C   LW V0, -32724(GP)
9D00C12C  00621021   ADDU V0, V1, V0
9D00C130  90420000   LBU V0, 0(V0)
9D00C134  00401821   ADDU V1, V0, ZERO
9D00C138  3C02BF80   LUI V0, -16512
9D00C13C  AC436420   SW V1, 25632(V0)
9D00C140  8F82802C   LW V0, -32724(GP)
9D00C144  24420001   ADDIU V0, V0, 1
9D00C148  AF82802C   SW V0, -32724(GP)
9D00C14C  8F83802C   LW V1, -32724(GP)
9D00C150  3402E800   ORI V0, ZERO, -6144
9D00C154  0062102A   SLT V0, V1, V0
9D00C158  14400002   BNE V0, ZERO, 0x9D00C164
9D00C15C  00000000   NOP
9D00C160  AF80802C   SW ZERO, -32724(GP)
84:                          }
85:                      }
86:                  }
9D00C174  03C0E821   ADDU SP, S8, ZERO
9D00C178  8FBE0004   LW S8, 4(SP)
9D00C17C  27BD0008   ADDIU SP, SP, 8
9D00C180  03E00008   JR RA
9D00C184  00000000   NOP
87:                  
88:                  /*Puts incoming data onto the circular buffer and inits the tx process*/
89:                  void BTTxBytes(unsigned char* dat, int len)
90:                  {
9D00C188  27BDFFF0   ADDIU SP, SP, -16
9D00C18C  AFBE000C   SW S8, 12(SP)
9D00C190  03A0F021   ADDU S8, SP, ZERO
9D00C194  AFC40010   SW A0, 16(S8)
9D00C198  AFC50014   SW A1, 20(S8)
91:                      int c;
92:                  
93:                      for(c=0; c<len; c++)
9D00C19C  AFC00000   SW ZERO, 0(S8)
9D00C1A0  0B40307F   J 0x9D00C1FC
9D00C1A4  00000000   NOP
9D00C1F0  8FC20000   LW V0, 0(S8)
9D00C1F4  24420001   ADDIU V0, V0, 1
9D00C1F8  AFC20000   SW V0, 0(S8)
9D00C1FC  8FC30000   LW V1, 0(S8)
9D00C200  8FC20014   LW V0, 20(S8)
9D00C204  0062102A   SLT V0, V1, V0
9D00C208  1440FFE7   BNE V0, ZERO, 0x9D00C1A8
9D00C20C  00000000   NOP
94:                      {
95:                          BTBuffer[BTwIndex] = *(dat++);
9D00C1A8  8F838064   LW V1, -32668(GP)
9D00C1AC  8F828030   LW V0, -32720(GP)
9D00C1B0  00621021   ADDU V0, V1, V0
9D00C1B4  8FC30010   LW V1, 16(S8)
9D00C1B8  90630000   LBU V1, 0(V1)
9D00C1BC  A0430000   SB V1, 0(V0)
9D00C1C0  8FC20010   LW V0, 16(S8)
9D00C1C4  24420001   ADDIU V0, V0, 1
9D00C1C8  AFC20010   SW V0, 16(S8)
96:                          BTwIncrement();
9D00C1CC  8F828030   LW V0, -32720(GP)
9D00C1D0  24420001   ADDIU V0, V0, 1
9D00C1D4  AF828030   SW V0, -32720(GP)
9D00C1D8  8F838030   LW V1, -32720(GP)
9D00C1DC  3402E800   ORI V0, ZERO, -6144
9D00C1E0  0062102A   SLT V0, V1, V0
9D00C1E4  14400002   BNE V0, ZERO, 0x9D00C1F0
9D00C1E8  00000000   NOP
9D00C1EC  AF808030   SW ZERO, -32720(GP)
97:                      }
98:                      
99:                  }
9D00C210  03C0E821   ADDU SP, S8, ZERO
9D00C214  8FBE000C   LW S8, 12(SP)
9D00C218  27BD0010   ADDIU SP, SP, 16
9D00C21C  03E00008   JR RA
9D00C220  00000000   NOP
100:                 
101:                 int BRGGen(int baud) {
9D00C224  27BDFFE0   ADDIU SP, SP, -32
9D00C228  AFBF001C   SW RA, 28(SP)
9D00C22C  AFBE0018   SW S8, 24(SP)
9D00C230  03A0F021   ADDU S8, SP, ZERO
9D00C234  AFC40020   SW A0, 32(S8)
102:                     double brg_temp = PBCLK / (4 * (double)baud) - 1;
9D00C238  8FC40020   LW A0, 32(S8)
9D00C23C  0F4027E5   JAL litofp
9D00C240  00000000   NOP
9D00C244  00401821   ADDU V1, V0, ZERO
9D00C248  3C029D01   LUI V0, -25343
9D00C24C  00602021   ADDU A0, V1, ZERO
9D00C250  8C45D85C   LW A1, -10148(V0)
9D00C254  0F4026EC   JAL fpmul
9D00C258  00000000   NOP
9D00C25C  3C039D01   LUI V1, -25343
9D00C260  8C64D860   LW A0, -10144(V1)
9D00C264  00402821   ADDU A1, V0, ZERO
9D00C268  0F40275A   JAL __divsf3
9D00C26C  00000000   NOP
9D00C270  00401821   ADDU V1, V0, ZERO
9D00C274  3C029D01   LUI V0, -25343
9D00C278  00602021   ADDU A0, V1, ZERO
9D00C27C  8C45D864   LW A1, -10140(V0)
9D00C280  0F40264F   JAL __subsf3
9D00C284  00000000   NOP
9D00C288  AFC20010   SW V0, 16(S8)
103:                     return (int) (brg_temp + 0.5);
9D00C28C  3C029D01   LUI V0, -25343
9D00C290  8FC40010   LW A0, 16(S8)
9D00C294  8C45D868   LW A1, -10136(V0)
9D00C298  0F402651   JAL fpadd
9D00C29C  00000000   NOP
9D00C2A0  00402021   ADDU A0, V0, ZERO
9D00C2A4  0F40280F   JAL fptosi
9D00C2A8  00000000   NOP
104:                 }
9D00C2AC  03C0E821   ADDU SP, S8, ZERO
9D00C2B0  8FBF001C   LW RA, 28(SP)
9D00C2B4  8FBE0018   LW S8, 24(SP)
9D00C2B8  27BD0020   ADDIU SP, SP, 32
9D00C2BC  03E00008   JR RA
9D00C2C0  00000000   NOP
105:                 
106:                 void BTTestDummy()
107:                 {
9D00C2C4  27BDFFE8   ADDIU SP, SP, -24
9D00C2C8  AFBF0014   SW RA, 20(SP)
9D00C2CC  AFBE0010   SW S8, 16(SP)
9D00C2D0  03A0F021   ADDU S8, SP, ZERO
108:                     while(1)
109:                     {
110:                         U3TXREG = 'U';
9D00C2D4  3C02BF80   LUI V0, -16512
9D00C2D8  24030055   ADDIU V1, ZERO, 85
9D00C2DC  AC436420   SW V1, 25632(V0)
111:                         DelayMS(10);
9D00C2E0  2404000A   ADDIU A0, ZERO, 10
9D00C2E4  0F4031E6   JAL DelayMS
9D00C2E8  00000000   NOP
112:                     }
9D00C2EC  0B4030B5   J 0x9D00C2D4
9D00C2F0  00000000   NOP
113:                 }
---  /Users/mikechi/Dropbox/Cognionics/Projects/EEG 64/Firmware/PIC32 DAQ/EEG64-PIC32.X/ampedrf.c  ------
1:                   #include "port_defs.h"
2:                   #include "xc.h"
3:                   #include "pic32_delay.h"
4:                   #include "ampedrf.h"
5:                   
6:                   void AmpRFEscape();
7:                   void AmpRFWriteCMD(char* cmd);
8:                   void AmpRFDelay();
9:                   int AmpRFBRGGen(int baud);
10:                  
11:                  void AmpRFProg()
12:                  {
9D00C2F4  27BDFFE8   ADDIU SP, SP, -24
9D00C2F8  AFBF0014   SW RA, 20(SP)
9D00C2FC  AFBE0010   SW S8, 16(SP)
9D00C300  03A0F021   ADDU S8, SP, ZERO
13:                      //quick delay
14:                      DelayMS(100);
9D00C304  24040064   ADDIU A0, ZERO, 100
9D00C308  0F4031E6   JAL DelayMS
9D00C30C  00000000   NOP
15:                  
16:                      //set to default Amped RF baud rate
17:                      U3BRG = AmpRFBRGGen(115200.0);
9D00C310  3C020001   LUI V0, 1
9D00C314  3444C200   ORI A0, V0, -15872
9D00C318  0F403127   JAL AmpRFBRGGen
9D00C31C  00000000   NOP
9D00C320  00401821   ADDU V1, V0, ZERO
9D00C324  3C02BF80   LUI V0, -16512
9D00C328  AC436440   SW V1, 25664(V0)
18:                  
19:                      while(1)
20:                      {
21:                          U3TXREG = 0x55;
9D00C32C  3C02BF80   LUI V0, -16512
9D00C330  24030055   ADDIU V1, ZERO, 85
9D00C334  AC436420   SW V1, 25632(V0)
22:                      }
9D00C338  0B4030CB   J 0x9D00C32C
9D00C33C  00000000   NOP
23:                  
24:                      
25:                      AmpRFWriteCMD("AT+AB DefaultLocalName Cog-Mini-6 113");
26:                      
27:                      AmpRFWriteCMD("AT+AB StreamingSerial D");
28:                  
29:                      AmpRFWriteCMD("at+ab config BondingAllowed = true");
30:                      AmpRFWriteCMD("at+ab config CpuMHz = 32");
31:                      AmpRFWriteCMD("at+ab config HciBaudrate = 2000000");
32:                      
33:                      //change baud rate
34:                      AmpRFWriteCMD("AT+AB ChangeBaud 921600");
35:                     
36:                  
37:                  }
38:                  
39:                  void AmpRFEscape()
40:                  {
9D00C340  27BDFFD8   ADDIU SP, SP, -40
9D00C344  AFBF0024   SW RA, 36(SP)
9D00C348  AFBE0020   SW S8, 32(SP)
9D00C34C  03A0F021   ADDU S8, SP, ZERO
41:                      char esc[6] = "^#^$^%";
9D00C350  3C029D01   LUI V0, -25343
9D00C354  8C43D7D0   LW V1, -10288(V0)
9D00C358  AFC30014   SW V1, 20(S8)
9D00C35C  2442D7D0   ADDIU V0, V0, -10288
9D00C360  94420004   LHU V0, 4(V0)
9D00C364  A7C20018   SH V0, 24(S8)
42:                  
43:                      int c = 0;
9D00C368  AFC00010   SW ZERO, 16(S8)
44:                      while(esc[c])
9D00C36C  0B4030E9   J 0x9D00C3A4
9D00C370  00000000   NOP
9D00C3A4  8FC20010   LW V0, 16(S8)
9D00C3A8  27C30010   ADDIU V1, S8, 16
9D00C3AC  00621021   ADDU V0, V1, V0
9D00C3B0  80420004   LB V0, 4(V0)
9D00C3B4  1440FFEF   BNE V0, ZERO, 0x9D00C374
9D00C3B8  00000000   NOP
45:                      {
46:                          U2TXREG = esc[c];
9D00C374  8FC20010   LW V0, 16(S8)
9D00C378  27C30010   ADDIU V1, S8, 16
9D00C37C  00621021   ADDU V0, V1, V0
9D00C380  80420004   LB V0, 4(V0)
9D00C384  00401821   ADDU V1, V0, ZERO
9D00C388  3C02BF80   LUI V0, -16512
9D00C38C  AC436820   SW V1, 26656(V0)
47:                          AmpRFDelay();
9D00C390  0F40311A   JAL AmpRFDelay
9D00C394  00000000   NOP
48:                          c++;
9D00C398  8FC20010   LW V0, 16(S8)
9D00C39C  24420001   ADDIU V0, V0, 1
9D00C3A0  AFC20010   SW V0, 16(S8)
49:                      }
50:                  }
9D00C3BC  03C0E821   ADDU SP, S8, ZERO
9D00C3C0  8FBF0024   LW RA, 36(SP)
9D00C3C4  8FBE0020   LW S8, 32(SP)
9D00C3C8  27BD0028   ADDIU SP, SP, 40
9D00C3CC  03E00008   JR RA
9D00C3D0  00000000   NOP
51:                  
52:                  void AmpRFWriteCMD(char* cmd) {
9D00C3D4  27BDFFE8   ADDIU SP, SP, -24
9D00C3D8  AFBF0014   SW RA, 20(SP)
9D00C3DC  AFBE0010   SW S8, 16(SP)
9D00C3E0  03A0F021   ADDU S8, SP, ZERO
9D00C3E4  AFC40018   SW A0, 24(S8)
53:                      while (*cmd) {
9D00C3E8  0B403106   J 0x9D00C418
9D00C3EC  00000000   NOP
9D00C418  8FC20018   LW V0, 24(S8)
9D00C41C  80420000   LB V0, 0(V0)
9D00C420  1440FFF3   BNE V0, ZERO, 0x9D00C3F0
9D00C424  00000000   NOP
54:                          U2TXREG = *(cmd);
9D00C3F0  8FC20018   LW V0, 24(S8)
9D00C3F4  80420000   LB V0, 0(V0)
9D00C3F8  00401821   ADDU V1, V0, ZERO
9D00C3FC  3C02BF80   LUI V0, -16512
9D00C400  AC436820   SW V1, 26656(V0)
55:                          AmpRFDelay();
9D00C404  0F40311A   JAL AmpRFDelay
9D00C408  00000000   NOP
56:                          cmd++;
9D00C40C  8FC20018   LW V0, 24(S8)
9D00C410  24420001   ADDIU V0, V0, 1
9D00C414  AFC20018   SW V0, 24(S8)
57:                      }
58:                  
59:                      //CRLF
60:                      U2TXREG = 13;
9D00C428  3C02BF80   LUI V0, -16512
9D00C42C  2403000D   ADDIU V1, ZERO, 13
9D00C430  AC436820   SW V1, 26656(V0)
61:                      AmpRFDelay();
9D00C434  0F40311A   JAL AmpRFDelay
9D00C438  00000000   NOP
62:                  
63:                      U2TXREG = 10;
9D00C43C  3C02BF80   LUI V0, -16512
9D00C440  2403000A   ADDIU V1, ZERO, 10
9D00C444  AC436820   SW V1, 26656(V0)
64:                      AmpRFDelay();
9D00C448  0F40311A   JAL AmpRFDelay
9D00C44C  00000000   NOP
65:                  }
9D00C450  03C0E821   ADDU SP, S8, ZERO
9D00C454  8FBF0014   LW RA, 20(SP)
9D00C458  8FBE0010   LW S8, 16(SP)
9D00C45C  27BD0018   ADDIU SP, SP, 24
9D00C460  03E00008   JR RA
9D00C464  00000000   NOP
66:                  
67:                  void AmpRFDelay() {
9D00C468  27BDFFE8   ADDIU SP, SP, -24
9D00C46C  AFBF0014   SW RA, 20(SP)
9D00C470  AFBE0010   SW S8, 16(SP)
9D00C474  03A0F021   ADDU S8, SP, ZERO
68:                      DelayMS(10);
9D00C478  2404000A   ADDIU A0, ZERO, 10
9D00C47C  0F4031E6   JAL DelayMS
9D00C480  00000000   NOP
69:                  }
9D00C484  03C0E821   ADDU SP, S8, ZERO
9D00C488  8FBF0014   LW RA, 20(SP)
9D00C48C  8FBE0010   LW S8, 16(SP)
9D00C490  27BD0018   ADDIU SP, SP, 24
9D00C494  03E00008   JR RA
9D00C498  00000000   NOP
70:                  
71:                  int AmpRFBRGGen(int baud) {
9D00C49C  27BDFFE0   ADDIU SP, SP, -32
9D00C4A0  AFBF001C   SW RA, 28(SP)
9D00C4A4  AFBE0018   SW S8, 24(SP)
9D00C4A8  03A0F021   ADDU S8, SP, ZERO
9D00C4AC  AFC40020   SW A0, 32(S8)
72:                      double brg_temp = PBCLK / (4 * (double)baud) - 1;
9D00C4B0  8FC40020   LW A0, 32(S8)
9D00C4B4  0F4027E5   JAL litofp
9D00C4B8  00000000   NOP
9D00C4BC  00401821   ADDU V1, V0, ZERO
9D00C4C0  3C029D01   LUI V0, -25343
9D00C4C4  00602021   ADDU A0, V1, ZERO
9D00C4C8  8C45D7D8   LW A1, -10280(V0)
9D00C4CC  0F4026EC   JAL fpmul
9D00C4D0  00000000   NOP
9D00C4D4  3C039D01   LUI V1, -25343
9D00C4D8  8C64D7DC   LW A0, -10276(V1)
9D00C4DC  00402821   ADDU A1, V0, ZERO
9D00C4E0  0F40275A   JAL __divsf3
9D00C4E4  00000000   NOP
9D00C4E8  00401821   ADDU V1, V0, ZERO
9D00C4EC  3C029D01   LUI V0, -25343
9D00C4F0  00602021   ADDU A0, V1, ZERO
9D00C4F4  8C45D7E0   LW A1, -10272(V0)
9D00C4F8  0F40264F   JAL __subsf3
9D00C4FC  00000000   NOP
9D00C500  AFC20010   SW V0, 16(S8)
73:                      return (int) (brg_temp + 0.5);
9D00C504  3C029D01   LUI V0, -25343
9D00C508  8FC40010   LW A0, 16(S8)
9D00C50C  8C45D7E4   LW A1, -10268(V0)
9D00C510  0F402651   JAL fpadd
9D00C514  00000000   NOP
9D00C518  00402021   ADDU A0, V0, ZERO
9D00C51C  0F40280F   JAL fptosi
9D00C520  00000000   NOP
74:                  }
9D00C524  03C0E821   ADDU SP, S8, ZERO
9D00C528  8FBF001C   LW RA, 28(SP)
9D00C52C  8FBE0018   LW S8, 24(SP)
9D00C530  27BD0020   ADDIU SP, SP, 32
9D00C534  03E00008   JR RA
9D00C538  00000000   NOP
75:                  
---  /Applications/microchip/xc32/v1.21/pic32mx/include/peripheral/system.h  ----------------------------
1:                   /********************************************************************
2:                   
3:                   	System Library Interface Definition
4:                   	
5:                   	Summary:
6:                   		This file contains the interface definition for the System
7:                   		peripheral library.
8:                   		
9:                   	Description:
10:                  		This library provides functions for configuring the peripheral
11:                  		clock, cache settings, and wait states.  For details on the
12:                  		register and bit settings used by these functions, refer to the
13:                  		PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:		System.h
20:                   * Dependencies:
21:                   * Processor:		PIC32
22:                   * Hardware:		N/A
23:                   * Assembler:		N/A
24:                   * Linker:		    N/A
25:                   * Company:		    Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the Company) for its PICmicro Microcontroller is intended and
30:                   * supplied to you, the Companys customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                   
51:                   
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
67:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
68:                  
69:                  /*********************************************************************
70:                   * SYSTEMConfig Flags
71:                   *********************************************************************/
72:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
73:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
74:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
75:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
76:                  
77:                  /*********************************************************************
78:                   Function:       
79:                  	unsigned int SYSTEMConfigPB(unsigned int sys_clock)
80:                   
81:                   Description:
82:                  	The function sets the PB divider to the optimum value.
83:                   
84:                   PreCondition:    
85:                  	None
86:                   
87:                   Parameters:           
88:                  	sys_clock - system clock in Hz
89:                   
90:                   Returns:          
91:                  	the PB clock frequency in Hz
92:                   
93:                   Side Effects:
94:                  	The PB clock may be changed
95:                  	
96:                   Overview:	    
97:                  	The function sets the PB divider to the optimum value.
98:                   
99:                   Remarks:            
100:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
101:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
102:                  
103:                  Example:
104:                 	<code>
105:                 	SYSTEMConfigPB(72000000);
106:                 	</code>
107:                  ********************************************************************/
108:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
109:                 {
110:                     unsigned int pb_div;
111:                     unsigned int pb_clock;
112:                 
113:                     pb_clock = sys_clock;
9D00AA30  8FC20020   LW V0, 32(S8)
9D00AA34  AFC20024   SW V0, 36(S8)
114:                 
115:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
9D00AA38  8FC30020   LW V1, 32(S8)
9D00AA3C  3C0204C4   LUI V0, 1220
9D00AA40  3442B401   ORI V0, V0, -19455
9D00AA44  0062102B   SLTU V0, V1, V0
9D00AA48  14400008   BNE V0, ZERO, 0x9D00AA6C
9D00AA4C  00000000   NOP
116:                     {
117:                         pb_div=OSC_PB_DIV_2;
9D00AA50  3C020008   LUI V0, 8
9D00AA54  AFC20028   SW V0, 40(S8)
118:                         pb_clock >>= 1;
9D00AA58  8FC20024   LW V0, 36(S8)
9D00AA5C  00021042   SRL V0, V0, 1
9D00AA60  AFC20024   SW V0, 36(S8)
9D00AA64  0B402A9C   J 0x9D00AA70
9D00AA68  00000000   NOP
119:                     }
120:                     else
121:                     {
122:                         pb_div=OSC_PB_DIV_1;
9D00AA6C  AFC00028   SW ZERO, 40(S8)
9D00AA70  8FC20028   LW V0, 40(S8)
9D00AA74  AFC2002C   SW V0, 44(S8)
123:                     }
124:                 
125:                     OSCSetPBDIV(pb_div);
126:                 
127:                     return pb_clock;
9D00ABC4  8FC20024   LW V0, 36(S8)
128:                 }
129:                 
130:                 
131:                 /*********************************************************************
132:                   Function:        
133:                 	void SYSTEMConfigWaitStates(unsigned int sys_clock)
134:                  
135:                   Description:
136:                 	The function sets the Flash Wait states to the optimum value.
137:                  
138:                   PreCondition:    
139:                 	None
140:                  
141:                   Parameters:           
142:                 	sys_clock - system clock in Hz
143:                  
144:                   Returns:          
145:                 	None
146:                  
147:                   Side Effects:    
148:                 	The Wait States may be changed  
149:                  
150:                   Remarks:         
151:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
152:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
153:                  
154:                   Example:
155:                 	<code>
156:                 	SYSTEMConfigWaitStates(72000000);
157:                 	</code>
158:                  ********************************************************************/
159:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
160:                 {
161:                 #ifdef _PCACHE
162:                     unsigned int wait_states;
163:                     unsigned int int_status;
164:                 #endif
165:                 
166:                 #ifdef _PCACHE
167:                     wait_states = 0;
168:                 
169:                     while(sys_clock > FLASH_SPEED_HZ)
170:                     {
171:                         wait_states++;
172:                         sys_clock -= FLASH_SPEED_HZ;
173:                     }
174:                 
175:                     int_status=INTDisableInterrupts();
176:                     mCheConfigure(wait_states);
177:                     INTRestoreInterrupts(int_status);
178:                 
179:                 #endif
180:                 }
181:                 
182:                 /*********************************************************************
183:                   Function:        
184:                 		unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
185:                   
186:                   Description:
187:                 	The function sets the PB divider and the Flash Wait states to the optimum value.
188:                  
189:                   PreCondition:    
190:                 	None
191:                  
192:                   Parameters:           
193:                 	sys_clock - system clock in Hz
194:                  
195:                   Returns:          
196:                 	the PB clock frequency in Hz
197:                  
198:                   Side Effects:    
199:                 	The PB clock and wait states may be changed
200:                 
201:                   Remarks:            
202:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
203:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
204:                  
205:                   Example:
206:                 	<code>
207:                 	SYSTEMConfigWaitStatesAndPB(72000000);
208:                 	</code>
209:                  ********************************************************************/
210:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
211:                 {
212:                 #ifdef _PCACHE
213:                     unsigned int wait_states;
214:                 #endif
215:                     unsigned int pb_clock;
216:                     unsigned int int_status;
217:                 
218:                     pb_clock = SYSTEMConfigPB(sys_clock);
9D00ABC8  AFC20044   SW V0, 68(S8)
219:                 
220:                 
221:                     // set the flash wait states based on 1 wait state
222:                     // for every 20 MHz
223:                 #ifdef _PCACHE
224:                     wait_states = 0;
9D00ABCC  AFC00048   SW ZERO, 72(S8)
9D00ABD0  0B402AFE   J 0x9D00ABF8
9D00ABD4  00000000   NOP
225:                 
226:                     while(sys_clock > FLASH_SPEED_HZ)
9D00ABF8  8FC3001C   LW V1, 28(S8)
9D00ABFC  3C0201C9   LUI V0, 457
9D00AC00  3442C381   ORI V0, V0, -15487
9D00AC04  0062102B   SLTU V0, V1, V0
9D00AC08  1040FFF3   BEQ V0, ZERO, 0x9D00ABD8
9D00AC0C  00000000   NOP
227:                     {
228:                         wait_states++;
9D00ABD8  8FC20048   LW V0, 72(S8)
9D00ABDC  24420001   ADDIU V0, V0, 1
9D00ABE0  AFC20048   SW V0, 72(S8)
229:                         sys_clock -= FLASH_SPEED_HZ;
9D00ABE4  8FC3001C   LW V1, 28(S8)
9D00ABE8  3C02FE36   LUI V0, -458
9D00ABEC  34423C80   ORI V0, V0, 15488
9D00ABF0  00621021   ADDU V0, V1, V0
9D00ABF4  AFC2001C   SW V0, 28(S8)
230:                     }
231:                 
232:                     int_status=INTDisableInterrupts();
9D00AC10  0F403623   JAL INTDisableInterrupts
9D00AC14  00000000   NOP
9D00AC18  AFC2004C   SW V0, 76(S8)
233:                     mCheConfigure(wait_states);
9D00AC1C  3C02BF88   LUI V0, -16504
9D00AC20  8FC30048   LW V1, 72(S8)
9D00AC24  AC434000   SW V1, 16384(V0)
234:                     INTRestoreInterrupts(int_status);
9D00AC28  8FC4004C   LW A0, 76(S8)
9D00AC2C  0F4035ED   JAL INTRestoreInterrupts
9D00AC30  00000000   NOP
235:                 
236:                 #endif
237:                 
238:                     return pb_clock;
9D00AC34  8FC20044   LW V0, 68(S8)
239:                 }
240:                 /*********************************************************************
241:                   Function:       
242:                 	unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
243:                  
244:                   Description:
245:                 	The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
246:                     It also enables the cacheability for the K0 segment.
247:                 	
248:                   PreCondition:    
249:                 	None
250:                  
251:                   Parameters:           
252:                 	sys_clock - system clock in Hz
253:                  
254:                   Output:          
255:                 	the PB clock frequency in Hz
256:                  
257:                   Side Effects:    
258:                 	Sets the PB and Flash Wait states
259:                  	
260:                   Remarks:            
261:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
262:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
263:                  
264:                   Example:
265:                 	<code>
266:                 	SYSTEMConfigPerformance(72000000);
267:                 	</code>
268:                  ********************************************************************/
269:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
270:                 {
271:                     // set up the wait states
272:                     unsigned int pb_clk;
273:                 #ifdef _PCACHE
274:                     unsigned int cache_status;
275:                 #endif
276:                     unsigned int int_status;
277:                 
278:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
9D00AC38  AFC20050   SW V0, 80(S8)
279:                 
280:                     int_status=INTDisableInterrupts();
9D00AC3C  0F403623   JAL INTDisableInterrupts
9D00AC40  00000000   NOP
9D00AC44  AFC20054   SW V0, 84(S8)
281:                 
282:                     mBMXDisableDRMWaitState();
9D00AC48  3C02BF88   LUI V0, -16504
9D00AC4C  24030040   ADDIU V1, ZERO, 64
9D00AC50  AC432004   SW V1, 8196(V0)
283:                 
284:                 #ifdef _PCACHE
285:                     cache_status = mCheGetCon();
9D00AC54  3C02BF88   LUI V0, -16504
9D00AC58  8C424000   LW V0, 16384(V0)
9D00AC5C  AFC20058   SW V0, 88(S8)
286:                     cache_status |= CHE_CONF_PF_ALL;
9D00AC60  8FC20058   LW V0, 88(S8)
9D00AC64  34420030   ORI V0, V0, 48
9D00AC68  AFC20058   SW V0, 88(S8)
287:                     mCheConfigure(cache_status);
9D00AC6C  3C02BF88   LUI V0, -16504
9D00AC70  8FC30058   LW V1, 88(S8)
9D00AC74  AC434000   SW V1, 16384(V0)
288:                     CheKseg0CacheOn();
9D00AC78  0F403600   JAL CheKseg0CacheOn
9D00AC7C  00000000   NOP
289:                 #endif
290:                 
291:                     INTRestoreInterrupts(int_status);
9D00AC80  8FC40054   LW A0, 84(S8)
9D00AC84  0F4035ED   JAL INTRestoreInterrupts
9D00AC88  00000000   NOP
292:                 
293:                     return pb_clk;
294:                 
295:                 }
296:                 /*********************************************************************
297:                   Function:       
298:                 	unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
299:                  
300:                   Description:
301:                 	The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value, 
302:                 	based on the flags selected and on the frequency of the system clock.
303:                     It also enables the cacheability for the K0 segment.
304:                 				   
305:                   PreCondition:    
306:                 	None
307:                  
308:                   Parameters:           
309:                 	sys_clock - system clock frequency in Hz
310:                     flags -
311:                 		*    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
312:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
313:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
314:                         *    SYS_CFG_ALL          - configure all based on system clock
315:                  
316:                   Returns:          
317:                 	the PB clock frequency in Hz
318:                  
319:                   Side Effects:    
320:                 	Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
321:                     wait state to 0.
322:                   
323:                  
324:                   Remarks:
325:                 	The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
326:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
327:                  
328:                   Example:
329:                 	<code>
330:                 	SYSTEMConfig(72000000, SYS_CFG_ALL);
331:                 	</code>
332:                  ********************************************************************/
333:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
334:                 {
335:                     unsigned int pb_clk;
336:                     unsigned int int_status;
337:                 #ifdef _PCACHE
338:                     unsigned int cache_status;
339:                 #endif
340:                 
341:                     int_status=INTDisableInterrupts();
342:                 
343:                     mBMXDisableDRMWaitState();
344:                 
345:                     if(flags & SYS_CFG_WAIT_STATES)
346:                     {
347:                         SYSTEMConfigWaitStates(sys_clock);
348:                     }
349:                 
350:                     if(flags & SYS_CFG_PB_BUS)
351:                     {
352:                         SYSTEMConfigPB(sys_clock);
353:                     }
354:                 
355:                 
356:                 #ifdef _PCACHE
357:                     if(flags & SYS_CFG_PCACHE)
358:                     {
359:                         cache_status = mCheGetCon();
360:                         cache_status |= CHE_CONF_PF_ALL;
361:                         mCheConfigure(cache_status);
362:                         CheKseg0CacheOn();
363:                     }
364:                 #endif
365:                 
366:                     pb_clk = sys_clock;
367:                     pb_clk >>= OSCCONbits.PBDIV;
368:                 
369:                     INTRestoreInterrupts(int_status);
370:                 
371:                     return pb_clk;
372:                 
373:                 }
374:                 #ifdef __cplusplus
375:                   }
376:                 #endif
377:                 #endif
378:                 
---  /Applications/microchip/xc32/v1.21/pic32mx/include/peripheral/osc.h  -------------------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  OSC API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        OSC.h
7:                    * Dependencies:
8:                    * Processor:       PIC32
9:                    *
10:                   *
11:                   * Compiler:        MPLAB XC32
12:                   *                  MPLAB IDE
13:                   * Company:         Microchip Technology Inc.
14:                   *
15:                   * Software License Agreement
16:                   *
17:                   * The software supplied herewith by Microchip Technology Incorporated
18:                   * (the Company) for its PIC Microcontroller is intended
19:                   * and supplied to you, the Companys customer, for use solely and
20:                   * exclusively on Microchip PIC Microcontroller products.
21:                   * The software is owned by the Company and/or its supplier, and is
22:                   * protected under applicable copyright laws. All rights are reserved.
23:                   * Any use in violation of the foregoing restrictions may subject the
24:                   * user to criminal sanctions under applicable laws, as well as to
25:                   * civil liability for the breach of the terms and conditions of this
26:                   * license.
27:                   *
28:                   * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
29:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                   *
35:                   *
36:                   * $Id: OSC.h,v 1.6 2006/10/13 21:24:31 C12532 Exp $
37:                   * $Name:  $
38:                   ********************************************************************/
39:                  
40:                  #ifndef OSC_H_
41:                  #define OSC_H_
42:                  
43:                  #include <xc.h>
44:                  #include <peripheral/lock.h>
45:                  
46:                  #define _OSC_
47:                  
48:                  /*********************************************************************
49:                   * Function:        OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div)
50:                   *
51:                   * Description:	    Sets Osc options and clock source
52:                   *
53:                   * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
54:                   *
55:                   * Inputs:	    	Clock source, PLL multiplier, PLL postscaler, FRC divisor - see below
56:                   *
57:                   * Output:          None
58:                   *
59:                   * Example:	    	OSCConfig( OSC_POSC, OSC_PLL_MULT_24, OSC_PLL_POST_256, OSC_FRC_POST_64 )
60:                   *
61:                   * Note:	    	Forces cpu clock source to FRC(no divisor, no PLL), configures new clock
62:                   * 		     		source and then switches to the new clock source
63:                   *
64:                   *		    		Unused parameters are set to zero/default values.
65:                   ********************************************************************/
66:                  void OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div);
67:                  
68:                  	/******************************************************************************
69:                  	 * Available options for source parameter
70:                  	 *****************************************************************************/
71:                  		// CPU Oscillator modes - values are mutually exclusive
72:                  		#define OSC_FRC_DIV 	(7 << _OSCCON_NOSC_POSITION)
73:                  		#define OSC_FRC_DIV16 	(6 << _OSCCON_NOSC_POSITION)
74:                  		#define OSC_LPRC        (5 << _OSCCON_NOSC_POSITION)
75:                  		#define OSC_SOSC        (4 << _OSCCON_NOSC_POSITION)
76:                  		#define OSC_POSC_PLL 	(3 << _OSCCON_NOSC_POSITION)
77:                  		#define OSC_POSC        (2 << _OSCCON_NOSC_POSITION)
78:                  		#define OSC_FRC_PLL 	(1 << _OSCCON_NOSC_POSITION)
79:                  		#define OSC_FRC         (0 << _OSCCON_NOSC_POSITION)
80:                  
81:                  	/******************************************************************************
82:                  	 * Available options for mult parameter
83:                  	 *****************************************************************************/
84:                  		// CPU PLL multiplier values - values are mutually exclusive
85:                  		#define OSC_PLL_MULT_24 (7 << _OSCCON_PLLMULT_POSITION)
86:                  		#define OSC_PLL_MULT_21 (6 << _OSCCON_PLLMULT_POSITION)
87:                  		#define OSC_PLL_MULT_20 (5 << _OSCCON_PLLMULT_POSITION)
88:                  		#define OSC_PLL_MULT_19 (4 << _OSCCON_PLLMULT_POSITION)
89:                  		#define OSC_PLL_MULT_18 (3 << _OSCCON_PLLMULT_POSITION)
90:                  		#define OSC_PLL_MULT_17 (2 << _OSCCON_PLLMULT_POSITION)
91:                  		#define OSC_PLL_MULT_16 (1 << _OSCCON_PLLMULT_POSITION)
92:                  		#define OSC_PLL_MULT_15 (0 << _OSCCON_PLLMULT_POSITION)
93:                  
94:                  	/******************************************************************************
95:                  	 * Available options for post parameter
96:                  	 *****************************************************************************/
97:                  		// CPU PLL output divisor values - values are mutuallye exclusive
98:                  		#define OSC_PLL_POST_256 (7 << _OSCCON_PLLODIV_POSITION)
99:                  		#define OSC_PLL_POST_64  (6 << _OSCCON_PLLODIV_POSITION)
100:                 		#define OSC_PLL_POST_32  (5 << _OSCCON_PLLODIV_POSITION)
101:                 		#define OSC_PLL_POST_16  (4 << _OSCCON_PLLODIV_POSITION)
102:                 		#define OSC_PLL_POST_8   (3 << _OSCCON_PLLODIV_POSITION)
103:                 		#define OSC_PLL_POST_4   (2 << _OSCCON_PLLODIV_POSITION)
104:                 		#define OSC_PLL_POST_2   (1 << _OSCCON_PLLODIV_POSITION)
105:                 		#define OSC_PLL_POST_1   (0 << _OSCCON_PLLODIV_POSITION)
106:                 
107:                 	/******************************************************************************
108:                 	 * Available options for div parameter
109:                 	 *****************************************************************************/
110:                 		// CPU FRC output divisor values - values are mutually exclusive
111:                 		#define OSC_FRC_POST_256 (7 << _OSCCON_FRCDIV_POSITION)
112:                 		#define OSC_FRC_POST_64  (6 << _OSCCON_FRCDIV_POSITION)
113:                 		#define OSC_FRC_POST_32  (5 << _OSCCON_FRCDIV_POSITION)
114:                 		#define OSC_FRC_POST_16  (4 << _OSCCON_FRCDIV_POSITION)
115:                 		#define OSC_FRC_POST_8   (3 << _OSCCON_FRCDIV_POSITION)
116:                 		#define OSC_FRC_POST_4   (2 << _OSCCON_FRCDIV_POSITION)
117:                 		#define OSC_FRC_POST_2   (1 << _OSCCON_FRCDIV_POSITION)
118:                 		#define OSC_FRC_POST_1   (0 << _OSCCON_FRCDIV_POSITION)
119:                 	/***********************************
120:                 	 * End parameter values
121:                 	 ************************************/
122:                 
123:                 #if (((__PIC32_FEATURE_SET__ >= 100) && (__PIC32_FEATURE_SET__ <= 299)) || \
124:                     (__PIC32_FEATURE_SET__ == 330) || (__PIC32_FEATURE_SET__ == 350) || (__PIC32_FEATURE_SET__ == 370) || (__PIC32_FEATURE_SET__ == 430) || (__PIC32_FEATURE_SET__ == 450) || (__PIC32_FEATURE_SET__ == 470))
125:                 	
126:                 		// Reference Oscillator Source Select bits - values are mutually exclusive
127:                 	#define OSC_REFOCON_REFCLKI	 	(7 << _REFOCON_ROSEL_POSITION )
128:                 	#define OSC_REFOCON_SYSPLL 		(7 << _REFOCON_ROSEL_POSITION )
129:                 	#define OSC_REFOCON_USBPLL 		(6 << _REFOCON_ROSEL_POSITION )
130:                 	#define OSC_REFOCON_SOSC        (5 << _REFOCON_ROSEL_POSITION )
131:                 	#define OSC_REFOCON_LPRC        (4 << _REFOCON_ROSEL_POSITION )
132:                 	#define OSC_REFOCON_FRC 		(3 << _REFOCON_ROSEL_POSITION )
133:                 	#define OSC_REFOCON_POSC        (2 << _REFOCON_ROSEL_POSITION )
134:                 	#define OSC_REFOCON_PBCLK 		(1 << _REFOCON_ROSEL_POSITION )
135:                 	#define OSC_REFOCON_SYSCLK      (0 << _REFOCON_ROSEL_POSITION )
136:                 		
137:                 	typedef enum
138:                 	{		
139:                 		OSC_REFOCON_RLSPEN		=(1 << _REFOCON_RSLP_POSITION )	,
140:                 		OSC_REFOCON_OE			=(1 << _REFOCON_OE_POSITION ),
141:                 		OSC_REFOCON_SIDLEN		=(1 << _REFOCON_SIDL_POSITION ),
142:                 		OSC_REFOCON_ON			=(1 << _REFOCON_ON_POSITION )
143:                 	} OSCREFConfigFlags;
144:                 	
145:                 	void OSCREFConfig(unsigned long int source, OSCREFConfigFlags config, unsigned long int div);
146:                 	 
147:                 
148:                 	#define mOSCREFOTRIMSet(trim) 		(REFOTRIM = (trim << _REFOTRIM_ROTRIM_POSITION))
149:                 
150:                 #endif
151:                 
152:                 	 
153:                 	 
154:                 	 
155:                 /*********************************************************************
156:                  * Function:    OSCSetPBDIV(unsigned int oscPbDiv)
157:                  *
158:                  * Description:	Configures peripheral bus divisor
159:                  *
160:                  * PreCondition: oscPbDiv one of the OSC_PB_DIV_X valid values
161:                  *
162:                  * Inputs:    oscPbDiv - desired PB divider
163:                  *
164:                  * Output:      None
165:                  *
166:                  * Example:   OSCSetPBDIV(  OSC_PB_DIV_8 )
167:                  *
168:                  ********************************************************************/
169:                 extern inline void __attribute__((always_inline)) OSCSetPBDIV(unsigned int oscPbDiv)
170:                 {
171:                 	unsigned int dma_status;
172:                 	unsigned int int_status;
173:                 	__OSCCONbits_t oscBits;
174:                 
175:                 	mSYSTEMUnlock(int_status, dma_status);
9D00AA78  0F403623   JAL INTDisableInterrupts
9D00AA7C  00000000   NOP
9D00AA80  AFC20030   SW V0, 48(S8)
9D00AAC8  AFC20038   SW V0, 56(S8)
9D00AACC  3C02BF81   LUI V0, -16511
9D00AAD0  AC40F230   SW ZERO, -3536(V0)
9D00AAD4  3C02BF81   LUI V0, -16511
9D00AAD8  3C03AA99   LUI V1, -21863
9D00AADC  34636655   ORI V1, V1, 26197
9D00AAE0  AC43F230   SW V1, -3536(V0)
9D00AAE4  3C02BF81   LUI V0, -16511
9D00AAE8  3C035566   LUI V1, 21862
9D00AAEC  346399AA   ORI V1, V1, -26198
9D00AAF0  AC43F230   SW V1, -3536(V0)
176:                 	
177:                 	oscBits.w=OSCCON;		// read to be in sync. flush any pending write
9D00AAF4  3C02BF81   LUI V0, -16511
9D00AAF8  8C42F000   LW V0, -4096(V0)
9D00AAFC  AFC2005C   SW V0, 92(S8)
178:                 	oscBits.PBDIV=0;
9D00AB00  8FC2005C   LW V0, 92(S8)
9D00AB04  7C02A4C4   INS V0, ZERO, 19, 2
9D00AB08  AFC2005C   SW V0, 92(S8)
179:                 	oscBits.w|=oscPbDiv;	
9D00AB0C  8FC3005C   LW V1, 92(S8)
9D00AB10  8FC2002C   LW V0, 44(S8)
9D00AB14  00621025   OR V0, V1, V0
9D00AB18  AFC2005C   SW V0, 92(S8)
180:                 	OSCCON=oscBits.w;		// write back
9D00AB1C  8FC3005C   LW V1, 92(S8)
9D00AB20  3C02BF81   LUI V0, -16511
9D00AB24  AC43F000   SW V1, -4096(V0)
181:                 	oscBits.w=OSCCON;		// make sure the write occurred before returning from this function
9D00AB28  3C02BF81   LUI V0, -16511
9D00AB2C  8C42F000   LW V0, -4096(V0)
9D00AB30  AFC2005C   SW V0, 92(S8)
182:                 	
183:                 	mSYSTEMLock(int_status, dma_status);
9D00AB34  3C02BF81   LUI V0, -16511
9D00AB38  3C033333   LUI V1, 13107
9D00AB3C  34633333   ORI V1, V1, 13107
9D00AB40  AC43F230   SW V1, -3536(V0)
9D00AB44  8FC20038   LW V0, 56(S8)
9D00AB48  AFC2003C   SW V0, 60(S8)
9D00ABB8  8FC40030   LW A0, 48(S8)
9D00ABBC  0F4035ED   JAL INTRestoreInterrupts
9D00ABC0  00000000   NOP
184:                 }
185:                 
186:                 #define		mOSCSetPBDIV		OSCSetPBDIV		// backward compatibility
187:                 
188:                 
189:                 
190:                 	/******************************************************************************
191:                 	 * Available options for config parameter
192:                 	 *****************************************************************************/
193:                 		// CPU Peripheral Bus divisor values - values are mutually exclusive
194:                 		#define OSC_PB_DIV_8    (3 << _OSCCON_PBDIV_POSITION)
195:                 		#define OSC_PB_DIV_4    (2 << _OSCCON_PBDIV_POSITION)
196:                 		#define OSC_PB_DIV_2    (1 << _OSCCON_PBDIV_POSITION)
197:                 		#define OSC_PB_DIV_1    (0 << _OSCCON_PBDIV_POSITION)
198:                 	/***********************************
199:                 	 * End config parameter values
200:                 	 ************************************/
201:                 
202:                 
203:                 /*********************************************************************
204:                  * Function:    mOSCGetPBDIV()
205:                  *
206:                  * Description:	Reads peripheral bus divisor
207:                  *
208:                  * PreCondition:None
209:                  *
210:                  * Inputs:	  	None
211:                  *
212:                  * Output:      None
213:                  *
214:                  * Example:	  	mOSCGetPBDIV()
215:                  *
216:                  ********************************************************************/
217:                 #define mOSCGetPBDIV() (OSCCONbits.PBDIV)
218:                 
219:                 
220:                 /*********************************************************************
221:                  * Function:    mOSCClockFailStatus()
222:                  *
223:                  * Description:	Returns Clock Fail status. 1 = clock fail, 0 = no clock fail
224:                  *
225:                  * PreCondition: None
226:                  *
227:                  * Inputs:	  	None
228:                  *
229:                  * Output:      None
230:                  *
231:                  * Example:	  	mOSCClockFailStatus()
232:                  *
233:                  ********************************************************************/
234:                 #define mOSCClockFailStatus (OSCCONbits.CF)
235:                 
236:                 
237:                 /*********************************************************************
238:                  * Function:      	mOSCEnableSOSC()
239:                  *
240:                  * Description:	  	Enables the LPRC
241:                  *
242:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
243:                  *
244:                  * Inputs:	  		None
245:                  *
246:                  * Output:        	None
247:                  *
248:                  * Example:	  		mOSCEnableSOSC()
249:                  *
250:                  ********************************************************************/
251:                 #define mOSCEnableSOSC() mSysUnlockOpLock(OSCCONSET = _OSCCON_SOSCEN_MASK)
252:                 
253:                 
254:                 /*********************************************************************
255:                  * Function:      	mOSCDisableSOSC(config)
256:                  *
257:                  * Description:	  	Disables SOSC
258:                  *
259:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
260:                  *
261:                  * Inputs:	  		None
262:                  *
263:                  * Output:        	None
264:                  *
265:                  * Example:	  		mOSCDisableSOSC()
266:                  *
267:                  ********************************************************************/
268:                 #define mOSCDisableSOSC() mSysUnlockOpLock(OSCCONCLR = _OSCCON_SOSCEN_MASK)
269:                 
270:                 
271:                 
272:                 #endif
---  /Applications/microchip/xc32/v1.21/pic32mx/include/peripheral/dma_5xx_6xx_7xx.h  -------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  DMA API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Dma.h
7:                    * Dependencies:	xc.h
8:                    * 					int.h
9:                    *
10:                   * Processor:       PIC32
11:                   *
12:                   * Complier:        MPLAB C32
13:                   *                  MPLAB IDE
14:                   * Company:         Microchip Technology Inc.
15:                   *
16:                   * Software License Agreement
17:                   *
18:                   * The software supplied herewith by Microchip Technology Incorporated
19:                   * (the Company) for its PIC32/PIC24F Microcontroller is intended
20:                   * and supplied to you, the Companys customer, for use solely and
21:                   * exclusively on Microchip PIC32/PIC24F Microcontroller products.
22:                   * The software is owned by the Company and/or its supplier, and is
23:                   * protected under applicable copyright laws. All rights are reserved.
24:                   * Any use in violation of the foregoing restrictions may subject the
25:                   * user to criminal sanctions under applicable laws, as well as to
26:                   * civil liability for the breach of the terms and conditions of this
27:                   * license.
28:                   *
29:                   * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
30:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
31:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
32:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
33:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
34:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
35:                   *
36:                   *
37:                   * $Id: Dma.h,v 1.9 2007/01/17 21:35:46 C12878 Exp $
38:                   * $Name:  $
39:                   *
40:                   ********************************************************************/
41:                  
42:                  #ifndef _DMA_H_
43:                  #define _DMA_H_
44:                  
45:                  #include <xc.h>
46:                  
47:                  
48:                  // DMA definitions
49:                  
50:                  #ifdef _DMAC0
51:                  	#define _DMA_CHANNELS		// DMA channels exist
52:                  
53:                  
54:                  // existent DMA channels
55:                  	typedef enum
56:                  	{
57:                  		DMA_CHANNEL0,
58:                  	#ifdef _DMAC1
59:                  		DMA_CHANNEL1,
60:                  	#ifdef _DMAC2
61:                  		DMA_CHANNEL2,
62:                  	#ifdef _DMAC3
63:                  		DMA_CHANNEL3,
64:                  	#ifdef _DMAC4
65:                  		DMA_CHANNEL4,
66:                  	#ifdef _DMAC5
67:                  		DMA_CHANNEL5,
68:                  	#ifdef _DMAC6
69:                  		DMA_CHANNEL6,
70:                  	#ifdef _DMAC7
71:                  		DMA_CHANNEL7,
72:                  	#endif	// _DMAC7
73:                  	#endif	// _DMAC6
74:                  	#endif	// _DMAC5
75:                  	#endif	// _DMAC4
76:                  	#endif	// _DMAC3
77:                  	#endif	// _DMAC2
78:                  	#endif	// _DMAC1
79:                  		//	add/remove DMA channel as needed here
80:                  
81:                  		DMA_CHANNELS	// number of current available channels
82:                  	}DmaChannel;
83:                  
84:                  
85:                  	// Relative Dma channels priority, between each other
86:                  	typedef enum
87:                  	{
88:                  		DMA_CHN_PRI0,
89:                  		DMA_CHN_PRI1,
90:                  		DMA_CHN_PRI2,
91:                  		DMA_CHN_PRI3
92:                  	}DmaChannelPri;
93:                  
94:                  
95:                  
96:                  	// high level definitions for the API functions
97:                  
98:                  	typedef enum
99:                  	{
100:                 		DMA_OPEN_DEFAULT = 0,							        // DMA default operation
101:                 		DMA_OPEN_AUTO	= _DCH0CON_CHAEN_MASK,					// DMA channel is auto enabled
102:                 		DMA_OPEN_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),	// DMA channel is chained to lower channel
103:                 		DMA_OPEN_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),				// DMA channel is chained to higher channel
104:                 		DMA_OPEN_DET_EN = _DCH0CON_CHAED_MASK,					// events detection enabled while channel off
105:                 		DMA_OPEN_ENABLE = _DCH0CON_CHEN_MASK,					// DMA channel is enabled after open
106:                 		DMA_OPEN_MATCH	= 0x80000000,						    // DMA channel stops on match
107:                 	}DmaOpenFlags;	// flags for the channel open
108:                 
109:                 
110:                 	typedef enum
111:                 	{
112:                 		DMA_EV_ERR =			0x1,		// address error event
113:                 		DMA_EV_ABORT = 			0x2,		// transfer abort event
114:                 		DMA_EV_CELL_DONE =		0x4,		// cell transfer complete event
115:                 		DMA_EV_BLOCK_DONE =		0x8,		// block transfer complete event
116:                 		DMA_EV_DST_HALF =		0x10,		// destination half event
117:                 		DMA_EV_DST_FULL =		0x20,		// destination full event
118:                 		DMA_EV_SRC_HALF =		0x40,		// source half event
119:                 		DMA_EV_SRC_FULL =		0x80,		// source full event
120:                 
121:                 		DMA_EV_ALL_EVNTS=		(DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_CELL_DONE|DMA_EV_BLOCK_DONE|DMA_EV_DST_HALF|
122:                 									DMA_EV_DST_FULL|DMA_EV_SRC_HALF|DMA_EV_SRC_FULL)				// all available events
123:                 	}DmaEvFlags;	// flags for controlling the DMA channel events; Bit fields from the processor header file.
124:                 
125:                 
126:                 	typedef enum
127:                 	{
128:                 		DMA_TXFER_OK,			// the transfer was performed successfully
129:                 		DMA_TXFER_ADD_ERR,		// address error while performing the transfer
130:                 		DMA_TXFER_ABORT,		// the DMA transfer was aborted
131:                 		DMA_TXFER_BC_ERR,		// block complete not set after the DMA transfer performed
132:                 		DMA_TXFER_CC_ERR,		// cell complete not set after the DMA transfer performed
133:                 		DMA_TXFER_TMO			// DMA transfer timeout
134:                 	}DmaTxferRes;		// DMA transfer result
135:                 
136:                 	typedef enum
137:                 	{
138:                 		DMA_WAIT_NOT,		// don't wait for the transfer to complete, return immediately
139:                 		DMA_WAIT_CELL,		// wait for the cell transfer to complete, than return
140:                 		DMA_WAIT_BLOCK		// wait for the block transfer to complete, than return
141:                 	}DmaWaitMode;		// DMA transfer wait mode
142:                 
143:                 	typedef enum
144:                 	{
145:                 		DMA_CHKSUM_CRC,		// LFSR CRC
146:                 		DMA_CHKSUM_IP,		// IP Checksum
147:                 	}DmaChksumType;		// DMA SFM supported checksum types
148:                 
149:                 	typedef enum
150:                 	{
151:                 		DMA_BITO_MSb,		// MSb first (not reflected)
152:                 		DMA_BITO_LSb,		// LSb first (reflected)
153:                 	}DmaBitOrder;		// DMA SFM supported bit ordering
154:                 
155:                 	typedef enum
156:                 	{
157:                 		DMA_REORDER_NOT,	// no reordering, destination matches the source
158:                 		DMA_REORDER_ENDIAN,	// change endianess on word (32 bit) boundaries: LE<->BE
159:                 		DMA_REORDER_SWAP_HALF,	// swap half words (16 bit) within word (32 bit)		
160:                 		DMA_REORDER_SWAP_BYTE,	// swap bytes within half word (16 bit)				
161:                 	}DmaReorderMode;	// DMA SFM supported re-ordering modes
162:                 
163:                 
164:                 	/*********************************************************************
165:                 	 * Function:        void DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags)
166:                 	 *
167:                 	 * PreCondition:    chPri  - valid channel priority, 0-3
168:                 	 *
169:                 	 * Input:           chn    - channel to be configured in the DMA controller
170:                 	 *                  chPri  - the priority given to the channel, 0-3
171:                 	 *                  oFlags - orred flags specifying the open mode:
172:                 	 *                           DMA_OPEN_DEFAULT: DMA default operation mode
173:                 	 *                           DMA_OPEN_AUTO:	DMA channel is auto enabled
174:                 	 *                           DMA_OPEN_CHAIN_LOW: DMA channel is chained to lower channel
175:                 	 *                           DMA_OPEN_CHAIN_HI: DMA channel is chained to higher channel
176:                 	 *                           DMA_OPEN_DET_EN: events detection enabled while channel off
177:                 	 *                           DMA_OPEN_ENABLE: DMA channel is enabled when opened
178:                 	 *                           DMA_OPEN_MATCH:	DMA channel stops on match
179:                 	 *
180:                 	 *
181:                 	 *
182:                 	 * Output:          None
183:                 	 *
184:                 	 * Side Effects:    None
185:                 	 *
186:                 	 * Overview:        The function opens and configures the selected DMA channel using the supplied user flags and priority.
187:                 	 *
188:                 	 * Note:            - This is a high level access function that doesn't give access to all the settings possible for a DMA channel.
189:                 	 *                  Use the low level functions to address special settings.
190:                 	 *                  - The channel is turned off, the pending interrupts are cleared, interrupts are disabled.
191:                 	 *                  After that the channel is configured.
192:                 	 *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
193:                 	 *                  if DMA_OPEN_ENABLE flag was not specified.
194:                 	 *                  - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
195:                 	 *                  This way, the transfer will occur correctly together with CRC calculation.
196:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
197:                 	 *                  User has to call event channel functions to enable the event flags if needed.
198:                 	 *
199:                 	 * Example:         DmaChnOpen(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_OPEN_AUTO|DMA_OPEN_MATCH|DMA_OPEN_ENABLE);
200:                 	 ********************************************************************/
201:                 	 void			DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags);
202:                 
203:                 	/*********************************************************************
204:                 	 * Function:        void DmaChnEnable(DmaChannel chn)
205:                 	 *
206:                 	 * PreCondition:    None
207:                 	 *
208:                 	 * Input:			chn		- channel to be enabled
209:                 	 *
210:                 	 * Output:          None
211:                 	 *
212:                 	 * Side Effects:    None
213:                 	 *
214:                 	 * Overview:		The function enables a previously configured DMA channel.
215:                 	 *
216:                 	 * Note:            DmaChnOpen()/DmaChnConfigure() should have been called before.
217:                 	 *
218:                 	 * Example:			DmaChnEnable(DMA_CHANNEL3);
219:                 	 ********************************************************************/
220:                 	 void			DmaChnEnable(DmaChannel chn);
221:                 
222:                 	/*********************************************************************
223:                 	 * Function:        void DmaChnDisable(DmaChannel chn)
224:                 	 *
225:                 	 * PreCondition:    None
226:                 	 *
227:                 	 * Input:			chn		- selected channel in the DMA controller
228:                 	 *
229:                 	 * Output:          None
230:                 	 *
231:                 	 * Side Effects:    None
232:                 	 *
233:                 	 * Overview:		The function disables a DMA channel. The channel operation stops.
234:                 	 *
235:                 	 * Note:            None.
236:                 	 *
237:                 	 * Example:			DmaChnDisable(DMA_CHANNEL3);
238:                 	 ********************************************************************/
239:                 	 void			DmaChnDisable(DmaChannel chn);
240:                 
241:                 	/*********************************************************************
242:                 	 * Function:        void DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize)
243:                 	 *
244:                 	 * PreCondition:    chn		- valid DMA channel
245:                 	 * 				- vSrcAdd, vDstAdd	- valid pointers
246:                 	 *                              - 0 < srcSize <= DmaGetMaxTxferSize()
247:                 	 *                              - 0 < dstSize <= DmaGetMaxTxferSize()
248:                 	 *                              - 0 < cellSize <= DmaGetMaxTxferSize()
249:                 	 *
250:                 	 * Input:			chn			- DMA channel number
251:                 	 * 								- vSrcAdd: source of the DMA transfer
252:                 	 * 								- vDstAdd: destination of the DMA transfer
253:                 	 * 								- srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
254:                 	 * 								- dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
255:                 	 * 								- cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
256:                 	 *
257:                 	 * Output:          None
258:                 	 *
259:                 	 * Side Effects:    None
260:                 	 *
261:                 	 * Overview:		The function sets the transfer characteristics for a DMA channel transfer:
262:                 	 * 					the source and the destination addresses.
263:                 	 * 					the source and destination lengths
264:                 	 * 					and the number of bytes	transferred per event.
265:                 	 *
266:                 	 * Note:            The function clears the existing DMA channel event flags.
267:                 	 *                  The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
268:                 	 *
269:                 	 * Example:			DmaChnSetTxfer(DMA_CHANNEL3, &U2RXREG, dstBuff, 1, 200, 1);
270:                 	 ********************************************************************/
271:                 	 void			DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize);
272:                 
273:                 
274:                 	/*********************************************************************
275:                 	 * Function:        void DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd)
276:                 	 *
277:                 	 * PreCondition:    chn		- valid DMA channel
278:                 	 *
279:                 	 * Input:           chn		- DMA channel number
280:                 	 * 				- vSrcAdd: source (virtual) of the DMA transfer
281:                 	 * Output:          None
282:                 	 *
283:                 	 * Side Effects:    None
284:                 	 *
285:                 	 * Overview:        The function is a helper to set directly the transfer source address.
286:                 	 *
287:                 	 * Note:            None.
288:                 	 *
289:                 	 * Example:         DmaChnSetSrcAdd(DMA_CHANNEL2, srcBuff+sizeof(srcBuff));
290:                 	 ********************************************************************/
291:                 	 void			DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd);
292:                 
293:                 	/*********************************************************************
294:                 	 * Function:        void DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd)
295:                 	 *
296:                 	 * PreCondition:    chn		- valid DMA channel
297:                 	 *
298:                 	 * Input:			chn			- DMA channel number
299:                 	 * 								- vDstAdd: destination (virtual) of the DMA transfer
300:                 	 * Output:          None
301:                 	 *
302:                 	 * Side Effects:    None
303:                 	 *
304:                 	 * Overview:		The function is a helper to set directly the transfer destination address.
305:                 	 *
306:                 	 * Note:            None
307:                 	 *
308:                 	 * Example:         DmaChnSetDstAdd(DMA_CHANNEL2, dstBuff+sizeof(dstBuff));
309:                 	 ********************************************************************/
310:                 	 void			DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd);
311:                 
312:                 	/*********************************************************************
313:                 	 * Function:        void DmaChnSetMatchPattern(DmaChannel chn, int pattern)
314:                 	 *
315:                 	 * PreCondition:    chn	- valid DMA channel
316:                 	 *
317:                 	 * Input:			chn		- DMA channel number
318:                 	 * 					pattern	-  the match pattern
319:                 	 *
320:                 	 * Output:          None
321:                 	 *
322:                 	 * Side Effects:    None
323:                 	 *
324:                 	 * Overview:		The function sets the curent match pattern for the selected DMA channel.
325:                 	 *
326:                 	 * Note:            None.
327:                 	 *
328:                 	 * Example:			DmaChnSetMatchPattern(DMA_CHANNEL3, '\r');
329:                 	 ********************************************************************/
330:                 	 void			DmaChnSetMatchPattern(DmaChannel chn, int pattern);
331:                 
332:                 	/*********************************************************************
333:                 	 * Function:        int DmaChnGetMatchPattern(DmaChannel chn)
334:                 	 *
335:                 	 * PreCondition:    chn	- valid DMA channel
336:                 	 *
337:                 	 * Input:			chn		- DMA channel number
338:                 	 *
339:                 	 * Output:          The channel match pattern.
340:                 	 *
341:                 	 * Side Effects:    None
342:                 	 *
343:                 	 * Overview:		The function retrieves the curent match pattern for the selected DMA channel.
344:                 	 *
345:                 	 * Note:            None.
346:                 	 *
347:                 	 * Example:			int pattern=DmaChnGetMatchPattern(DMA_CHANNEL3);
348:                 	 ********************************************************************/
349:                 	 int			DmaChnGetMatchPattern(DmaChannel chn);
350:                 
351:                 	/*********************************************************************
352:                 	 * Function:        DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries)
353:                 	 *
354:                 	 * PreCondition:    chn	- valid DMA channel
355:                 	 *
356:                 	 * Input:			chn		- DMA channel number
357:                 	 * 					wMode	- if DMA_WAIT_NOT, return immediately
358:                 	 * 							- if DMA_WAIT_CELL, return after the cell transfer complete
359:                 	 * 							- if DMA_WAIT_BLOCK, return after the whole transfer is done
360:                 	 * 					retries	- retry counter: if transfer not complete after so many retries, return with tmo.
361:                 	 * 								If 0, wait forever.
362:                 	 *
363:                 	 * Output:          DMA_TXFER_OK if not waiting for the transfer completion or if the transfer ended normally,
364:                 	 * 					an DmaTxferRes error code  otherwise
365:                 	 *
366:                 	 * Side Effects:    None
367:                 	 *
368:                 	 * Overview:		The function initiates (forces) a DMA transfer for the selected DMA channel.
369:                 	 * 					The DMA channel is enabled.
370:                 	 * 					If waiting for the transfer completion needed (user doesn't use an ISR to catch
371:                 	 * 					this event) the function will periodically query the DMA controller for the
372:                 	 * 					transfer completion status.
373:                      * 					If DMA_WAIT_BLOCK is specified and multiple cell transfers are needed to complete
374:                      * 					the block transfer than the function will re-force the transfer for each cell.
375:                 	 *
376:                 	 * Note:            This function can not ne used when the DMA channel is triggerred
377:                      *                  by hardware interrupt requests.
378:                      *                  This is because the transfers are software forced, theere is no
379:                      *                  wait for the occurrence of the hardware trigger. 
380:                 	 *
381:                 	 * Example:         DmaChnStartTxfer(DMA_CHANNEL2, DMA_WAIT_BLOCK, 0);
382:                 	 ********************************************************************/
383:                 	 DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries);
384:                 
385:                 	/*********************************************************************
386:                 	 * Function:        void DmaChnForceTxfer(DmaChannel chn)
387:                 	 *
388:                 	 * PreCondition:    chn	- valid DMA channel
389:                 	 *
390:                 	 * Input:			chn		- DMA channel number
391:                 	 *
392:                 	 * Output:          None
393:                 	 *
394:                 	 * Side Effects:    None
395:                 	 *
396:                 	 * Overview:		The function forces a DMA transfer to occur for the selected DMA channel.
397:                 	 *
398:                 	 * Note:            None.
399:                 	 *
400:                 	 * Example:			DmaChnForceTxfer(DMA_CHANNEL3);
401:                 	 ********************************************************************/
402:                 	 void			DmaChnForceTxfer(DmaChannel chn);
403:                 
404:                 	/*********************************************************************
405:                 	 * Function:        void DmaChnAbortTxfer(DmaChannel chn)
406:                 	 *
407:                 	 * PreCondition:    chn	- valid DMA channel
408:                 	 *
409:                 	 * Input:			chn		- DMA channel number
410:                 	 *
411:                 	 * Output:          None
412:                 	 *
413:                 	 * Side Effects:    None
414:                 	 *
415:                 	 * Overview:		The function aborts a current undergoing DMA transfer for the selected DMA channel.
416:                 	 *
417:                 	 * Note:            None.
418:                 	 *
419:                 	 * Example:			DmaChnAbortTxfer(DMA_CHANNEL3);
420:                 	 ********************************************************************/
421:                 	 void			DmaChnAbortTxfer(DmaChannel chn);
422:                 
423:                 	// High level channel event and interrupt control functions
424:                 
425:                 	/*********************************************************************
426:                 	 * Function:        void DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
427:                 	 *
428:                 	 * PreCondition:    chn	- valid DMA channel
429:                 	 *
430:                 	 * Input:			chn		- DMA channel number
431:                 	 * 					eFlags	- event flags with the following significance:
432:                 	 * 								- DMA_EV_ERR: address error event
433:                 	 * 								- DMA_EV_ABORT: transfer abort event
434:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
435:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
436:                 	 * 								- DMA_EV_DST_HALF: destination half event
437:                 	 * 								- DMA_EV_DST_FULL: destination full event
438:                 	 * 								- DMA_EV_SRC_HALF: source half event
439:                 	 * 								- DMA_EV_SRC_FULL: source full event
440:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
441:                 	 *
442:                 	 * Output:          None
443:                 	 *
444:                 	 * Side Effects:    None
445:                 	 *
446:                 	 * Overview:		The function sets the event enable flags for the selected DMA channel.
447:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
448:                 	 * 					enabled for the selected channel, the other channel event flags won't be touched.
449:                 	 *
450:                 	 * Note:            None.
451:                 	 *
452:                 	 * Example:			DmaChnSetEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
453:                 	 ********************************************************************/
454:                 	 void			DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
455:                 
456:                 	/*********************************************************************
457:                 	 * Function:        void DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
458:                 	 *
459:                 	 * PreCondition:    chn	- valid DMA channel
460:                 	 *
461:                 	 * Input:			chn		- DMA channel number
462:                 	 * 					eFlags	- event flags with the following significance:
463:                 	 * 								- DMA_EV_ERR: address error event
464:                 	 * 								- DMA_EV_ABORT: transfer abort event
465:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
466:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
467:                 	 * 								- DMA_EV_DST_HALF: destination half event
468:                 	 * 								- DMA_EV_DST_FULL: destination full event
469:                 	 * 								- DMA_EV_SRC_HALF: source half event
470:                 	 * 								- DMA_EV_SRC_FULL: source full event
471:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
472:                 	 *
473:                 	 * Output:          None
474:                 	 *
475:                 	 * Side Effects:    None
476:                 	 *
477:                 	 * Overview:		The function clears the event enable flags for the selected DMA channel.
478:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
479:                 	 * 					disabled for the selected channel, the other channel event flags won't be touched.
480:                 	 *
481:                 	 * Note:            None.
482:                 	 *
483:                 	 * Example:			DmaChnClrEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
484:                 	 ********************************************************************/
485:                 	 void			DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
486:                 
487:                 	/*********************************************************************
488:                 	 * Function:        void DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
489:                 	 *
490:                 	 * PreCondition:    chn	- valid DMA channel
491:                 	 *
492:                 	 * Input:			chn		- DMA channel number
493:                 	 * 					eFlags	- event flags with the following significance:
494:                 	 * 								- DMA_EV_ERR: address error event
495:                 	 * 								- DMA_EV_ABORT: transfer abort event
496:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
497:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
498:                 	 * 								- DMA_EV_DST_HALF: destination half event
499:                 	 * 								- DMA_EV_DST_FULL: destination full event
500:                 	 * 								- DMA_EV_SRC_HALF: source half event
501:                 	 * 								- DMA_EV_SRC_FULL: source full event
502:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
503:                 	 *
504:                 	 * Output:          None
505:                 	 *
506:                 	 * Side Effects:    None
507:                 	 *
508:                 	 * Overview:		The function sets the event enable flags for the selected DMA channel.
509:                 	 * 					The channel event flags are forced to the eFlags value.
510:                 	 *
511:                 	 * Note:            None.
512:                 	 *
513:                 	 * Example:			DmaChnWriteEvEnableFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
514:                 	 ********************************************************************/
515:                 	 void			DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
516:                 
517:                 	/*********************************************************************
518:                 	 * Function:        DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn)
519:                 	 *
520:                 	 * PreCondition:    chn	- valid DMA channel
521:                 	 *
522:                 	 * Input:			chn		- DMA channel number
523:                 	 *
524:                 	 * Output:          - event flags with the following significance:
525:                 	 * 						- DMA_EV_ERR: address error event
526:                 	 * 						- DMA_EV_ABORT: transfer abort event
527:                 	 * 						- DMA_EV_CELL_DONE: cell transfer complete event
528:                 	 * 						- DMA_EV_BLOCK_DONE: block transfer complete event
529:                 	 * 						- DMA_EV_DST_HALF: destination half event
530:                 	 * 						- DMA_EV_DST_FULL: destination full event
531:                 	 * 						- DMA_EV_SRC_HALF: source half event
532:                 	 * 						- DMA_EV_SRC_FULL: source full event
533:                 	 *						- DMA_EV_ALL_EVNTS: all of the above flags
534:                 	 *
535:                 	 * Side Effects:    None
536:                 	 *
537:                 	 * Overview:		The function returns the event enabled flags for the selected DMA channel.
538:                 	 *
539:                 	 * Note:            None.
540:                 	 *
541:                 	 * Example:			DmaEvFlags enabledFlags=DmaChnGetEvEnableFlags(DMA_CHANNEL3);
542:                 	 ********************************************************************/
543:                 	 DmaEvFlags	DmaChnGetEvEnableFlags(DmaChannel chn);
544:                 
545:                 	/*********************************************************************
546:                 	 * Function:        void DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags)
547:                 	 *
548:                 	 * PreCondition:    chn	- valid DMA channel
549:                 	 *
550:                 	 * Input:			chn		- DMA channel number
551:                 	 * 					eFlags	- event flags with the following significance:
552:                 	 * 								- DMA_EV_ERR: address error event
553:                 	 * 								- DMA_EV_ABORT: transfer abort event
554:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
555:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
556:                 	 * 								- DMA_EV_DST_HALF: destination half event
557:                 	 * 								- DMA_EV_DST_FULL: destination full event
558:                 	 * 								- DMA_EV_SRC_HALF: source half event
559:                 	 * 								- DMA_EV_SRC_FULL: source full event
560:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
561:                 	 *
562:                 	 * Output:          None
563:                 	 *
564:                 	 * Side Effects:    None
565:                 	 *
566:                 	 * Overview:		The function clears the event flags for the selected DMA channel.
567:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
568:                 	 * 					cleared for the selected channel, the other channel event flags won't be touched.
569:                 	 *
570:                 	 * Note:            None.
571:                 	 *
572:                 	 * Example:			DmaChnClrEvFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
573:                 	 ********************************************************************/
574:                 	 void			DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags);
575:                 
576:                 	/*********************************************************************
577:                 	 * Function:        DmaEvFlags DmaChnGetEvFlags(DmaChannel chn)
578:                 	 *
579:                 	 * PreCondition:    chn	- valid DMA channel
580:                 	 *
581:                 	 * Input:			chn		- DMA channel number
582:                 	 *
583:                 	 * Output:          event flags with the following significance:
584:                 	 * 						- DMA_EV_ERR: address error event
585:                 	 * 						- DMA_EV_ABORT: transfer abort event
586:                 	 * 						- DMA_EV_CELL_DONE: cell transfer complete event
587:                 	 * 						- DMA_EV_BLOCK_DONE: block transfer complete event
588:                 	 * 						- DMA_EV_DST_HALF: destination half event
589:                 	 * 						- DMA_EV_DST_FULL: destination full event
590:                 	 * 						- DMA_EV_SRC_HALF: source half event
591:                 	 * 						- DMA_EV_SRC_FULL: source full event
592:                 	 * 						- DMA_EV_ALL_EVNTS: all of the above flags
593:                 	 *
594:                 	 * Side Effects:    None
595:                 	 *
596:                 	 * Overview:		The function returns the event flags for the selected DMA channel.
597:                 	 *
598:                 	 * Note:            None.
599:                 	 *
600:                 	 * Example:			DmaEvFlags intSetFlags=DmaChnGetEvFlags(DMA_CHANNEL3);
601:                 	 ********************************************************************/
602:                 	 DmaEvFlags	DmaChnGetEvFlags(DmaChannel chn);
603:                 
604:                 
605:                 	// high level helpers for fast strcpy/memcpy transfers
606:                 
607:                 	/*********************************************************************
608:                 	 * Function:        DmaTxferRes DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri)
609:                 	 *
610:                 	 * PreCondition:    chn		- a valid DMA channel
611:                 	 * 					s1, s2	- valid memory pointers
612:                 	 * 					n>0, n<=DmaGetMaxTxferSize()
613:                 	 *
614:                 	 * Input:			s1		- destination pointer
615:                 	 * 					s2		- source pointer
616:                 	 * 					n		- number of bytes to transfer
617:                 	 * 					chn		- the DMA channel to perform the transfer
618:                 	 * 					chPri	- the desired channel priority
619:                 	 *
620:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
621:                 	 * 					an DmaTxferRes error code  otherwise
622:                 	 *
623:                 	 * Side Effects:    None
624:                 	 *
625:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
626:                 	 * 			Then it copies one block of memory from source to destination.
627:                 	 *
628:                 	 *
629:                 	 * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
630:                 	 *                    This way, the transfer will occur correctly together with checksum calculation.
631:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
632:                 	 *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
633:                 	 *                  - The function clears the suspend state and resumes the operation of the DMA controller.
634:                 	 *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
635:                 	 *
636:                  	 * Example:		res=DmaChnMemcpy(pDst, pSrc, buffSz, DMA_CHANNEL0, DMA_CHN_PRI3);
637:                  	 ********************************************************************/
638:                 	 DmaTxferRes	DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri);
639:                 
640:                 	/*********************************************************************
641:                 	 * Function:        DmaTxferRes DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri)
642:                 	 *
643:                 	 * PreCondition:    chn		- a valid DMA channel
644:                 	 * 					s1, s2	- valid memory pointers
645:                 	 *
646:                 	 * Input:			s1		- destination pointer
647:                 	 * 					s2		- source pointer
648:                 	 * 					chn		- the DMA channel to perform the transfer
649:                 	 * 					chPri	- the desired channel priority
650:                 	 *
651:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
652:                 	 * 					an DmaTxferRes error code  otherwise
653:                 	 *
654:                 	 * Side Effects:    None
655:                 	 *
656:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
657:                 	 * 			Then it copies one zero terminated string from source to destination.
658:                 	 *
659:                 	 *
660:                 	 * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
661:                 	 *                    This way, the transfer will occur correctly together with checksum calculation.
662:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
663:                 	 *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
664:                 	 *                  - The function clears the suspend state and resumes the operation of the DMA controller.
665:                 	 *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
666:                 	 *
667:                 	 *
668:                  	 * Example:		res=DmaChnStrcpy(str1, str2, DMA_CHANNEL1, DMA_CHN_PRI3);
669:                 	 *********************************************************************/
670:                 	 DmaTxferRes	DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri);
671:                 
672:                 	/*********************************************************************
673:                 	 * Function:        DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri)
674:                 	 *
675:                 	 * PreCondition:    chn		- a valid DMA channel
676:                 	 * 				- s1, s2	- valid memory pointers
677:                 	 *                              - 0 < n <= DmaGetMaxTxferSize()
678:                 	 *
679:                 	 * Input:			s1		- destination pointer
680:                 	 * 					s2		- source pointer
681:                 	 * 					n	- max number of bytes to transfer
682:                 	 * 					chn		- the DMA channel to perform the transfer
683:                 	 * 					chPri	- the desired channel priority
684:                 	 *
685:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
686:                 	 * 					an DmaTxferRes error code  otherwise
687:                 	 *
688:                 	 * Side Effects:    None
689:                 	 *
690:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
691:                 	 * 			Then it copies one zero terminated string from source to destination.
692:                 	 * 			It copies no more than n characters from s2.
693:                 	 *
694:                 	 *
695:                 	 * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
696:                 	 *                    This way, the transfer will occur correctly together with checksum calculation.
697:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
698:                 	 *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
699:                 	 *                  - The function clears the suspend state and resumes the operation of the DMA controller.
700:                 	 *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
701:                 	 *
702:                 	 *
703:                  	 * Example:		res=DmaChnStrncpy(str1, str2, MAX_STR_LEN, DMA_CHANNEL1, DMA_CHN_PRI3);
704:                 	 ********************************************************************/
705:                 	 DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri);
706:                 
707:                 	/*********************************************************************
708:                 	 * Function:        DmaTxferRes DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
709:                 	 *
710:                 	 * PreCondition:    chn    - a valid DMA channel
711:                 	 *                  d, s   - valid memory pointer
712:                 	 *                  n>0, n<=DmaGetMaxTxferSize()
713:                 	 *
714:                 	 * Input:           d     - address where to deposit the result
715:                 	 *                  s     - source buffer pointer
716:                 	 *                  n     - number of bytes in the pointer
717:                 	 *                  chn   - the DMA channel to use
718:                 	 *                  chPri - the desired channel priority
719:                 	 * 
720:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
721:                 	 *                  an DmaTxferRes error code  otherwise
722:                 	 *
723:                 	 * Side Effects:    None
724:                 	 *
725:                 	 * Overview:        The function is a helper that calculates the CRC of a memory block.
726:                 	 *                  The function configures the DMA channel for a fast memory transfer and calculates the CRC.
727:                 	 *
728:                 	 *
729:                 	 * Note:            - The CRC generator must have been previously configured using DmaSfmCrcConfigure()
730:                 	 *                  - No transfer is done, just the CRC is calculated.
731:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
732:                 	 *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
733:                 	 *                  - The checksum type is switched to CRC.
734:                 	 *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
735:                 	 *                  
736:                 	 * Example:          int myCrc; DmaChnMemCrc(&myCrc, srcBuff, sizeof(srcBuff), DMA_CHANNEL2, DMA_CHN_PRI3);
737:                 	 ********************************************************************/
738:                 	 DmaTxferRes	DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
739:                 
740:                 	/*********************************************************************
741:                 	 * Function:        DmaTxferRes DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
742:                 	 *
743:                 	 * PreCondition:    chn    - a valid DMA channel
744:                 	 *                  d, s   - valid memory pointer
745:                 	 *                  n>0, n<=DmaGetMaxTxferSize()
746:                 	 *
747:                 	 * Input:           d     - address where to deposit the result
748:                 	 *                  s     - source buffer pointer
749:                 	 *                  n     - number of bytes in the pointer
750:                 	 *                  chn   - the DMA channel to use
751:                 	 *                  chPri - the desired channel priority
752:                 	 * 
753:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
754:                 	 *                  an DmaTxferRes error code  otherwise
755:                 	 *
756:                 	 * Side Effects:    None
757:                 	 *
758:                 	 * Overview:        The function is a helper that calculates the IP checksum of a memory block.
759:                 	 *                  The function configures the DMA channel for a fast memory transfer and calculates the IP checksum.
760:                 	 *
761:                 	 *
762:                 	 * Note:            - The checksum generator must have been previously seeded using DmaSfmSetSeed()
763:                 	 *                  - No transfer is done, just the checksum is calculated.
764:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
765:                 	 *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
766:                 	 *                  - The checksum type is switched to IP checksum.
767:                 	 *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
768:                 	 *                  
769:                 	 * Example:          int myChecksum; DmaChnMemChecksum(&myChecksum, srcBuff, sizeof(srcBuff), DMA_CHANNEL1, DMA_CHN_PRI3);
770:                 	 ********************************************************************/
771:                 	 DmaTxferRes	DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
772:                 
773:                 	// High level Special Function Module (SFM) functions
774:                 
775:                 	/*********************************************************************
776:                 	 * Function:        void DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
777:                 	 *
778:                 	 * PreCondition:    cType, bitO, rMode - valid values
779:                 	 *
780:                 	 * Input:           cType - checksum type to be calculated: CRC or IP Checksum
781:                 	 *                  bitO  - the bit order to be used MSb or LSb first
782:                 	 *                  rMode - the reordering mode of the bytes when calculating the checksum 
783:                 	 *
784:                 	 * Output:          None
785:                 	 *
786:                 	 * Side Effects:    Whenever the Transfer re-ordering is enabled the rMode setting will influence the destination data layout
787:                 	 *
788:                 	 * Overview:        The function configures the SFM module by setting the parameters that define the behavior:
789:                 	 *                      - the type of the checksum to be calculated (either CRC or IP checksum are supported)
790:                 	 *                      - the bit ordering (how a specific byte is used in the checksum calculation: MSb or LSb first) 
791:                 	 *                      - the data re-ordering (how bytes are re-ordered before calculating the checksum).
792:                 	 *                      All these values affect the way the checksum is calculated.
793:                 	 *
794:                 	 * Note:            None
795:                 	 *
796:                 	 * Example:         DmaSfmConfigure(DMA_CHKSUM_CRC, DMA_BITO_LSb, DMA_REORDER_ENDIAN);
797:                 	 ********************************************************************/
798:                 	extern __inline__ void __attribute__((always_inline)) DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
799:                 	{
800:                 		DCRCCONCLR=_DCRCCON_CRCTYP_MASK|_DCRCCON_BITO_MASK|_DCRCCON_BYTO_MASK;
801:                 		DCRCCONSET=(cType<<_DCRCCON_CRCTYP_POSITION)|(bitO<<_DCRCCON_BITO_POSITION)|(rMode<<_DCRCCON_BYTO_POSITION);
802:                 	}
803:                 
804:                 	/*********************************************************************
805:                 	 * Function:        void DmaSfmTxferReorder(int enable)
806:                 	 *
807:                 	 * PreCondition:    None
808:                 	 *
809:                 	 * Input:           enable - boolean to enable/disable the re-ordering of the data transfer
810:                 	 *
811:                 	 * Output:          None
812:                 	 *
813:                 	 * Side Effects:    None
814:                 	 *
815:                 	 * Overview:        The function configures the data transfer re-ordering of the SFM module.
816:                 	 *                  If the re-ordering is enabled, the data is read from the source, re-ordered accordingly and then written to the destination.
817:                 	 *                  Otherwise the data is written to the destination un-modified.
818:                 	 *                  The re-ordering is the one specified by the DmaReorderMode parameter in the DmaSfmConfigure() call.
819:                 	 *                  
820:                 	 *
821:                 	 * Note:            - The data transfer re-ordering should be used only for normal (background mode) data transfers.
822:                 	 *                  - In append mode the data transfer re-ordering should not be enabled (undefined behavior)!
823:                 	 *                  - Whenever the data re-ordering is enabled, the transfer should be aligned at both ends (source and destination).
824:                 	 *                    Un-aligned transfers are not supported (undefined behavior)!
825:                 	 *
826:                 	 * Example:         DmaSfmTxferReorder();
827:                 	 ********************************************************************/
828:                 	extern __inline__ void __attribute__((always_inline)) DmaSfmTxferReorder(int enable)
829:                 	{
830:                 		DCRCCONCLR=_DCRCCON_WBO_MASK;
831:                 		DCRCCONSET=(enable<<_DCRCCON_WBO_POSITION);
832:                 	}
833:                 
834:                 
835:                 	 /*********************************************************************
836:                 	 * Function:        void DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
837:                 	 *
838:                 	 * PreCondition:    pLen   - valid polynomial length within 1-32
839:                 	 *
840:                 	 * Input:           polynomial	- the layout of the CRC generator
841:                 	 *                  pLen        - the length of the CRC generator polynomial
842:                 	 *                  seed        - the initial seed of the CRC generator
843:                 	 *
844:                 	 * Output:          None
845:                 	 *
846:                 	 * Side Effects:    None
847:                 	 *
848:                 	 * Overview:        The function configures the SFM CRC module by setting the parameters that define the generator polynomial:
849:                 	 *                  - the length of the CRC generator polynomial, pLen;
850:                 	 *                  - the function sets the layout of the shift stages that take place in the CRC generation.
851:                 	 *                    Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
852:                 	 *                    If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
853:                 	 *                    Note that in a proper CRC polynomial, both the most significant bit (MSb) and least significant bit(LSb)
854:                 	 *                    are always a '1'. Considering the generator polynomial: X^16+X^15+X^2+1, the value to be written as
855:                 	 *                    feedback should be 0x8005, or 0x8004, but not 0x018005;
856:                 	 *                  - the function sets the seed of the CRC generator. This is the initial data present in the
857:                 	 *                   CRC shift register before the CRC calculation begins. A good initial value is usually 0xffffffff.
858:                 	 *
859:                 	 * Note:            - Bit 0 of the generator polynomial is always XOR'ed.
860:                 	 *                  - When the append mode is set, the attached DMA channel has to have destination size <=4.
861:                 	 *                    Upon the transfer completion the calculated CRC is stored at the destination address.
862:                 	 *                  - When append mode is cleared, the DMA transfer occurs normally, and the CRC value is available using
863:                 	 *                    the CrcResult() function.
864:                 	 *                  - The CRC module should be configured before enabled.
865:                 	 *                  - These settings are relevant only when the SFM is configured for the CRC type of checksum.
866:                 	 *                  - The checksum register is the same for CRC or IP checksum mode. Therefore, this function changes also the seed for the IP checksum.
867:                 	 *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
868:                 	 *
869:                 	 * Example:         DmaSfmCrcConfigure(0x04c11db7, 32, 0xffffffff);
870:                 	 ********************************************************************/
871:                 	extern __inline__ void __attribute__((always_inline)) DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
872:                 	{
873:                 		DCRCCONCLR=_DCRCCON_PLEN_MASK;
874:                 		DCRCCONSET=(pLen-1)<<_DCRCCON_PLEN_POSITION;
875:                 		DCRCDATA=seed;
876:                 		DCRCXOR=polynomial;
877:                 	}
878:                 	
879:                 	#define DmaCrcConfigure	DmaSfmCrcConfigure	// PIC32_3xx backward compatibility name
880:                 
881:                 
882:                 	/*********************************************************************
883:                 	 * Function:        void DmaSfmAttachChannel(DmaChannel chn, int appendMode)
884:                 	 *
885:                 	 * PreCondition:    chn	   - valid DMA channel
886:                 	 *
887:                 	 * Input:           chn         - the DMA channel to be attached to the checksum module.
888:                 	 *                  appendMode	- if TRUE the data passed to the checksum generator is not transferred to destination
889:                 	 *                                but it's written to the destination address when the block transfer is complete.
890:                 	 *                              - if FALSE the data is transferred normally while the checksum is calculated.
891:                 	 *                                The checksum will be available using the DmaSfmChecksum function.
892:                 	 *
893:                 	 * Output:          None
894:                 	 *
895:                 	 * Side Effects:    None
896:                 	 *
897:                 	 * Overview:        The function attaches the SFM checksum module to a DMA channel and enables the checksum generator.
898:                 	 *                  From now on, all the DMA traffic is directed to the SFM checksum generator. Once the DMA block transfer
899:                 	 *                  is complete, the checksum result is available in the checksum data register.
900:                 	 *                  If append mode is enabled, no data transfer takes place but the checksum result will be deposited at the DMA destination address.
901:                 
902:                 	 *
903:                 	 * Note:            If append mode is enabled the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
904:                 	 * 
905:                 	 * Example:         DmaSfmAttachChannel(DMA_CHANNEL0, TRUE);
906:                 	 ********************************************************************/
907:                 	void			DmaSfmAttachChannel(DmaChannel chn, int appendMode);
908:                 	#define			CrcAttachChannel	DmaSfmAttachChannel		// PIC32_3xx backward compatibility name	
909:                 
910:                 	/*********************************************************************
911:                 	 * Function:        unsigned int DmaSfmChecksum(void)
912:                 	 *
913:                 	 * PreCondition:    None
914:                 	 *
915:                 	 * Input:			None
916:                 	 *
917:                 	 * Output:          the current value of the checksum generator.
918:                 	 *
919:                 	 * Side Effects:    None
920:                 	 *
921:                 	 * Overview:		The function returns the calculated checksum value.
922:                 	 *
923:                 	 * Note:            - The function returns the valid checksum result. The masking out the unused MSbits in the checksum register is done by the hardware.
924:                 	 *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
925:                 	 *
926:                 	 * Example:         unsigned int myChk=DmaSfmChecksum();
927:                 	 ********************************************************************/
928:                 	extern __inline__ int __attribute__((always_inline)) DmaSfmChecksum(void)
929:                 	{
930:                 		return DCRCDATA;
931:                 	}
932:                 	#define		CrcResult	DmaSfmChecksum		// PIC32_3xx backward compatibility name
933:                 	#define		DmaCrcGetValue	DmaSfmChecksum		// PIC32_3xx backward compatibility name 
934:                 
935:                 
936:                 	/*********************************************************************
937:                 	 * Function:        void DmaSfmSetSeed(unsigned int seed)
938:                 	 *
939:                 	 * PreCondition:    None
940:                 	 *
941:                 	 * Input:           seed	- the initial seed of the checksum generator
942:                 	 *
943:                 	 * Output:          None
944:                 	 *
945:                 	 * Side Effects:    None
946:                 	 *
947:                 	 * Overview:        The function sets the seed of the checksum generator. This is the initial data present in the
948:                 	 *                  CRC shift register or the IP checksum calculator before the actual transfer/calculation begins.
949:                 	 *
950:                 	 * Note:            When the SFM is configured for IP checksum mode, only the least significant 16 bits are relevant.
951:                 	 *
952:                 	 * Example:         DmaSfmSetSeed(0xffffffff);
953:                 	 ********************************************************************/
954:                 	extern __inline__ void __attribute__((always_inline)) DmaSfmSetSeed(unsigned int seed)
955:                 	{
956:                 		DCRCDATA=seed;
957:                 	}
958:                 	#define		DmaCrcSetSeed	DmaSfmSetSeed		// PIC32_3xx backward compatibility name
959:                 
960:                 	 
961:                 /*********************  end of high level functions ****************************************/
962:                 
963:                 	// low level definitions for the API functions
964:                 
965:                 
966:                 	typedef struct
967:                 	{
968:                 		union
969:                 		{
970:                 			struct
971:                 			{
972:                 				unsigned int chn:	3;		// last active DMA channel
973:                 				unsigned int rdOp:	1;		// last DMA operation, read if 1, write if 0
974:                 			};
975:                 			unsigned int	w;						// word access
976:                 		}lastAccess;
977:                 		void*	lastAddress;		// most recent DMA address
978:                 	}DmaStatus;			// DMA controller status
979:                 
980:                 	typedef enum
981:                 	{
982:                 		DMA_GFLG_SUSPEND =	_DMACON_SUSPEND_MASK,	// suspend DMA controller operation
983:                 		DMA_GFLG_ON =		_DMACON_ON_MASK,		// DMA module enabled/desabled
984:                 		//
985:                 		DMA_GFLG_ALL_FLAGS=	DMA_GFLG_SUSPEND|DMA_GFLG_ON		// all flags
986:                 	}DmaGlblFlags;	// flags for controlling global DMA controller behavior. From processor header file.
987:                 
988:                 
989:                 
990:                 
991:                 	typedef enum
992:                 	{
993:                 		DMA_EV_ABORT_IRQ_EN =		_DCH0ECON_AIRQEN_MASK,
994:                 		DMA_EV_START_IRQ_EN =		_DCH0ECON_SIRQEN_MASK,
995:                         // use DMA_EV_START_IRQ() and DMA_EV_ABORT_IRQ() below for selecting
996:                         // the start and abort IRQ signals
997:                 		DMA_EV_MATCH_EN =			_DCH0ECON_PATEN_MASK,
998:                 
999:                 
1000:                        // compiler use only field
1001:                        _DMA_EV_MAX_MASK =     _DCH0ECON_CHAIRQ_MASK,
1002:                	}DmaEvCtrlFlags;	/*DMA channel event control fields accessible as flags also
1003:                	                	  part of DmaEvCtrlFlags:
1004:                	                	*/
1005:                	#define	DMA_EV_START_IRQ(irq)	(DMA_EV_START_IRQ_EN | ((irq)<<_DCH0ECON_CHSIRQ_POSITION))	// NOTE: irq has to be a symbol from the processor header file
1006:                	#define	DMA_EV_ABORT_IRQ(irq)	(DMA_EV_ABORT_IRQ_EN | ((irq)<<_DCH0ECON_CHAIRQ_POSITION))	// NOTE: irq has to be a symbol from the processor header file
1007:                
1008:                	// DMA channel event control as a structure:
1009:                	#define	DmaEvCtrl	__DCH0ECONbits_t
1010:                
1011:                
1012:                
1013:                
1014:                	typedef enum
1015:                	{
1016:                		DMA_CTL_AUTO_EN =		_DCH0CON_CHAEN_MASK,
1017:                		DMA_CTL_CHAIN_EN =		_DCH0CON_CHCHN_MASK,
1018:                		DMA_CTL_DET_EN =		_DCH0CON_CHAED_MASK,
1019:                		DMA_CTL_CHN_EN =		_DCH0CON_CHEN_MASK,
1020:                		DMA_CTL_CHAIN_DIR =		_DCH0CON_CHCHNS_MASK,
1021:                        // use the DMA_CTL_PRI() below for selecting the DMA
1022:                        // channel priority
1023:                	}DmaChnCtrlFlags;	// controlling the DMA channel with flags
1024:                	// also part of DmaChnCtrlFlags:
1025:                	#define	DMA_CTL_PRI(pri)	((pri)&_DCH0CON_CHPRI_MASK) // DMA Control channel priority
1026:                
1027:                	// DMA channel control as a structure:
1028:                	#define	DmaChnCtrl  	__DCH0CONbits_t
1029:                
1030:                	typedef struct
1031:                	{
1032:                		void*	vSrcAdd;		// source of the DMA transfer, virtual
1033:                		void*	vDstAdd;		// destination of the DMA transfer, virtual
1034:                		int	srcSize;		// source buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1035:                		int	dstSize;		// destination buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1036:                		int	cellSize;		// no of bytes txferred per event, 1 to DmaGetMaxTxferSize().
1037:                	}DmaTxferCtrl;		// transfer setting: the transfer source, destination addresses and size, cell size
1038:                
1039:                
1040:                	/********************** low level DMA channel functions *******************************/
1041:                
1042:                
1043:                
1044:                	// Global DMA controller functions
1045:                
1046:                	/*********************************************************************
1047:                	 * Function:        void DmaEnable(int enable)
1048:                	 *
1049:                	 * PreCondition:    None
1050:                	 *
1051:                	 * Input:           enable - boolean to enable/disable the DMA controller
1052:                	 *
1053:                	 * Output:          None
1054:                	 *
1055:                	 * Side Effects:    None
1056:                	 *
1057:                	 * Overview:       The function enables/disables the DMA controller.
1058:                	 *
1059:                	 * Note:           None.
1060:                	 *
1061:                	 * Example:        DmaEnable(1);
1062:                	 ********************************************************************/
1063:                	extern __inline__ void __attribute__((always_inline)) DmaEnable(int enable)
1064:                	{
1065:                		if(enable)
1066:                		{
1067:                			DMACONSET=_DMACON_ON_MASK;
1068:                		}
1069:                		else
1070:                		{
1071:                			DMACONCLR=_DMACON_ON_MASK;
1072:                			while(DMACONbits.ON);		// wait to take effect
1073:                		}
1074:                	}
1075:                
1076:                	/*********************************************************************
1077:                	 * Function:        void DmaReset(void)
1078:                	 *
1079:                	 * PreCondition:    None
1080:                	 *
1081:                	 * Input:		None
1082:                	 *
1083:                	 * Output:          None
1084:                	 *
1085:                	 * Side Effects:    None
1086:                	 *
1087:                	 * Overview:        The function resets the DMA controller.
1088:                	 *
1089:                	 * Note:            None.
1090:                	 *
1091:                	 * Example:        DmaReset();
1092:                	 ********************************************************************/
1093:                	#define            DmaReset()	DmaEnable(0)
1094:                
1095:                
1096:                	/*********************************************************************
1097:                	 * Function:        int DmaSuspend(void)
1098:                	 *
1099:                	 * PreCondition:    None
1100:                	 *
1101:                	 * Input:		None
1102:                	 *
1103:                	 * Output:          true if the DMA was previously suspended, false otherwise
1104:                	 *
1105:                	 *
1106:                	 * Side Effects:    None
1107:                	 *
1108:                	 * Overview:        The function suspends the DMA controller.
1109:                	 *
1110:                	 * Note:            After the execution of this function the DMA operation is supposed to be suspended.
1111:                	 *                  I.e. the function has to wait for the suspension to take place!
1112:                	 *
1113:                	 * Example:         int susp=DmaSuspend();
1114:                	 ********************************************************************/
1115:                        extern __inline__ int __attribute__((always_inline)) DmaSuspend(void)
1116:                	{
1117:                		int suspSt;
1118:                		if(!(suspSt=DMACONbits.SUSPEND))
9D00AA84  3C02BF88   LUI V0, -16504
9D00AA88  8C423000   LW V0, 12288(V0)
9D00AA8C  7C420300   EXT V0, V0, 12, 1
9D00AA90  304200FF   ANDI V0, V0, 255
9D00AA94  AFC20034   SW V0, 52(S8)
9D00AA98  8FC20034   LW V0, 52(S8)
9D00AA9C  14400009   BNE V0, ZERO, 0x9D00AAC4
9D00AAA0  00000000   NOP
9D00AB58  3C02BF88   LUI V0, -16504
9D00AB5C  8C423000   LW V0, 12288(V0)
9D00AB60  7C420300   EXT V0, V0, 12, 1
9D00AB64  304200FF   ANDI V0, V0, 255
9D00AB68  AFC20040   SW V0, 64(S8)
9D00AB6C  8FC20040   LW V0, 64(S8)
9D00AB70  14400010   BNE V0, ZERO, 0x9D00ABB4
9D00AB74  00000000   NOP
1119:                		{
1120:                			DMACONSET=_DMACON_SUSPEND_MASK;		// suspend
9D00AAA4  3C02BF88   LUI V0, -16504
9D00AAA8  24031000   ADDIU V1, ZERO, 4096
9D00AAAC  AC433008   SW V1, 12296(V0)
9D00AB78  3C02BF88   LUI V0, -16504
9D00AB7C  24031000   ADDIU V1, ZERO, 4096
9D00AB80  AC433008   SW V1, 12296(V0)
1121:                			while((DMACONbits.DMABUSY));	// wait to be actually suspended
9D00AAB0  3C02BF88   LUI V0, -16504
9D00AAB4  8C423000   LW V0, 12288(V0)
9D00AAB8  30420800   ANDI V0, V0, 2048
9D00AABC  1440FFFC   BNE V0, ZERO, 0x9D00AAB0
9D00AAC0  00000000   NOP
9D00AB84  3C02BF88   LUI V0, -16504
9D00AB88  8C423000   LW V0, 12288(V0)
9D00AB8C  30420800   ANDI V0, V0, 2048
9D00AB90  1440FFFC   BNE V0, ZERO, 0x9D00AB84
9D00AB94  00000000   NOP
1122:                		}
1123:                		return suspSt;
9D00AAC4  8FC20034   LW V0, 52(S8)
9D00AB98  0B402AEE   J 0x9D00ABB8
9D00AB9C  00000000   NOP
9D00ABB4  00000000   NOP
1124:                	}
1125:                
1126:                
1127:                
1128:                	/*********************************************************************
1129:                	 * Function:        void DmaResume(int susp)
1130:                	 *
1131:                	 * PreCondition:    None
1132:                	 *
1133:                	 * Input:		the desired DMA suspended state.
1134:                	 *
1135:                	 * Output:          None
1136:                	 *
1137:                	 * Side Effects:    None
1138:                	 *
1139:                	 * Overview:		The function restores the DMA controller activity to the old suspended mode.
1140:                	 *
1141:                	 * Note:            None.
1142:                	 *
1143:                	 * Example:			int isSusp=DmaSuspend(); {....}; DmaResume(isSusp);
1144:                	 ********************************************************************/
1145:                        extern __inline__ void __attribute__((always_inline)) DmaResume(int susp)
1146:                	{
1147:                		if(susp)
9D00AB4C  8FC2003C   LW V0, 60(S8)
9D00AB50  10400013   BEQ V0, ZERO, 0x9D00ABA0
9D00AB54  00000000   NOP
1148:                		{
1149:                			DmaSuspend();
1150:                		}
1151:                		else
1152:                		{
1153:                			DMACONCLR=_DMACON_SUSPEND_MASK;		// resume DMA activity
9D00ABA0  3C02BF88   LUI V0, -16504
9D00ABA4  24031000   ADDIU V1, ZERO, 4096
9D00ABA8  AC433004   SW V1, 12292(V0)
9D00ABAC  0B402AEE   J 0x9D00ABB8
9D00ABB0  00000000   NOP
1154:                		}
1155:                	}
1156:                
1157:                	/*********************************************************************
1158:                	 * Function:        void DmaGetStatus(DmaStatus* pStat)
1159:                	 *
1160:                	 * PreCondition:    pStat	- valid pointer
1161:                	 *
1162:                	 * Input:			pStat	- pointer to a DmaStatus structure to store the current DMA controller
1163:                	 * 							status, carrying the following info:
1164:                	 * 								- chn:	the last active DMA channel
1165:                	 * 								- rdOp: the last DMA operation, read/write
1166:                	 * 								- lastAddress: the most recent DMA address
1167:                	 *
1168:                	 * Output:          None
1169:                	 *
1170:                	 * Side Effects:    None
1171:                	 *
1172:                	 * Overview:		The function updates the info for the current DMA controller status.
1173:                	 * 					It updates the last DMA: operation, channel used and address.
1174:                	 *
1175:                	 * Note:            None.
1176:                	 *
1177:                	 * Example:			DmaStatus stat; DmaGetStatus(&stat);
1178:                	 ********************************************************************/
1179:                	 void			DmaGetStatus(DmaStatus* pStat);
1180:                
1181:                	/*********************************************************************
1182:                	 * Function:        void DmaSetGlobalFlags(DmaGlblFlags gFlags)
1183:                	 *
1184:                	 * PreCondition:    None
1185:                	 *
1186:                	 * Input:           gFlags - flags to be set, having the following fields:
1187:                	 * 			- DMA_GFLG_SUSPEND: DMA controller operation suspend
1188:                	 * 			- DMA_GFLG_ON: DMA controller enabled/desabled
1189:                	 * 			- DMA_GFLG_ALL_FLAGS: all flags
1190:                	 *
1191:                	 * Output:          None
1192:                	 *
1193:                	 * Side Effects:    None
1194:                	 *
1195:                	 * Overview:        The function affects the global behavior of the DMA controller.
1196:                	 *                  It sets the specified flags. Any flag that is set in the gFlags will be
1197:                	 *                  enabled, the other flags won't be touched.
1198:                	 *
1199:                	 * Note:            None.
1200:                	 *
1201:                	 * Example:         DmaSetGlobalFlags(DMA_GFLG_ON);
1202:                	 ********************************************************************/
1203:                        extern __inline__ void __attribute__((always_inline)) DmaSetGlobalFlags(DmaGlblFlags gFlags)
1204:                	{
1205:                		DMACONSET=gFlags;
1206:                	}
1207:                
1208:                	/*********************************************************************
1209:                	 * Function:        void DmaClrGlobalFlags(DmaGlblFlags gFlags)
1210:                	 *
1211:                	 * PreCondition:    None
1212:                	 *
1213:                	 * Input:           gFlags - flags to be cleared, having the following fields:
1214:                	 *                               - DMA_GFLG_SUSPEND: DMA controller operation suspend
1215:                	 *                               - DMA_GFLG_ON: DMA controller enabled/desabled
1216:                	 *                               - DMA_GFLG_ALL_FLAGS: all flags
1217:                	 *
1218:                	 * Output:          None
1219:                	 *
1220:                	 * Side Effects:    None
1221:                	 *
1222:                	 * Overview:        The function affects the global behavior of the DMA controller.
1223:                	 *                  It clears the specified flags. Any flag that is set in the gFlags will be
1224:                	 *                  cleared, the other flags won't be touched.
1225:                	 *
1226:                	 * Note:            None.
1227:                	 *
1228:                	 * Example:         DmaClrGlobalFlags(DMA_GFLG_SUSPEND);
1229:                	 ********************************************************************/
1230:                        extern __inline__ void __attribute__((always_inline)) DmaClrGlobalFlags(DmaGlblFlags gFlags)
1231:                	{
1232:                		DMACONCLR=gFlags;
1233:                	}
1234:                
1235:                
1236:                	/*********************************************************************
1237:                	 * Function:        void DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1238:                	 *
1239:                	 * PreCondition:    None
1240:                	 *
1241:                	 * Input:           gFlags - flags to be set, having the following fields:
1242:                	 *                                 - DMA_GFLG_SUSPEND: DMA controller operation suspend
1243:                	 *                                 - DMA_GFLG_ON: DMA controller enabled/desabled
1244:                	 *                                 - DMA_GFLG_ALL_FLAGS: all flags
1245:                	 *
1246:                	 * Output:          None
1247:                	 *
1248:                	 * Side Effects:    None
1249:                	 *
1250:                	 * Overview:        The function affects the global behavior of the DMA controller.
1251:                	 *                  It forces the flags to have the specified gFlags value.
1252:                	 *
1253:                	 * Note:            None.
1254:                	 *
1255:                	 * Example:         DmaWriteGlobalFlags(DMA_GFLG_ALL_FLAGS);
1256:                	 ********************************************************************/
1257:                        extern __inline__ void __attribute__((always_inline)) DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1258:                	{
1259:                		DMACON=gFlags;
1260:                	}
1261:                
1262:                	/*********************************************************************
1263:                	 * Function:        DmaGlblFlags DmaGetGlobalFlags(void)
1264:                	 *
1265:                	 * PreCondition:    None
1266:                	 *
1267:                	 * Input:           None
1268:                	 *
1269:                	 * Output:          The current DMA controller flags settings.
1270:                	 *                              - DMA_GFLG_SUSPEND: DMA controller operation suspend
1271:                	 *                              - DMA_GFLG_ON: DMA controller enabled/desabled
1272:                	 *
1273:                	 * Side Effects:    None
1274:                	 *
1275:                	 * Overview:        The function returns the global flags of the DMA controller.
1276:                	 *
1277:                	 * Note:            None.
1278:                	 *
1279:                	 * Example:         DmaGlblFlags dmaFlags=DmaGetGlobalFlags();
1280:                	 ********************************************************************/
1281:                        extern __inline__ DmaGlblFlags __attribute__((always_inline)) DmaGetGlobalFlags(void)
1282:                	{
1283:                		return (DmaGlblFlags)DMACON;
1284:                	}
1285:                
1286:                
1287:                	/*********************************************************************
1288:                	 * Function:        int DmaGetMaxTxferSize(void)
1289:                	 *
1290:                	 * PreCondition:    None
1291:                	 *
1292:                	 * Input:           None
1293:                	 *
1294:                	 * Output:          The maximum transfer capacity for a DMA channel, in bytes.
1295:                	 *
1296:                	 * Side Effects:    None
1297:                	 *
1298:                	 * Overview:        The function returns the maximum number of bytes that can be transferred by a DMA channel.
1299:                	 *
1300:                	 * Note:            Revision dependant.
1301:                	 *
1302:                	 * Example:         int dmaMaxSz=DmaGetMaxTxferSize();
1303:                	 ********************************************************************/
1304:                	extern __inline__ int __attribute__((always_inline)) DmaGetMaxTxferSize(void)
1305:                	{
1306:                		return 65536;
1307:                	}
1308:                
1309:                	// Direct Channel control functions
1310:                
1311:                	typedef enum
1312:                	{
1313:                		DMA_CONFIG_DEFAULT = 0,                             // DMA default operation
1314:                		DMA_CONFIG_AUTO	= _DCH0CON_CHAEN_MASK,              // DMA channel is auto enabled
1315:                		DMA_CONFIG_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),	// DMA channel is chained to lower channel
1316:                		DMA_CONFIG_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),		// DMA channel is chained to higher channel
1317:                		DMA_CONFIG_DET_EN = _DCH0CON_CHAED_MASK,			// events detection enabled while channel off
1318:                		DMA_CONFIG_ENABLE = _DCH0CON_CHEN_MASK,	            // DMA channel is enabled after open
1319:                		DMA_CONFIG_MATCH	= 0x80000000,                   // DMA channel stops on match
1320:                	}DmaConfigFlags;	// flags for the channel configuration
1321:                
1322:                
1323:                
1324:                	/*********************************************************************
1325:                	 * Function:        void DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags)
1326:                	 *
1327:                	 * PreCondition:    chPri  - valid channel priority, 0-3
1328:                	 *
1329:                	 * Input:           chn    - channel to be configured in the DMA controller
1330:                	 *                  chPri  - the priority given to the channel, 0-3
1331:                	 *                  cFlags - orred flags specifying the configuration:
1332:                	 *                           DMA_CONFIG_DEFAULT: DMA default operation mode
1333:                	 *                           DMA_CONFIG_AUTO:	DMA channel is auto enabled
1334:                	 *                           DMA_CONFIG_CHAIN_LOW: DMA channel is chained to lower channel
1335:                	 *                           DMA_CONFIG_CHAIN_HI: DMA channel is chained to higher channel
1336:                	 *                           DMA_CONFIG_DET_EN: events detection enabled while channel off
1337:                	 *                           DMA_CONFIG_ENABLE: DMA channel is enabled when opened
1338:                	 *                           DMA_CONFIG_MATCH:	DMA channel stops on match
1339:                	 *
1340:                	 *
1341:                	 *
1342:                	 * Output:          None
1343:                	 *
1344:                	 * Side Effects:    None
1345:                	 *
1346:                	 * Overview:        The function configures the selected DMA channel using the supplied user flags and priority.
1347:                	 *
1348:                	 * Note:            - The channel is NOT turned off. It should be turned off before calling this function.
1349:                	 *                  The channel is just configured.
1350:                	 *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
1351:                	 *                  if DMA_CONFIG_ENABLE flag was not specified.
1352:                	 *                  - The function does not touch the interrupt flags, interrupt enables, etc.
1353:                	 *                  The interrupt flags should have been previously cleared and interrupts disabled before calling this function.
1354:                	 *                  - The start and abort Irqs, the channel event enable flags are not touched/cleared by this function.
1355:                	 *                  User has to call event channel functions to clear/enable the event flags if needed.
1356:                	 *
1357:                	 * Example:         DmaChnDisable(DMA_CHANNEL2); DmaChnConfigure(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_CONFIG_AUTO|DMA_CONFIG_MATCH|DMA_CONFIG_ENABLE);
1358:                	 ********************************************************************/
1359:                	void			DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags);
1360:                
1361:                
1362:                	/*********************************************************************
1363:                	 * Function:        int DmaChnGetSrcPnt(DmaChannel chn)
1364:                	 *
1365:                	 * PreCondition:    chn	- valid DMA channel
1366:                	 *
1367:                	 * Input:			chn		- DMA channel number
1368:                	 *
1369:                	 * Output:          Current channel source pointer.
1370:                	 *
1371:                	 * Side Effects:    None
1372:                	 *
1373:                	 * Overview:		The function retrieves the current source pointer for the selected DMA channel.
1374:                	 * 					It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the source transfer buffer.
1375:                	 *
1376:                	 * Note:            None
1377:                	 *
1378:                	 * Example:         int srcPnt=DmaChnGetSrcPnt(DMA_CHANNEL3);
1379:                	 ********************************************************************/
1380:                	 int			DmaChnGetSrcPnt(DmaChannel chn);
1381:                
1382:                	/*********************************************************************
1383:                	 * Function:        int DmaChnGetDstPnt(DmaChannel chn)
1384:                	 *
1385:                	 * PreCondition:    chn	- valid DMA channel
1386:                	 *
1387:                	 * Input:			chn		- DMA channel number
1388:                	 *
1389:                	 * Output:          Current channel destination pointer.
1390:                	 *
1391:                	 * Side Effects:    None
1392:                	 *
1393:                	 * Overview:		The function retrieves the current destination pointer for the selected DMA channel.
1394:                	 * 					It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the destination transfer buffer.
1395:                	 *
1396:                	 * Note:            None
1397:                	 *
1398:                	 * Example:			int dstPnt=DmaChnGetDstPnt(DMA_CHANNEL3);
1399:                	 ********************************************************************/
1400:                	 int			DmaChnGetDstPnt(DmaChannel chn);
1401:                
1402:                	/*********************************************************************
1403:                	 * Function:        int DmaChnGetCellPnt(DmaChannel chn)
1404:                	 *
1405:                	 * PreCondition:    chn	- valid DMA channel
1406:                	 *
1407:                	 * Input:			chn		- DMA channel number
1408:                	 *
1409:                	 * Output:          Current channel transfer pointer.
1410:                	 *
1411:                	 * Side Effects:    None
1412:                	 *
1413:                	 * Overview:		The function retrieves the current transfer progress pointer for the selected DMA channel.
1414:                	 * 					It ranges 0 to DmaGetMaxTxferSize()-1.
1415:                	 *
1416:                	 * Note:            None
1417:                	 *
1418:                	 * Example:			int cellPnt=DmaChnGetCellPnt(DMA_CHANNEL3);
1419:                	 ********************************************************************/
1420:                	 int			DmaChnGetCellPnt(DmaChannel chn);
1421:                
1422:                
1423:                
1424:                	/*********************************************************************
1425:                	 * Function:        void DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1426:                	 *
1427:                	 * PreCondition:    chn	- valid DMA channel
1428:                	 *
1429:                	 * Input:			chn			- DMA channel number
1430:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1431:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1432:                	 * 										- SIRQEN: enable/disable the start IRQ action
1433:                	 * 										- PATEN: enable/disable the pattern match and abort
1434:                	 * 									or any of the DmaEvCtrlFlags:
1435:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1436:                	 *
1437:                	 *
1438:                	 * Output:          None
1439:                	 *
1440:                	 * Side Effects:    None
1441:                	 *
1442:                	 * Overview:		The function sets the events that start and abort the transfer
1443:                	 * 					for the selected DMA channel.
1444:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1445:                	 * 					enabled for the selected channel, the other channel event flags won't be touched.
1446:                	 *
1447:                	 * Note:            None.
1448:                	 *
1449:                	 * Example:			either:
1450:                	 * 						DmaChnSetEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN;
1451:                	 * 					or:
1452:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.SIRQEN=1;
1453:                	 * 						DmaChnSetEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1454:                	 *
1455:                	 ********************************************************************/
1456:                	 void			DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1457:                
1458:                
1459:                	/*********************************************************************
1460:                	 * Function:        void DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1461:                	 *
1462:                	 * PreCondition:    chn	- valid DMA channel
1463:                	 *
1464:                	 * Input:			chn			- DMA channel number
1465:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1466:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1467:                	 * 										- SIRQEN: enable/disable the start IRQ action
1468:                	 * 										- PATEN: enable/disable the pattern match and abort
1469:                	 * 									or any of the DmaEvCtrlFlags:
1470:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1471:                	 *
1472:                	 *
1473:                	 * Output:          None
1474:                	 *
1475:                	 * Side Effects:    None
1476:                	 *
1477:                	 * Overview:		The function clears the events that start and abort the transfer
1478:                	 * 					for the selected DMA channel.
1479:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1480:                	 * 					disabled for the selected channel, the other channel event flags won't be touched.
1481:                	 *
1482:                	 * Note:            None.
1483:                	 *
1484:                	 * Example:			either:
1485:                	 * 						DmaChnClrEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN);
1486:                	 * 					or:
1487:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.AIRQEN=1;
1488:                	 * 						DmaChnClrEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1489:                	 *
1490:                	 ********************************************************************/
1491:                	 void			DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1492:                
1493:                
1494:                
1495:                	/*********************************************************************
1496:                	 * Function:        void DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1497:                	 *
1498:                	 * PreCondition:    chn	- valid DMA channel
1499:                	 *
1500:                	 * Input:			chn			- DMA channel number
1501:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1502:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1503:                	 * 										- SIRQEN: enable/disable the start IRQ action
1504:                	 * 										- PATEN: enable/disable the pattern match and abort
1505:                	 * 										- CHSIRQ: IRQ number to start the DMA channel transfer
1506:                	 * 										- CHAIRQ: IRQ number to abort the DMA channel transfer
1507:                	 * 									or any of the DmaEvCtrlFlags:
1508:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1509:                	 *
1510:                	 *
1511:                	 * Output:          None
1512:                	 *
1513:                	 * Side Effects:    None
1514:                	 *
1515:                	 * Overview:		The function writes the events that start and abort the transfer
1516:                	 * 					for the selected DMA channel.
1517:                	 *
1518:                	 * Note:            None.
1519:                	 *
1520:                	 * Example:			either:
1521:                	 * 						DmaChnWriteEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1522:                	 * 					or:
1523:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1524:                	 * 						DmaChnWriteEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1525:                	 *
1526:                	 ********************************************************************/
1527:                	 void			DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1528:                
1529:                
1530:                
1531:                	/*********************************************************************
1532:                	 * Function:        void DmaChnSetEventControl(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1533:                	 *
1534:                	 * PreCondition:    chn	- valid DMA channel
1535:                	 *
1536:                	 * Input:			chn			- DMA channel number
1537:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1538:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1539:                	 * 										- SIRQEN: enable/disable the start IRQ action
1540:                	 * 										- PATEN: enable/disable the pattern match and abort
1541:                	 * 										- CHSIRQ: IRQ number to start the DMA channel transfer
1542:                	 * 										- CHAIRQ: IRQ number to abort the DMA channel transfer
1543:                	 * 									or any of the DmaEvCtrlFlags:
1544:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1545:                	 *
1546:                	 *
1547:                	 * Output:          None
1548:                	 *
1549:                	 * Side Effects:    None
1550:                	 *
1551:                	 * Overview:		The function sets the events that start and abort the transfer
1552:                	 * 					for the selected DMA channel.
1553:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1554:                	 * 					enabled for the selected channel, the other channel event flags won't be touched.
1555:                	 *
1556:                	 * Note:           A shorter name for DmaChnWriteEventControlFlags();
1557:                	 *
1558:                	 * Example:			either:
1559:                	 * 						DmaChnSetEventControl(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1560:                	 * 					or:
1561:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1562:                	 * 						DmaChnSetEventControl(DMA_CHANNEL3, evCtrl.w);
1563:                	 *
1564:                	 ********************************************************************/
1565:                	#define			DmaChnSetEventControl(chn, dmaEvCtrl)	DmaChnWriteEventControlFlags(chn, dmaEvCtrl)
1566:                
1567:                
1568:                	/*********************************************************************
1569:                	 * Function:        DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn)
1570:                	 *
1571:                	 * PreCondition:    chn	- valid DMA channel
1572:                	 *
1573:                	 * Input:			chn		- DMA channel number
1574:                	 *
1575:                	 * Output:          - 	either a DmaEvCtrl structure field, carrying the following info:
1576:                	 * 							- AIRQEN: enable/disable the abort IRQ action
1577:                	 * 							- SIRQEN: enable/disable the start IRQ action
1578:                	 * 							- PATEN: enable/disable the pattern match and abort
1579:                	 * 							- CHSIRQ: IRQ number to start the DMA channel transfer
1580:                	 * 							- CHAIRQ: IRQ number to abort the DMA channel transfer
1581:                	 * 						or any of the DmaEvCtrlFlags:
1582:                	 * 							DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1583:                	 *
1584:                	 *
1585:                	 * Side Effects:    None
1586:                	 *
1587:                	 * Overview:		The function retrieves the events that start and abort the transfer
1588:                	 * 					for the selected DMA channel.
1589:                	 *
1590:                	 * Note:            None.
1591:                	 *
1592:                	 * Example:			either:
1593:                	 * 						DmaEvCtrlFlags evCtrlW=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrlW&DMA_EV_MATCH_EN) {...}
1594:                	 * 					or:
1595:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrl.PATEN){...}
1596:                	 *
1597:                	 ********************************************************************/
1598:                	 DmaEvCtrlFlags	DmaChnGetEventControl(DmaChannel chn);
1599:                
1600:                
1601:                	/*********************************************************************
1602:                	 * Function:        void DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1603:                	 *
1604:                	 * PreCondition:    chn	- valid DMA channel
1605:                	 *
1606:                	 * Input:			chn			- DMA channel number
1607:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1608:                	 * 										- autoEn: enable/disable the automatic mode
1609:                	 * 										- chainEn: enable/disable channel chaining
1610:                	 * 										- detectEn: enable/disable events detection when channel disabled
1611:                	 * 										- chEn: enable/disable channel functionality
1612:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1613:                	 * 									or any of the DmaChnCtrlFlags flags:
1614:                	 * 										DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1615:                	 *
1616:                	 * Output:          None
1617:                	 *
1618:                	 * Side Effects:    None
1619:                	 *
1620:                	 * Overview:		The function sets the selected DMA channel control flags:
1621:                	 * 					the chaining or auto mode, and events detection.
1622:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1623:                	 * 					set for the selected channel, the other channel control flags won't be touched.
1624:                	 *
1625:                	 * Note:            None.
1626:                	 *
1627:                	 * Example:			either:
1628:                	 * 						DmaChnSetControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1629:                	 * 					or:
1630:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1631:                	 * 						DmaChnSetControlFlags(DMA_CHANNEL3, chCtrl.w);
1632:                	 *
1633:                	 ********************************************************************/
1634:                	 void			DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1635:                
1636:                	/*********************************************************************
1637:                	 * Function:        void DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1638:                	 *
1639:                	 * PreCondition:    chn	- valid DMA channel
1640:                	 *
1641:                	 * Input:			chn			- DMA channel number
1642:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1643:                	 * 										- autoEn: enable/disable the automatic mode
1644:                	 * 										- chainEn: enable/disable channel chaining
1645:                	 * 										- detectEn: enable/disable events detection when channel disabled
1646:                	 * 										- chEn: enable/disable channel functionality
1647:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1648:                	 * 									or any of the DmaChnCtrlFlags flags:
1649:                	 * 										DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1650:                	 *
1651:                	 * Output:          None
1652:                	 *
1653:                	 * Side Effects:    None
1654:                	 *
1655:                	 * Overview:		The function clears the selected DMA channel control flags:
1656:                	 * 					the chaining or auto mode and events detection.
1657:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1658:                	 * 					cleared for the selected channel, the other channel control flags won't be touched.
1659:                	 *
1660:                	 * Note:            None.
1661:                	 *
1662:                	 * Example:			either:
1663:                	 * 						DmaChnClrControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1664:                	 * 					or:
1665:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1666:                	 * 						DmaChnClrControlFlags(DMA_CHANNEL3, chCtrl.w);
1667:                	 *
1668:                	 ********************************************************************/
1669:                	 void			DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1670:                
1671:                	/*********************************************************************
1672:                	 * Function:        void DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1673:                	 *
1674:                	 * PreCondition:    chn	- valid DMA channel
1675:                	 *
1676:                	 * Input:			chn			- DMA channel number
1677:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1678:                	 * 										- chPri: channel priority 0-3
1679:                	 * 										- autoEn: enable/disable the automatic mode
1680:                	 * 										- chainEn: enable/disable channel chaining
1681:                	 * 										- detectEn: enable/disable events detection when channel disabled
1682:                	 * 										- chEn: enable/disable channel functionality
1683:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1684:                	 * 									or any of the DmaChnCtrlFlags flags:
1685:                	 * 										DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1686:                	 *
1687:                	 * Output:          None
1688:                	 *
1689:                	 * Side Effects:    None
1690:                	 *
1691:                	 * Overview:		The function enables/disables the selected DMA channel and also sets
1692:                	 * 					the channel priority, chaining mode or auto and events detection.
1693:                	 *
1694:                	 * Note:            None.
1695:                	 *
1696:                	 * Example:			either:
1697:                	 * 						DmaChnWriteControlFlags(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1698:                	 * 					or:
1699:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1700:                	 * 						DmaChnWriteControlFlags(DMA_CHANNEL3, chCtrl.w);
1701:                	 *
1702:                	 ********************************************************************/
1703:                	 void			DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1704:                
1705:                	/*********************************************************************
1706:                	 * Function:        void DmaChnSetControl(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1707:                	 *
1708:                	 * PreCondition:    chn	- valid DMA channel
1709:                	 *
1710:                	 * Input:	    chn		- DMA channel number
1711:                	 *                  dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1712:                	 * 						- chPri: channel priority 0-3
1713:                	 * 						- autoEn: enable/disable the automatic mode
1714:                	 * 						- chainEn: enable/disable channel chaining
1715:                	 * 						- detectEn: enable/disable events detection when channel disabled
1716:                	 * 						- chEn: enable/disable channel functionality
1717:                	 * 						- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1718:                	 * 					or any of the DmaChnCtrlFlags flags:
1719:                	 * 						DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1720:                	 *
1721:                	 * Output:          None
1722:                	 *
1723:                	 * Side Effects:    None
1724:                	 *
1725:                	 * Overview:        The function enables/disables the selected DMA channel and also sets
1726:                	 * 					the channel priority, chaining mode or auto and events detection.
1727:                	 *
1728:                	 * Note:            Another name ( backward compatible) for DmaChnWriteControlFlags().
1729:                	 *
1730:                	 * Example:         either:
1731:                	 *                      DmaChnSetControl(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1732:                	 *                  or:
1733:                	 *                     	DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1734:                	 * 			DmaChnSetControl(DMA_CHANNEL3, chCtrl.w);
1735:                	 *
1736:                	 ********************************************************************/
1737:                	#define		DmaChnSetControl(chn, dmaChnCtrl)	DmaChnWriteControlFlags(chn, dmaChnCtrl)
1738:                
1739:                	/*********************************************************************
1740:                	 * Function:        DmaChnCtrlFlags DmaChnGetControlFlags(DmaChannel chn)
1741:                	 *
1742:                	 * PreCondition:    chn	- valid DMA channel
1743:                	 *
1744:                	 * Input:			chn			- DMA channel number
1745:                	 *
1746:                	 * Output:          - either a DmaChnCtrl structure field, carrying the following info:
1747:                	 * 							- chPri: channel priority 0-3
1748:                	 * 							- autoEn: enable/disable the automatic mode
1749:                	 * 							- chainEn: enable/disable channel chaining
1750:                	 * 							- detectEn: enable/disable events detection when channel disabled
1751:                	 * 							- chEn: enable/disable channel functionality
1752:                	 * 							- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1753:                	 *						or any of the DmaChnCtrlFlags flags:
1754:                	 *							DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1755:                	 *
1756:                	 * Side Effects:    None
1757:                	 *
1758:                	 * Overview:		The function retrieves the current control settings for the selected DMA channel,
1759:                	 * 					including the channel enable/disable status, the channel priority,
1760:                	 * 					chaining mode, auto mode and events detection.
1761:                	 *
1762:                	 * Note:            None.
1763:                	 *
1764:                	 * Example:			either:
1765:                	 * 						DmaChnCtrlFlags ctrl=DmaChnGetControlFlags(DMA_CHANNEL3); if(ctrl&DMA_CTL_AUTO_EN) {...}
1766:                	 * 					or:
1767:                	 * 						DmaChnCtrl chnCtrl; chnCtrl.w=DmaChnGetControlFlags(DMA_CHANNEL3); if(chnCtrl.autoEn) {...}
1768:                	 *
1769:                	 ********************************************************************/
1770:                	 DmaChnCtrlFlags	DmaChnGetControlFlags(DmaChannel chn);
1771:                
1772:                
1773:                	/*********************************************************************
1774:                	 * Function:        int DmaChnGetEvDetect(DmaChannel chn)
1775:                	 *
1776:                	 * PreCondition:    chn	- valid DMA channel
1777:                	 *
1778:                	 * Input:			chn		- DMA channel number
1779:                	 *
1780:                	 * Output:          TRUE if an DMA event was detected, FALSE otherwise.
1781:                	 *
1782:                	 * Side Effects:    None
1783:                	 *
1784:                	 * Overview:		The function returns the current event detection for the selected DMA channel.
1785:                	 *
1786:                	 * Note:            None.
1787:                	 *
1788:                	 * Example:			int evDetect=DmaChnGetEvDetect(DMA_CHANNEL3);
1789:                	 *
1790:                	 ********************************************************************/
1791:                	 int			DmaChnGetEvDetect(DmaChannel chn);
1792:                
1793:                	/*********************************************************************
1794:                	 * Function:        void DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0)
1795:                	 *
1796:                	 * PreCondition:    chn		- valid DMA channel
1797:                	 * 					pTxCtrl	- valid pointer
1798:                	 *
1799:                	 * Input:			chn			- DMA channel number
1800:                	 * 					pTxCtrl		- pointer to a DmaTxferCtrl that will carry the following info:
1801:                	 * 								- vSrcAdd: source of the DMA transfer
1802:                	 * 								- vDstAdd: destination of the DMA transfer
1803:                	 * 								- srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
1804:                	 * 								- dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
1805:                	 * 								- cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
1806:                	 *					mapToK0		- if TRUE, a Kernel address is mapped to KSeg0, else KSeg1.
1807:                	 *
1808:                	 * Output:          None
1809:                	 *
1810:                	 * Side Effects:    None
1811:                	 *
1812:                	 * Overview:		The function retrieves the transfer characteristics for a DMA channel transfer:
1813:                	 * 					the source and the destination addresses.
1814:                	 * 					It also retrieves the source and destination lengths
1815:                	 * 					and the number of bytes	transferred per event.
1816:                	 *
1817:                	 * Note:            None
1818:                	 *
1819:                	 * Example:			DmaTxferCtrl txCtl; DmaChnGetTxfer(DMA_CHANNEL3, &txCtl, FALSE);
1820:                	 ********************************************************************/
1821:                	 void			DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0);
1822:                
1823:                	// Low level checksum functions
1824:                
1825:                	/*********************************************************************
1826:                	 * Function:        void DmaSfmEnable(int enable)
1827:                	 *
1828:                	 * PreCondition:    None
1829:                	 *
1830:                	 * Input:           enable _ boolean to enable/disable the SFM functionality
1831:                	 *
1832:                	 * Output:          None
1833:                	 *
1834:                	 * Side Effects:    None
1835:                	 *
1836:                	 * Overview:        The function enables/diables the checksum module functionality.
1837:                	 *                  When enabled the attached DMA channel transfers are routed to the SFM module.
1838:                	 *
1839:                	 * Note:            The SFM module should be properly configured before enabled.
1840:                	 *
1841:                	 * Example:         DmaSfmEnable(1);
1842:                	 ********************************************************************/
1843:                	extern __inline__ void __attribute__((always_inline)) DmaSfmEnable(int enable)
1844:                	{
1845:                		if(enable)
1846:                		{
1847:                			DCRCCONSET=_DCRCCON_CRCEN_MASK;
1848:                		}
1849:                		else
1850:                		{
1851:                			DCRCCONCLR=_DCRCCON_CRCEN_MASK;
1852:                		}
1853:                	}
1854:                	#define DmaCrcEnable	DmaSfmEnable		// PIC32_3xx backward compatibility
1855:                
1856:                
1857:                	/*********************************************************************
1858:                	 * Function:        int DmaSfmGetEnable(void)
1859:                	 *
1860:                	 * PreCondition:    None
1861:                	 *
1862:                	 * Input:			None
1863:                	 *
1864:                	 * Output:          TRUE, if the SFM module is enabled
1865:                	 * 		    FALSE otherwise
1866:                	 *
1867:                	 * Side Effects:    None
1868:                	 *
1869:                	 * Overview:		The function returns the SFM module enabling status.
1870:                	 *
1871:                	 * Note:            None
1872:                	 *
1873:                	 * Example:	    int isSfmEnabled=DmaSfmGetEnable();
1874:                	 ********************************************************************/
1875:                	extern __inline__ int __attribute__((always_inline)) DmaSfmGetEnable(void)
1876:                	{
1877:                		return DCRCCONbits.CRCEN!=0;
1878:                	}
1879:                	#define		DmaCrcGetEnable 	DmaSfmGetEnable		// PIC32_3xx backward compatibility
1880:                
1881:                
1882:                	/*********************************************************************
1883:                	 * Function:        void DmaSfmAppendEnable(int enable)
1884:                	 *
1885:                	 * PreCondition:    None
1886:                	 *
1887:                	 * Input:           enable _ boolean to enable/disable the SFM append mode
1888:                	 *
1889:                	 * Output:          None
1890:                	 *
1891:                	 * Side Effects:    None
1892:                	 *
1893:                	 * Overview:        The function enables the SFM append mode. In this mode, the attached DMA channel reads
1894:                	 *                  the source data but does not write it to the destination address. The data it's just passed
1895:                	 *                  to the checksum generator for CRC/IP checksum calculation.
1896:                	 *                  When the block transfer is completed, the checksum result is written to the
1897:                	 *                  DMA channel destination address.
1898:                	 *
1899:                	 * Note:            The SFM module should be properly configured before enabled.
1900:                	 *
1901:                	 * Example:         DmaSfmAppendModeEnable(TRUE);
1902:                	 ********************************************************************/
1903:                	extern __inline__ void __attribute__((always_inline)) DmaSfmAppendEnable(int enable)
1904:                	{
1905:                		if(enable)
1906:                		{
1907:                			DCRCCONSET=_DCRCCON_CRCAPP_MASK;
1908:                		}
1909:                		else
1910:                		{
1911:                			DCRCCONCLR=_DCRCCON_CRCAPP_MASK;
1912:                		}
1913:                	}
1914:                	#define		DmaCrcAppendModeEnable	DmaSfmAppendEnable	// PIC32_3xx backward compatibility
1915:                
1916:                
1917:                	/*********************************************************************
1918:                	 * Function:        int DmaSfmGetAppendMode(void)
1919:                	 *
1920:                	 * PreCondition:    None
1921:                	 *
1922:                	 * Input:           None
1923:                	 *
1924:                	 * Output:          TRUE, if the SFM append mode is enabled
1925:                	 *                  FALSE otherwise
1926:                	 *
1927:                	 * Side Effects:    None
1928:                	 *
1929:                	 * Overview:        The function returns the SFM module enabling status.
1930:                	 *
1931:                	 * Note:            None
1932:                	 *
1933:                	 * Example:         int isAppendEnabled=DmaSfmGetAppendMode();
1934:                	 ********************************************************************/
1935:                	extern __inline__ int __attribute__((always_inline)) DmaSfmGetAppendMode(void)
1936:                	{
1937:                		return DCRCCONbits.CRCAPP!=0;
1938:                	}
1939:                	#define	DmaCrcGetAppendMode	DmaSfmGetAppendMode		// PIC32_3xx backward compatibility
1940:                
1941:                
1942:                	/*********************************************************************
1943:                	 * Function:        void DmaSfmSetAttach(DmaChannel chn)
1944:                	 *
1945:                	 * PreCondition:    chn		- valid DMA channel
1946:                	 *
1947:                	 * Input:           chn	- the DMA channel to be attached to the SFM module (the DMA channel transfers will be routed to the SFM module)
1948:                	 *
1949:                	 * Output:          None
1950:                	 *
1951:                	 * Side Effects:    None
1952:                	 *
1953:                	 * Overview:        The function directly attaches a DMA channel to the SFM module.
1954:                	 *
1955:                	 * Note:            None
1956:                	 *
1957:                	 * Example:         DmaSfmSetAttach(DMA_CHANNEL3);
1958:                	 ********************************************************************/
1959:                	extern __inline__ void __attribute__((always_inline)) DmaSfmSetAttach(DmaChannel chn)
1960:                	{
1961:                		DCRCCONCLR=_DCRCCON_CRCCH_MASK;
1962:                		DCRCCONSET=chn;
1963:                	}
1964:                	#define		DmaCrcSetAttach		DmaSfmSetAttach		// PIC32_3xx backward compatibility
1965:                
1966:                
1967:                	/*********************************************************************
1968:                	 * Function:        DmaChannel DmaSfmGetAttach(void)
1969:                	 *
1970:                	 * PreCondition:    None
1971:                	 *
1972:                	 * Input:           None
1973:                	 *
1974:                	 * Output:          the DMA channel that is currently attached to the CRC module
1975:                	 *
1976:                	 * Side Effects:    None
1977:                	 *
1978:                	 * Overview:        The function returns the DMA channel number that is currently attached to the SFM module.
1979:                	 *
1980:                	 * Note:            None
1981:                	 *
1982:                	 * Example:         DmaChannel chn=DmaSfmGetAttach();
1983:                	 ********************************************************************/
1984:                	extern __inline__ DmaChannel __attribute__((always_inline)) DmaSfmGetAttach(void)
1985:                	{
1986:                		return (DmaChannel)DCRCCONbits.CRCCH;
1987:                	}
1988:                	#define		DmaCrcGetAttach		DmaSfmGetAttach		// PIC32_3xx backward compatibility
1989:                
1990:                	/*********************************************************************
1991:                	 * Function:        void DmaCrcSetPLen(int pLen)
1992:                	 *
1993:                	 * PreCondition:    pLen - valid polynomial length within 1-32
1994:                	 *
1995:                	 * Input:           pLen	- the length of the CRC generator polynomial
1996:                	 *
1997:                	 * Output:          None
1998:                	 *
1999:                	 * Side Effects:    None
2000:                	 *
2001:                	 * Overview:        The length of the CRC generator polynomial is set as being pLen;
2002:                	 *
2003:                	 * Note:            None
2004:                	 *
2005:                	 * Example:         DmaCrcSetPLen(32);
2006:                	 ********************************************************************/
2007:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetPLen(int pLen)
2008:                	{
2009:                		DCRCCONCLR=_DCRCCON_PLEN_MASK;
2010:                		DCRCCONSET=(pLen)-1;
2011:                	}
2012:                
2013:                	/*********************************************************************
2014:                	 * Function:        int DmaCrcGetPLen(void)
2015:                	 *
2016:                	 * PreCondition:    None
2017:                	 *
2018:                	 * Input:           None
2019:                	 *
2020:                	 * Output:          the length of the CRC generator polynomial
2021:                	 *
2022:                	 * Side Effects:    None
2023:                	 *
2024:                	 * Overview:        The function returns the current length of the CRC generator polynomial.
2025:                	 *                  It's always a number between 1 and 32.
2026:                	 *
2027:                	 * Note:            None
2028:                	 *
2029:                	 * Example:         int polyLen=DmaCrcGetPLen();
2030:                	 ********************************************************************/
2031:                	extern __inline__ int __attribute__((always_inline)) DmaCrcGetPLen(void)
2032:                	{
2033:                		return	DCRCCONbits.PLEN+1; 
2034:                	}
2035:                
2036:                	/*********************************************************************
2037:                	 * Function:        void DmaCrcSetShiftFeedback(unsigned int feedback)
2038:                	 *
2039:                	 * PreCondition:    None
2040:                	 *
2041:                	 * Input:           feedback - the layout of the CRC generator
2042:                	 *
2043:                	 * Output:          None
2044:                	 *
2045:                	 * Side Effects:    None
2046:                	 *
2047:                	 * Overview:        The function sets the layout of the shift stages that take place in the CRC generation.
2048:                	 *                  Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2049:                	 *                  If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2050:                	 *
2051:                	 * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2052:                	 *
2053:                	 * Example:         DmaCrcSetShiftFeedback(0x04c11db7);
2054:                	 ********************************************************************/
2055:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetShiftFeedback(unsigned int feedback)
2056:                	{
2057:                		DCRCXOR=feedback;
2058:                	}
2059:                
2060:                
2061:                	/*********************************************************************
2062:                	 * Function:        unsigned int DmaCrcGetShiftFeedback(void)
2063:                	 *
2064:                	 * PreCondition:    None
2065:                	 *
2066:                	 * Input:           None
2067:                	 *
2068:                	 * Output:          the current layout of the CRC generator
2069:                	 *
2070:                	 * Side Effects:    None
2071:                	 *
2072:                	 * Overview:        The function returns the layout of the shift stages that take place in the CRC generation.
2073:                	 *                  A bit set to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2074:                	 *                  If a bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2075:                	 *
2076:                	 * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2077:                	 *
2078:                	 * Example:         int feedback=DmaCrcGetShiftFeedback();
2079:                	 ********************************************************************/
2080:                	extern __inline__ unsigned int __attribute__((always_inline)) DmaCrcGetShiftFeedback(void)
2081:                	{
2082:                		return DCRCXOR;
2083:                	}
2084:                
2085:                
2086:                
2087:                	// Channel test/debug and special functions
2088:                
2089:                	/*********************************************************************
2090:                	 * Function:        void DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2091:                	 *
2092:                	 * PreCondition:    chn	- valid DMA channel
2093:                	 *
2094:                	 * Input:			chn		- DMA channel number
2095:                	 * 					eFlags	- event flags with the following significance:
2096:                	 * 								- DMA_EV_ERR: address error event
2097:                	 * 								- DMA_EV_ABORT: transfer abort event
2098:                	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
2099:                	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
2100:                	 * 								- DMA_EV_DST_HALF: destination half event
2101:                	 * 								- DMA_EV_DST_FULL: destination full event
2102:                	 * 								- DMA_EV_SRC_HALF: source half event
2103:                	 * 								- DMA_EV_SRC_FULL: source full event
2104:                	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
2105:                	 *
2106:                	 * Output:          None
2107:                	 *
2108:                	 * Side Effects:    None
2109:                	 *
2110:                	 * Overview:		The function sets the event flags for the selected DMA channel.
2111:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
2112:                	 * 					set for the selected channel, the other channel event flags won't be touched.
2113:                	 *
2114:                	 * Note:            This is intended as a channel test function.
2115:                	 *
2116:                	 * Example:			DmaChnSetEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2117:                	 ********************************************************************/
2118:                	 void			DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2119:                
2120:                	/*********************************************************************
2121:                	 * Function:        void DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2122:                	 *
2123:                	 * PreCondition:    chn	- valid DMA channel
2124:                	 *
2125:                	 * Input:			chn		- DMA channel number
2126:                	 * 					eFlags	- event flags with the following significance:
2127:                	 * 								- DMA_EV_ERR: address error event
2128:                	 * 								- DMA_EV_ABORT: transfer abort event
2129:                	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
2130:                	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
2131:                	 * 								- DMA_EV_DST_HALF: destination half event
2132:                	 * 								- DMA_EV_DST_FULL: destination full event
2133:                	 * 								- DMA_EV_SRC_HALF: source half event
2134:                	 * 								- DMA_EV_SRC_FULL: source full event
2135:                	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
2136:                	 *
2137:                	 * Output:          None
2138:                	 *
2139:                	 * Side Effects:    None
2140:                	 *
2141:                	 * Overview:		The function writes the event flags for the selected DMA channel.
2142:                	 * 					The channel event flags are forced to the eFlags value.
2143:                	 *
2144:                	 * Note:            This is intended as a channel test function.
2145:                	 *
2146:                	 * Example:			DmaChnWriteEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2147:                	 ********************************************************************/
2148:                	 void			DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2149:                
2150:                
2151:                	/********************************************************************
2152:                	 * Include legacy DMA functions
2153:                	 * New projects should not use them!
2154:                	 * Note that interrupt functions are no longer provided.
2155:                	 * The functions in the int.h should be used instead.
2156:                	 ********************************************************************/
2157:                	#ifndef _PLIB_DISABLE_LEGACY
2158:                		#include <peripheral/legacy/dma_legacy.h>
2159:                	#endif
2160:                
2161:                
2162:                #else
2163:                	#undef _DMA_CHANNELS		// no DMA channels
2164:                #endif	// _DMAC0
2165:                
2166:                #endif /*_DMA_H_*/
2167:                
2168:                
